This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: _private, .specstory, .venv
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    nyord-vpn.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  nyord_vpn/
    core/
      __init__.py
      api.py
      base.py
      client.py
    data/
      countries.json
      country_ids.json
    network/
      __init__.py
      country.py
      server.py
      vpn_commands.py
      vpn.py
    scripts/
      __init__.py
      update_countries.py
    storage/
      models.py
      state.py
    utils/
      __init__.py
      connection.py
      templates.py
      utils.py
    __init__.py
    __main__.py
    exceptions.py
tests/
  integration/
    __init__.py
    test_config_loading.py
    test_connection.py
    test_errors.py
    test_validation_integration.py
  __init__.py
  conftest.py
  test_client.py
  test_legacy_api.py
  test_package.py
.gitignore
.pre-commit-config.yaml
LICENSE
package.toml
pyproject.toml
README.md
TODO.md

================================================================
Files
================================================================

================
File: .cursor/rules/nyord-vpn.mdc
================
---
description: nyord-vpn
globs: 
---
# nyord-vpn

A modern Python client for NordVPN with automatic API fallback support, providing both a CLI interface and a Python library.

```bash
# Install system requirements first
brew install openvpn  # macOS
sudo apt install openvpn  # Ubuntu/Debian
sudo dnf install openvpn  # Fedora/RHEL

# Then install and use the package
pip install nyord-vpn
export NORD_USER="username" NORD_PASSWORD="password"
nyord-vpn connect de  # Connect to a German VPN
nyord-vpn status  # Check status
nyord-vpn disconnect  # Disconnect
```

## DEVELOPMENT

After each set of changes, update @TODO.md with what you've done (`- [x] `). Upgrade priorities for NEXT TODO (`- [!]`), re-think the normal TODO (`- [ ] `)

Periodically do:

```
uv venv; source .venv/bin/activate; uv pip install -e .[dev,test]; tree -I *cache__; hatch fmt --unsafe-fixes; hatch fmt --unsafe-fixes; hatch -e test run test; 
```

and react to the results. Use `uv pip...` instead of `pip...` if needed.

================
File: .github/workflows/push.yml
================
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/nyord-vpn
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/nyord_vpn/core/__init__.py
================
"""Core modules for nyord-vpn.

this_file: src/nyord_vpn/core/__init__.py

This package contains the core functionality including
the main Client class and API interactions.
"""

================
File: src/nyord_vpn/core/api.py
================
"""NordVPN API client for data retrieval and API interactions.

this_file: src/nyord_vpn/core/api.py

This module provides the NordVPNAPIClient class for interacting with NordVPN's API.
It handles all API-related operations and caching to ensure reliable data access.

Core Responsibilities:
1. Authentication with NordVPN API
2. Country and server information retrieval
3. Cache management for API responses
4. Location and city information lookup
5. API connectivity testing

Integration Points:
- Used by Client (core/client.py) for API operations
- Used by ServerManager (network/server.py) for server info
- Interacts with cache system in utils/utils.py
- Handles models defined in storage/models.py

The client implements automatic fallback to cached data when
API requests fail, and provides both raw and formatted data
access methods. This ensures continuous operation even during
API outages or rate limiting.

Cache Management:
- Stores data in ~/.cache/nyord-vpn/
- Implements TTL-based cache invalidation
- Provides fallback data for core countries
- Handles cache corruption gracefully

Error Handling:
- Provides detailed error messages
- Implements automatic retries
- Falls back to cached data
- Logs failures for debugging
"""

import time

from loguru import logger
from requests import get, RequestException

from nyord_vpn.network.country import get_cached_countries, cache_countries
from nyord_vpn.storage.models import City, Country, CountryCache
from nyord_vpn.utils.utils import API_HEADERS, CACHE_FILE


class NordVPNAPIClient:
    """Base client for NordVPN API interactions.

    This class provides a comprehensive interface to the NordVPN API:
    1. Server and country information retrieval
    2. Location-based server lookup
    3. Cache management for API responses
    4. Connectivity testing and monitoring

    The client handles both v1 and v2 API endpoints, with automatic
    fallback to cached data when API requests fail. It provides
    methods for both raw data access and formatted information
    suitable for display.

    Attributes:
        BASE_API_URL: Base URL for NordVPN API
        BASE_API_V1_URL: Base URL for v1 API endpoints
        BASE_API_V2_URL: Base URL for v2 API endpoints

    """

    BASE_API_URL: str = "https://api.nordvpn.com"
    BASE_API_V1_URL: str = f"{BASE_API_URL}/v1"
    BASE_API_V2_URL: str = f"{BASE_API_URL}/v2"

    def __init__(self, username: str, password: str, verbose: bool = False) -> None:
        """Initialize the NordVPN API client.

        Sets up the client with authentication and configuration:
        1. Stores credentials for API authentication
        2. Configures logging based on verbosity
        3. Sets up cache file location
        4. Initializes API interaction settings

        Args:
            username: NordVPN account username
            password: NordVPN account password
            verbose: Enable detailed logging (default: False)

        Note:
            The client doesn't validate credentials on initialization.
            Validation occurs on first API interaction.

        """
        self.username = username
        self.password = password
        self.verbose = verbose
        self.logger = logger
        self.cache_file = CACHE_FILE

    def list_countries(self, use_cache: bool = True) -> list[Country]:
        """Fetch list of available server countries.

        Retrieves a comprehensive list of countries with servers:
        1. Attempts to fetch fresh data from API
        2. Updates local cache with new data
        3. Falls back to cached data if API fails
        4. Includes server counts and city information

        Args:
            use_cache: Whether to allow using cached data (default: True)

        Returns:
            list[Country]: List of countries with their details:
                - name: Country name
                - code: Two-letter country code
                - id: Country identifier
                - cities: List of cities with servers
                - serverCount: Total servers in country

        Note:
            The method automatically updates the cache with fresh data
            on successful API requests. Cache format matches API response
            to ensure consistency.

        """
        try:
            url = f"{self.BASE_API_URL}/servers/countries"
            response = get(url, headers=API_HEADERS, timeout=10)
            response.raise_for_status()
            countries: list[Country] = response.json()

            cache_data: CountryCache = {
                "countries": countries,
                "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            }
            cache_countries(cache_data)
            return countries

        except RequestException as e:
            self.logger.warning(f"Failed to fetch countries: {e}")
            cached = get_cached_countries()
            if cached:
                return cached["countries"]
            return []

    def get_country_by_code(self, code: str) -> Country | None:
        """Find country information by country code.

        Searches for a country using its ISO code:
        1. Converts code to uppercase for consistency
        2. Searches in available countries list
        3. Returns full country information if found

        Args:
            code: Two-letter country code (case insensitive)

        Returns:
            Country | None: Country information if found:
                - name: Country name
                - code: Two-letter country code
                - id: Country identifier
                - cities: List of cities with servers
                - serverCount: Total servers in country
            Returns None if country not found.

        Note:
            This method uses list_countries() internally, so it may
            trigger an API request if no cached data is available.

        """
        code = code.upper()
        for country in self.list_countries():
            if country["code"] == code:
                return country
        return None

    def get_country_by_name(self, name: str) -> Country | None:
        """Get country info by name."""
        name = name.lower()
        for country in self.list_countries():
            if country["name"].lower() == name:
                return country
        return None

    def get_available_locations(self) -> list[str]:
        """Get formatted list of available locations."""
        locations = []
        for country in sorted(self.list_countries(), key=lambda x: x["name"]):
            total_servers = country["serverCount"]
            locations.append(
                f"{country['name']} ({country['code'].lower()}) - {total_servers} servers",
            )
            for city in sorted(country["cities"], key=lambda x: x["name"]):
                locations.append(f"  {city['name']} - {city['serverCount']} servers")
        return locations

    def get_best_city(self, country_code: str) -> City | None:
        """Find optimal city for VPN connection in a country.

        Selects the best city based on multiple factors:
        1. Hub score (network infrastructure quality)
        2. Number of available servers
        3. Geographic distribution
        4. Server performance metrics

        Args:
            country_code: Two-letter country code

        Returns:
            City | None: Best city information if found:
                - name: City name
                - dns_name: DNS hostname component
                - hub_score: Infrastructure quality score
                - serverCount: Available servers
                - latitude/longitude: Geographic coordinates
            Returns None if country not found or has no cities.

        Note:
            The hub score is a NordVPN metric combining various
            factors like infrastructure quality, server capacity,
            and network performance.

        """
        country = self.get_country_by_code(country_code)
        if not country:
            return None
        sorted_cities = sorted(
            country["cities"],
            key=lambda x: (x["hub_score"], x["serverCount"]),
            reverse=True,
        )
        return sorted_cities[0] if sorted_cities else None

    def test_api_connectivity(self) -> bool:
        """Test connectivity to NordVPN API.

        Performs a basic health check of the API:
        1. Attempts to fetch server list
        2. Verifies response format
        3. Checks response timing
        4. Validates API version compatibility

        Returns:
            bool: True if API is accessible and responding correctly,
                 False if any connectivity issues are detected

        Note:
            This method is used during initialization and can be
            called periodically to verify API health. It uses a
            short timeout to quickly detect connectivity issues.

        """
        try:
            response = get(
                f"{self.BASE_API_V2_URL}/servers",
                headers=API_HEADERS,
                timeout=5,
            )
            response.raise_for_status()
            return True
        except Exception as e:
            if self.verbose:
                self.logger.exception(f"API connectivity test failed: {e}")
            return False

================
File: src/nyord_vpn/core/base.py
================
"""Base NordVPN client implementation.

This module contains the base NordVPN client class that handles:
- Country list management
- Cache handling
- Location lookup
- API interaction

This class is extended by the main Client class to add connection functionality.
"""

import json
import sys
import time

import requests
from loguru import logger

from nyord_vpn.network.country import get_cached_countries, cache_countries
from nyord_vpn.storage.models import City, Country, CountryCache
from nyord_vpn.utils.utils import CACHE_FILE, API_HEADERS

# Fallback data in case API is unreachable
FALLBACK_DATA: CountryCache = {
    "countries": [
        {
            "cities": [
                {
                    "dns_name": "new-york",
                    "hub_score": 0,
                    "id": 8971718,
                    "latitude": 40.7141667,
                    "longitude": -74.0063889,
                    "name": "New York",
                    "serverCount": 529,
                },
            ],
            "code": "US",
            "id": 228,
            "name": "United States",
            "serverCount": 529,
        },
        {
            "cities": [
                {
                    "dns_name": "london",
                    "hub_score": 0,
                    "id": 2989907,
                    "latitude": 51.514125,
                    "longitude": -0.093689,
                    "name": "London",
                    "serverCount": 785,
                },
            ],
            "code": "GB",
            "id": 227,
            "name": "United Kingdom",
            "serverCount": 785,
        },
        {
            "cities": [
                {
                    "dns_name": "frankfurt",
                    "hub_score": 0,
                    "id": 2215709,
                    "latitude": 50.116667,
                    "longitude": 8.683333,
                    "name": "Frankfurt",
                    "serverCount": 301,
                },
            ],
            "code": "DE",
            "id": 81,
            "name": "Germany",
            "serverCount": 301,
        },
    ],
    "last_updated": "2024-02-23T00:00:00Z",
}


class NordVPNClient:
    """Base NordVPN client for managing country data and API interactions."""

    BASE_API_URL: str = "https://api.nordvpn.com/v1"

    def __init__(self, username: str, password: str, verbose: bool = False) -> None:
        """Initialize NordVPN client.

        Args:
            username: NordVPN username
            password: NordVPN password
            verbose: Whether to enable verbose logging

        """
        self.username = username
        self.password = password
        self.verbose = verbose
        self.logger = logger
        self.cache_file = CACHE_FILE
        self.countries = self._load_countries()
        self.logger.add(sys.stdout, level="DEBUG" if self.verbose else "INFO")

    def _load_countries(self) -> list[Country]:
        """Load countries from cache or fallback data."""
        try:
            with open(self.cache_file) as f:
                cache_data: CountryCache = json.load(f)
                return cache_data["countries"]
        except (FileNotFoundError, json.JSONDecodeError) as e:
            self.logger.warning(f"Failed to load cache: {e}. Using fallback data.")
            return FALLBACK_DATA["countries"]

    def get_country_by_code(self, code: str) -> Country | None:
        """Get country by its code.

        Args:
            code: Two-letter country code (e.g. 'us', 'uk')

        """
        code = code.upper()
        for country in self.countries:
            if country["code"] == code:
                return country
        return None

    def get_country_by_name(self, name: str) -> Country | None:
        """Get country by its name.

        Args:
            name: Country name (case-insensitive)

        """
        name = name.lower()
        for country in self.countries:
            if country["name"].lower() == name:
                return country
        return None

    def get_available_locations(self) -> list[str]:
        """Get list of available locations with server counts."""
        locations = []
        for country in sorted(self.countries, key=lambda x: x["name"]):
            total_servers = country["serverCount"]
            locations.append(
                f"{country['name']} ({country['code'].lower()}) - {total_servers} servers",
            )
            for city in sorted(country["cities"], key=lambda x: x["name"]):
                locations.append(f"  {city['name']} - {city['serverCount']} servers")
        return locations

    def get_best_city(self, country_code: str) -> City | None:
        """Get the best city in a country based on hub score and server count.

        Args:
            country_code: Two-letter country code

        """
        country = self.get_country_by_code(country_code)
        if not country:
            return None

        # Sort cities by hub score (higher is better) and server count
        sorted_cities = sorted(
            country["cities"],
            key=lambda x: (x["hub_score"], x["serverCount"]),
            reverse=True,
        )
        return sorted_cities[0] if sorted_cities else None

    def list_countries(self, use_cache: bool = True) -> list[Country]:
        """Fetch a list of all available server countries from the NordVPN API.

        Args:
            use_cache: Whether to use cached country list (default: True)
                     If False, forces a fresh fetch from the API

        Returns:
            List of dictionaries containing country information

        """
        try:
            url = f"{self.BASE_API_URL}/servers/countries"
            response = requests.get(url, headers=API_HEADERS, timeout=10)
            response.raise_for_status()
            countries: list[Country] = response.json()

            # Cache the fresh data
            cache_data: CountryCache = {
                "countries": countries,
                "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            }
            cache_countries(cache_data)
            return countries

        except requests.RequestException as e:
            self.logger.warning(f"Failed to fetch countries: {e}")
            cached = get_cached_countries()
            if cached:
                return cached["countries"]

            # If no cache available, use fallback list
            return FALLBACK_DATA["countries"]

================
File: src/nyord_vpn/core/client.py
================
"""Main NordVPN client implementation.

this_file: src/nyord_vpn/core/client.py

This module contains the main Client class that coordinates all VPN operations.
It serves as the primary entry point for both CLI and library usage, orchestrating:

Components:
- API interactions via NordVPNAPIClient (core/api.py) for authentication and server info
- VPN connections via VPNConnectionManager (network/vpn.py) for OpenVPN management
- Server selection via ServerManager (network/server.py) for optimal server choice
- State persistence via utils/utils.py for connection recovery

The client implements automatic fallback mechanisms and retry logic to handle:
1. API failures (falls back to cached data)
2. Connection failures (retries with different servers)
3. State management (persists and recovers connection state)
4. Error handling (provides detailed error messages and recovery steps)

Used by:
- CLI interface in __main__.py for command-line operations
- Python applications importing the Client class directly
- Internal test suite for integration testing

Example usage:
    from nyord_vpn import Client

    client = Client(username="user", password="pass")
    client.go("us")  # Connect to US server
    client.status()  # Check connection status
    client.disconnect()  # Disconnect from VPN
"""

import os
import sys
import time
from pathlib import Path
from typing import TypedDict, Any, cast

import requests
from dotenv import load_dotenv
from loguru import logger
from rich.console import Console
from rich.logging import RichHandler

from nyord_vpn.storage.models import (
    ConnectionError,
    CredentialsError,
    VPNError,
)
from nyord_vpn.utils.utils import (
    API_HEADERS,
    CACHE_DIR,
    CONFIG_DIR,
    DATA_DIR,
    save_vpn_state,
    check_root,
    ensure_root,
)
from nyord_vpn.network.server import ServerManager
from nyord_vpn.core.api import NordVPNAPIClient
from nyord_vpn.network.vpn import VPNConnectionManager

load_dotenv()
logger.configure(
    handlers=[
        {
            "sink": RichHandler(),
            "format": "<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        },
    ],
)


# Constants
PACKAGE_DIR = Path(__file__).parent
CACHE_FILE = DATA_DIR / "countries.json"

# Rich console for pretty output
console = Console()


# Store cache in the package directory
COUNTRIES_CACHE = PACKAGE_DIR / "data" / "countries.json"


# Type definitions for country data
class City(TypedDict):
    """City information from NordVPN API."""

    dns_name: str
    hub_score: int
    id: int
    latitude: float
    longitude: float
    name: str
    serverCount: int


class Country(TypedDict):
    """Country information from NordVPN API."""

    cities: list[City]
    code: str
    id: int
    name: str
    serverCount: int


class CountryCache(TypedDict):
    """Cache file structure."""

    countries: list[Country]
    last_updated: str


# Fallback country list in case API is unreachable
FALLBACK_DATA: CountryCache = {
    "countries": [
        {
            "cities": [
                {
                    "dns_name": "new-york",
                    "hub_score": 0,
                    "id": 8971718,
                    "latitude": 40.7141667,
                    "longitude": -74.0063889,
                    "name": "New York",
                    "serverCount": 529,
                },
            ],
            "code": "US",
            "id": 228,
            "name": "United States",
            "serverCount": 529,
        },
        {
            "cities": [
                {
                    "dns_name": "london",
                    "hub_score": 0,
                    "id": 2989907,
                    "latitude": 51.514125,
                    "longitude": -0.093689,
                    "name": "London",
                    "serverCount": 785,
                },
            ],
            "code": "GB",
            "id": 227,
            "name": "United Kingdom",
            "serverCount": 785,
        },
        {
            "cities": [
                {
                    "dns_name": "frankfurt",
                    "hub_score": 0,
                    "id": 2215709,
                    "latitude": 50.116667,
                    "longitude": 8.683333,
                    "name": "Frankfurt",
                    "serverCount": 301,
                },
            ],
            "code": "DE",
            "id": 81,
            "name": "Germany",
            "serverCount": 301,
        },
    ],
    "last_updated": "2024-02-23T00:00:00Z",
}

# Cache expiry in seconds (24 hours)
CACHE_EXPIRY = 24 * 60 * 60


class Client:
    """Main NordVPN client that coordinates API, VPN, and server management.

    This class provides the high-level interface for:
    1. Managing VPN connections
    2. Server selection and optimization
    3. Connection status monitoring
    4. User feedback and logging
    """

    def __init__(self, username_str: str, password_str: str, verbose: bool = False):
        """Initialize NordVPN client.

        Args:
            username_str: NordVPN username
            password_str: NordVPN password
            verbose: Whether to enable verbose output
        """
        self.verbose = verbose
        self.logger = logger
        self.api_client = NordVPNAPIClient(username_str, password_str, verbose)
        self.vpn_manager = VPNConnectionManager(verbose=verbose)
        self.server_manager = ServerManager(self.api_client)

    def is_protected(self) -> bool:
        """Check if VPN is active."""
        status = self.status()
        return status.get("connected", False)

    def status(self) -> dict[str, Any]:
        """Get current VPN status.

        Returns:
            dict: Status information including:
                - connected (bool): Whether connected to VPN
                - ip (str): Current IP address
                - normal_ip (str): IP when not connected to VPN
                - server (str): Connected server if any
                - country (str): Connected country if any
        """
        return self.vpn_manager.status()

    def go(self, country_code: str) -> None:
        """Connect to VPN in specified country.

        Args:
            country_code: Two-letter country code (e.g. 'US', 'GB')

        Raises:
            VPNError: If connection fails
        """
        if not check_root():
            ensure_root()
            return

        try:
            # First check if we're already connected
            status = self.status()
            if status.get("connected", False):
                console.print("[yellow]Already connected to VPN.[/yellow]")
                console.print(f"Current IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
                console.print(
                    f"Country: [cyan]{status.get('country', 'Unknown')}[/cyan]"
                )
                console.print(f"Server: [cyan]{status.get('server', 'Unknown')}[/cyan]")
                console.print("\n[yellow]Please disconnect first with:[/yellow]")
                console.print("[blue]nyord-vpn bye[/blue]")
                return

            # Select fastest server
            server = self.server_manager.select_fastest_server(country_code)
            if not server:
                raise VPNError(f"No servers available in {country_code}")

            hostname = server.get("hostname")
            if not hostname:
                raise VPNError("Selected server has no hostname")

            if self.verbose:
                self.logger.info(f"Selected server: {hostname}")
                console.print(f"Selected server: [cyan]{hostname}[/cyan]")

            # Set up VPN configuration
            self.vpn_manager.setup_connection(
                hostname, self.api_client.username, self.api_client.password
            )

            # Connect to VPN
            if self.verbose:
                self.logger.info("Establishing VPN connection...")
                console.print("Establishing VPN connection...")

            # Connect and wait for result
            self.vpn_manager.connect(server)

            # Get status for display
            status = self.status()
            if self.verbose:
                self.logger.info("Successfully connected to VPN")
                self.logger.info(f"New IP: {status.get('ip', 'Unknown')}")
            console.print("[green]Successfully connected to VPN[/green]")
            console.print(f"New IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
            console.print(f"Country: [cyan]{status.get('country', 'Unknown')}[/cyan]")
            console.print(f"Server: [cyan]{status.get('server', 'Unknown')}[/cyan]")

        except Exception as e:
            if isinstance(e, VPNError):
                raise
            raise VPNError(f"Failed to connect: {str(e)}")

    def bye(self) -> None:
        """Disconnect from VPN."""
        if not check_root():
            ensure_root()
            return

        try:
            # First check if we're actually connected
            status = self.status()
            if not status.get("connected", False):
                console.print("[yellow]Not connected to VPN[/yellow]")
                console.print(
                    f"Public IP: [cyan]{status.get('normal_ip', 'Unknown')}[/cyan]"
                )
                return

            # Store the current IP for display
            current_ip = status.get("ip", "Unknown")

            # Disconnect
            self.vpn_manager.disconnect()

            # Get new status for display
            status = self.status()
            console.print("[green]Successfully disconnected from VPN[/green]")
            console.print(
                f"Public IP: [cyan]{status.get('normal_ip', 'Unknown')}[/cyan]"
            )
            console.print(f"Previous IP: [yellow]{current_ip}[/yellow]")

        except Exception as e:
            raise VPNError(f"Failed to disconnect: {e}")

    def info(self) -> None:
        """Display current VPN status."""
        try:
            status = self.status()
            if status.get("connected", False):
                console.print("[green]VPN Status: Connected[/green]")
                console.print(f"Current IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
                console.print(
                    f"Country: [cyan]{status.get('country', 'Unknown')}[/cyan]"
                )
                console.print(f"Server: [cyan]{status.get('server', 'Unknown')}[/cyan]")
            else:
                console.print("[yellow]VPN Status: Not Connected[/yellow]")
                console.print(
                    f"Public IP: [cyan]{status.get('normal_ip', 'Unknown')}[/cyan]"
                )
        except Exception as e:
            raise VPNError(f"Failed to get status: {e}")

    def init(self) -> None:
        """Initialize the client environment and verify all dependencies.

        This method performs essential setup tasks:
        1. Verifies OpenVPN installation and accessibility
        2. Creates necessary directory structure for configs and cache
        3. Tests API connectivity to ensure account access
        4. Captures initial IP address for connection verification
        5. Sets up logging based on verbosity level

        The initialization process ensures all components required for
        VPN operation are available and properly configured before
        attempting any connections.

        Raises:
            ConnectionError: If any initialization step fails (OpenVPN missing,
                           directory creation fails, API unreachable, etc.)

        """
        try:
            # Check OpenVPN installation
            openvpn_path = self.vpn_manager.check_openvpn_installation()
            if self.verbose:
                self.logger.info(f"Found OpenVPN at: {openvpn_path}")

            # Create necessary directories
            for directory in [CACHE_DIR, CONFIG_DIR, DATA_DIR]:
                directory.mkdir(parents=True, exist_ok=True)
                if self.verbose:
                    self.logger.info(f"Created directory: {directory}")

            # Test API connectivity
            if not self.api_client.test_api_connectivity():
                raise ConnectionError("Failed to connect to NordVPN API")
            if self.verbose:
                self.logger.info("Successfully connected to NordVPN API")

            # Get initial IP
            initial_ip = self.vpn_manager.get_current_ip()
            if not initial_ip:
                raise ConnectionError("Failed to get initial IP")
            if self.verbose:
                self.logger.info(f"Initial IP: {initial_ip}")

            if self.verbose:
                self.logger.info("Client environment initialized successfully")

        except Exception as e:
            raise ConnectionError(f"Failed to initialize client environment: {e}")

    def get_current_ip(self) -> str | None:
        """Get current IP address."""
        return self.vpn_manager.get_current_ip()

    def _save_state(self) -> None:
        """Save current connection state."""
        state = {
            "connected": self.is_protected(),
            "initial_ip": self.get_current_ip(),
            "connected_ip": self.get_current_ip(),
            "server": self.status().get("server", "Unknown"),
            "country": self.status().get("country", "Unknown"),
            "timestamp": time.time(),
        }
        save_vpn_state(state)

================
File: src/nyord_vpn/data/countries.json
================
{
  "servers": [
    {
      "hostname": "pl128.nordvpn.com",
      "load": 34,
      "country": {
        "code": "PL",
        "name": "Poland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "kjAOzXQRVGpmQdqE2zPsITH8QHmFK83AAPktqWed9wM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "194.99.105.99"
    },
    {
      "hostname": "be148.nordvpn.com",
      "load": 7,
      "country": {
        "code": "BE",
        "name": "Belgium"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "VSa6XYcD279ahd3IuEiUH6VpXn0+h+kWrD4OcN1ExUs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "82.102.19.137"
    },
    {
      "hostname": "hu48.nordvpn.com",
      "load": 7,
      "country": {
        "code": "HU",
        "name": "Hungary"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "3KWTCjpHlmXD3BroyAIFMN8ajr+ibShIl8OSUGgejXY="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.189.114.28"
    },
    {
      "hostname": "us5063.nordvpn.com",
      "load": 27,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.245.87.59"
    },
    {
      "hostname": "at86.nordvpn.com",
      "load": 12,
      "country": {
        "code": "AT",
        "name": "Austria"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "F6b2ac9H7hEvt03EonY1bS4FzNAabEmURDTB8wIIPXc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.216.34.100"
    },
    {
      "hostname": "ch217.nordvpn.com",
      "load": 10,
      "country": {
        "code": "CH",
        "name": "Switzerland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SqAWBSVdnUJ859Bz2Nyt82rlSebMwPgvwQxIb1DzyF8="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.156.175.132"
    },
    {
      "hostname": "dk152.nordvpn.com",
      "load": 9,
      "country": {
        "code": "DK",
        "name": "Denmark"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "EHL1zeXjZEJlqtFA8qaRVuvl0zR4skbC/AjiG66CLCc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "82.102.20.212"
    },
    {
      "hostname": "no151.nordvpn.com",
      "load": 4,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "82.102.22.92"
    },
    {
      "hostname": "ch218.nordvpn.com",
      "load": 13,
      "country": {
        "code": "CH",
        "name": "Switzerland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SqAWBSVdnUJ859Bz2Nyt82rlSebMwPgvwQxIb1DzyF8="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "84.39.112.20"
    },
    {
      "hostname": "uk1784.nordvpn.com",
      "load": 11,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "81.92.202.11"
    },
    {
      "hostname": "fr555.nordvpn.com",
      "load": 20,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "82.102.18.252"
    },
    {
      "hostname": "ch219.nordvpn.com",
      "load": 12,
      "country": {
        "code": "CH",
        "name": "Switzerland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SqAWBSVdnUJ859Bz2Nyt82rlSebMwPgvwQxIb1DzyF8="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.9.18.84"
    },
    {
      "hostname": "us5064.nordvpn.com",
      "load": 24,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.104.156"
    },
    {
      "hostname": "uk765.nordvpn.com",
      "load": 10,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.35.28.131"
    },
    {
      "hostname": "uk812.nordvpn.com",
      "load": 9,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "77.81.191.3"
    },
    {
      "hostname": "uk813.nordvpn.com",
      "load": 18,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.34.98.195"
    },
    {
      "hostname": "uk814.nordvpn.com",
      "load": 10,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.121.139.100"
    },
    {
      "hostname": "uk871.nordvpn.com",
      "load": 13,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.34.99.131"
    },
    {
      "hostname": "uk873.nordvpn.com",
      "load": 12,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.180.3"
    },
    {
      "hostname": "uk875.nordvpn.com",
      "load": 14,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.180.131"
    },
    {
      "hostname": "de507.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.130.184.115"
    },
    {
      "hostname": "de508.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.130.184.116"
    },
    {
      "hostname": "de509.nordvpn.com",
      "load": 3,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.130.184.117"
    },
    {
      "hostname": "de510.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.130.184.118"
    },
    {
      "hostname": "uk877.nordvpn.com",
      "load": 24,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "81.19.217.3"
    },
    {
      "hostname": "us2920.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "96.9.246.179"
    },
    {
      "hostname": "us2921.nordvpn.com",
      "load": 3,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "96.9.246.180"
    },
    {
      "hostname": "uk879.nordvpn.com",
      "load": 10,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "81.19.223.3"
    },
    {
      "hostname": "us2924.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "96.9.247.187"
    },
    {
      "hostname": "us2925.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "96.9.247.188"
    },
    {
      "hostname": "uk884.nordvpn.com",
      "load": 11,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "178.239.169.3"
    },
    {
      "hostname": "us2929.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "107.173.59.99"
    },
    {
      "hostname": "us2930.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "172.93.147.130"
    },
    {
      "hostname": "uk886.nordvpn.com",
      "load": 11,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.44.79.131"
    },
    {
      "hostname": "be149.nordvpn.com",
      "load": 7,
      "country": {
        "code": "BE",
        "name": "Belgium"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "VSa6XYcD279ahd3IuEiUH6VpXn0+h+kWrD4OcN1ExUs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "77.243.191.250"
    },
    {
      "hostname": "uk1806.nordvpn.com",
      "load": 14,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "193.9.113.134"
    },
    {
      "hostname": "uk888.nordvpn.com",
      "load": 8,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.16.205.3"
    },
    {
      "hostname": "uk890.nordvpn.com",
      "load": 7,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.16.205.131"
    },
    {
      "hostname": "us2939.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "172.93.237.99"
    },
    {
      "hostname": "us2940.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "172.93.237.100"
    },
    {
      "hostname": "de655.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "194.31.54.4"
    },
    {
      "hostname": "uk892.nordvpn.com",
      "load": 11,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.170.3"
    },
    {
      "hostname": "uk894.nordvpn.com",
      "load": 9,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.170.131"
    },
    {
      "hostname": "uk896.nordvpn.com",
      "load": 8,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "178.239.164.3"
    },
    {
      "hostname": "uk898.nordvpn.com",
      "load": 9,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "178.239.164.131"
    },
    {
      "hostname": "us2943.nordvpn.com",
      "load": 1,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.175.97"
    },
    {
      "hostname": "us2944.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.175.98"
    },
    {
      "hostname": "us2945.nordvpn.com",
      "load": 10,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.185.86"
    },
    {
      "hostname": "us2946.nordvpn.com",
      "load": 1,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.185.97"
    },
    {
      "hostname": "nl408.nordvpn.com",
      "load": 0,
      "country": {
        "code": "NL",
        "name": "Netherlands"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "5p4RkybdRU5uaDi90eu4KZPTFif0lKCg4Qp6t1c4F30="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.229.58.3"
    },
    {
      "hostname": "nl409.nordvpn.com",
      "load": 0,
      "country": {
        "code": "NL",
        "name": "Netherlands"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "5p4RkybdRU5uaDi90eu4KZPTFif0lKCg4Qp6t1c4F30="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.229.58.129"
    },
    {
      "hostname": "de676.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "37.120.223.116"
    },
    {
      "hostname": "us5055.nordvpn.com",
      "load": 13,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.187.175.2"
    },
    {
      "hostname": "us2949.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "64.44.32.75"
    },
    {
      "hostname": "us2950.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "64.44.32.76"
    },
    {
      "hostname": "fr439.nordvpn.com",
      "load": 8,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.93.2.199"
    },
    {
      "hostname": "fr440.nordvpn.com",
      "load": 1,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.93.2.206"
    },
    {
      "hostname": "jp429.nordvpn.com",
      "load": 25,
      "country": {
        "code": "JP",
        "name": "Japan"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SAio0Z0suFlRfmydzPdcn6MamqS7Mq4pSOm2YmJkLSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.210.107"
    },
    {
      "hostname": "es114.nordvpn.com",
      "load": 7,
      "country": {
        "code": "ES",
        "name": "Spain"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "IF1FGVSzrUznFVZ+dymIz+6bdlCgsuiT/d6cyapN8lw="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.199.243"
    },
    {
      "hostname": "it132.nordvpn.com",
      "load": 15,
      "country": {
        "code": "IT",
        "name": "Italy"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FgxaycYZ4t1kp4x7LDv60sczNTAl0h/d4pyyUNHhgBc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.197.75"
    },
    {
      "hostname": "us4735.nordvpn.com",
      "load": 16,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.198.235"
    },
    {
      "hostname": "pl122.nordvpn.com",
      "load": 9,
      "country": {
        "code": "PL",
        "name": "Poland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "kjAOzXQRVGpmQdqE2zPsITH8QHmFK83AAPktqWed9wM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.211.171"
    },
    {
      "hostname": "cz93.nordvpn.com",
      "load": 5,
      "country": {
        "code": "CZ",
        "name": "Czech Republic"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "apEe1p4IQvCQxexoxoUTXsm2p582FtbDAboPwThFYEs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.199.27"
    },
    {
      "hostname": "at80.nordvpn.com",
      "load": 4,
      "country": {
        "code": "AT",
        "name": "Austria"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "F6b2ac9H7hEvt03EonY1bS4FzNAabEmURDTB8wIIPXc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "5.253.207.203"
    },
    {
      "hostname": "ro59.nordvpn.com",
      "load": 16,
      "country": {
        "code": "RO",
        "name": "Romania"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "o3Dj1qKYmzBBOBaD9JAhK9cg/8nfYxWg6GADL09DPHE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "86.106.137.187"
    },
    {
      "hostname": "ch198.nordvpn.com",
      "load": 18,
      "country": {
        "code": "CH",
        "name": "Switzerland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SqAWBSVdnUJ859Bz2Nyt82rlSebMwPgvwQxIb1DzyF8="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.213.131"
    },
    {
      "hostname": "bg38.nordvpn.com",
      "load": 12,
      "country": {
        "code": "BG",
        "name": "Bulgaria"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "xqa+kDsDeYLQAnVDUQaFun9Djfo3c1ESTMwfNArHw10="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.202.147"
    },
    {
      "hostname": "hu47.nordvpn.com",
      "load": 6,
      "country": {
        "code": "HU",
        "name": "Hungary"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "3KWTCjpHlmXD3BroyAIFMN8ajr+ibShIl8OSUGgejXY="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.192.99"
    },
    {
      "hostname": "fr452.nordvpn.com",
      "load": 10,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "45.152.181.219"
    },
    {
      "hostname": "jp454.nordvpn.com",
      "load": 28,
      "country": {
        "code": "JP",
        "name": "Japan"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SAio0Z0suFlRfmydzPdcn6MamqS7Mq4pSOm2YmJkLSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.187.161.54"
    },
    {
      "hostname": "us4951.nordvpn.com",
      "load": 2,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "84.17.44.122"
    },
    {
      "hostname": "dk150.nordvpn.com",
      "load": 10,
      "country": {
        "code": "DK",
        "name": "Denmark"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "EHL1zeXjZEJlqtFA8qaRVuvl0zR4skbC/AjiG66CLCc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.194.3"
    },
    {
      "hostname": "de750.nordvpn.com",
      "load": 10,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "5.180.62.120"
    },
    {
      "hostname": "us4953.nordvpn.com",
      "load": 1,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.175.53"
    },
    {
      "hostname": "us4954.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.175.54"
    },
    {
      "hostname": "pl125.nordvpn.com",
      "load": 10,
      "country": {
        "code": "PL",
        "name": "Poland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "kjAOzXQRVGpmQdqE2zPsITH8QHmFK83AAPktqWed9wM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.209.67"
    },
    {
      "hostname": "us5057.nordvpn.com",
      "load": 14,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.208.211"
    },
    {
      "hostname": "us5058.nordvpn.com",
      "load": 52,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.208.219"
    },
    {
      "hostname": "us5059.nordvpn.com",
      "load": 16,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.208.139"
    },
    {
      "hostname": "us5060.nordvpn.com",
      "load": 18,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.208.147"
    },
    {
      "hostname": "no141.nordvpn.com",
      "load": 21,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.163"
    },
    {
      "hostname": "no142.nordvpn.com",
      "load": 3,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.171"
    },
    {
      "hostname": "no143.nordvpn.com",
      "load": 3,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.179"
    },
    {
      "hostname": "no144.nordvpn.com",
      "load": 6,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.187"
    },
    {
      "hostname": "no145.nordvpn.com",
      "load": 6,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.195"
    },
    {
      "hostname": "no146.nordvpn.com",
      "load": 5,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.203"
    },
    {
      "hostname": "no147.nordvpn.com",
      "load": 5,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.211"
    },
    {
      "hostname": "no148.nordvpn.com",
      "load": 6,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.219"
    },
    {
      "hostname": "no149.nordvpn.com",
      "load": 4,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "95.174.66.27"
    },
    {
      "hostname": "uk1785.nordvpn.com",
      "load": 13,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "194.35.233.75"
    },
    {
      "hostname": "hu49.nordvpn.com",
      "load": 5,
      "country": {
        "code": "HU",
        "name": "Hungary"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "3KWTCjpHlmXD3BroyAIFMN8ajr+ibShIl8OSUGgejXY="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.192.83"
    },
    {
      "hostname": "fr536.nordvpn.com",
      "load": 11,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.139"
    },
    {
      "hostname": "fr537.nordvpn.com",
      "load": 20,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.147"
    },
    {
      "hostname": "fr538.nordvpn.com",
      "load": 8,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.155"
    },
    {
      "hostname": "fr539.nordvpn.com",
      "load": 13,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.163"
    },
    {
      "hostname": "fr540.nordvpn.com",
      "load": 8,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.195"
    },
    {
      "hostname": "fr541.nordvpn.com",
      "load": 8,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.203"
    },
    {
      "hostname": "fr542.nordvpn.com",
      "load": 12,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.171"
    },
    {
      "hostname": "fr543.nordvpn.com",
      "load": 9,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.179"
    },
    {
      "hostname": "fr544.nordvpn.com",
      "load": 11,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.187"
    }
  ],
  "last_updated": "2025-02-23T06:17:51Z",
  "expires_at": 1740377871.590903
}

================
File: src/nyord_vpn/data/country_ids.json
================
{
    "AL": "2",
    "AR": "10",
    "AU": "13",
    "AT": "14",
    "BE": "21",
    "BA": "27",
    "BR": "30",
    "BG": "33",
    "CA": "38",
    "CL": "43",
    "CR": "52",
    "HR": "54",
    "CY": "56",
    "CZ": "57",
    "DK": "58",
    "EE": "68",
    "FI": "73",
    "FR": "74",
    "GE": "80",
    "DE": "81",
    "GR": "84",
    "HK": "97",
    "HU": "98",
    "IS": "99",
    "IN": "100",
    "ID": "101",
    "IE": "104",
    "IL": "105",
    "IT": "106",
    "JP": "108",
    "LV": "119",
    "LU": "126",
    "MY": "131",
    "MX": "140",
    "MD": "142",
    "NL": "153",
    "NZ": "156",
    "MK": "128",
    "NO": "163",
    "PL": "174",
    "PT": "175",
    "RO": "179",
    "RS": "192",
    "SG": "195",
    "SK": "196",
    "SI": "197",
    "ZA": "200",
    "KR": "114",
    "ES": "202",
    "SE": "208",
    "CH": "209",
    "TW": "211",
    "TH": "214",
    "TR": "220",
    "UA": "225",
    "GB": "227",
    "US": "228",
    "VN": "234"
}

================
File: src/nyord_vpn/network/__init__.py
================
"""Network-related modules for nyord-vpn.

this_file: src/nyord_vpn/network/__init__.py

This package contains modules for network operations including
VPN connection management and server selection.
"""

================
File: src/nyord_vpn/network/country.py
================
import json
import time

from nyord_vpn.storage.models import CountryCache
from nyord_vpn.utils.utils import COUNTRIES_CACHE, CACHE_EXPIRY


def get_cached_countries() -> CountryCache | None:
    """Get cached country list if available and not expired."""
    try:
        if not COUNTRIES_CACHE.exists():
            return None
        # Check if cache is expired
        if time.time() - COUNTRIES_CACHE.stat().st_mtime > CACHE_EXPIRY:
            return None
        return json.loads(COUNTRIES_CACHE.read_text())
    except (json.JSONDecodeError, OSError):
        return None


def cache_countries(data: CountryCache) -> None:
    """Cache the country list to disk.

    Args:
        data: Dictionary containing countries list and last_updated timestamp

    """
    try:
        COUNTRIES_CACHE.parent.mkdir(parents=True, exist_ok=True)
        COUNTRIES_CACHE.write_text(json.dumps(data, indent=2, sort_keys=True))
        COUNTRIES_CACHE.chmod(0o644)  # Make readable for all users
    except OSError:
        pass

================
File: src/nyord_vpn/network/server.py
================
import json
import random
import subprocess
import time
import asyncio
import socket
from typing import Any, TypedDict, List, Tuple
from concurrent.futures import ThreadPoolExecutor
from loguru import logger

import requests

from nyord_vpn.core.api import NordVPNAPIClient
from nyord_vpn.storage.models import ServerError
from nyord_vpn.utils.utils import API_HEADERS, CACHE_DIR, CACHE_EXPIRY


"""Server management and selection for NordVPN.

this_file: src/nyord_vpn/network/server.py

This module provides server selection and management functionality for NordVPN.
It implements intelligent server selection based on multiple metrics and maintains
server state information.

Core Responsibilities:
1. Server discovery and filtering
2. Load balancing and server selection
3. Server performance measurement
4. Country-based server filtering
5. Cache management for server information

Integration Points:
- Used by Client (core/client.py) for server selection
- Uses NordVPNAPIClient (core/api.py) for server data
- Uses models from storage/models.py
- Uses cache system from utils/utils.py

Selection Algorithm:
The server selection process considers multiple factors:
1. Server load (from API)
2. Geographic proximity (ping times)
3. Connection stability (failure tracking)
4. Feature support (OpenVPN TCP)

Cache Management:
- Implements TTL-based caching
- Handles API failures gracefully
- Provides fallback data
- Validates cached entries

Error Handling:
- Tracks failed servers
- Implements automatic retries
- Provides fallback options
- Detailed error reporting

The module uses TypedDict classes to ensure type safety when
handling server information from the NordVPN API.
"""


class ServerLocation(TypedDict):
    """Server location information from NordVPN API.

    Attributes:
        country: Dictionary containing country information
                with keys for code and name

    """

    country: dict[str, str]


class ServerTechnology(TypedDict):
    """Server technology support information.

    Attributes:
        id: Technology identifier (e.g. 5 for OpenVPN TCP)
        status: Technology status ('online' or 'offline')

    """

    id: int
    status: str


class ServerData(TypedDict):
    """Complete server information from NordVPN API.

    Attributes:
        hostname: Server's hostname for connection
        load: Current server load percentage (0-100)
        status: Server status ('online' or 'offline')
        location_ids: List of location identifiers
        technologies: List of supported technologies
        station: Optional station identifier

    """

    hostname: str
    load: int
    status: str
    location_ids: list[str]
    technologies: list[ServerTechnology]
    station: str | None


class APIResponse(TypedDict):
    """NordVPN API response structure.

    Attributes:
        servers: List of available servers
        locations: Mapping of location IDs to location info

    """

    servers: list[ServerData]
    locations: dict[str, ServerLocation]


class ServerManager:
    """Manages NordVPN server selection and optimization.

    This class handles all server-related operations including:
    1. Server discovery and filtering
    2. Performance measurement and ranking
    3. Load balancing across available servers
    4. Cache management for server information
    5. Country-based server selection

    The manager maintains a cache of server information and tracks
    failed servers within a session to avoid repeated connection
    attempts to problematic servers.
    """

    def __init__(self, api_client: NordVPNAPIClient) -> None:
        """Initialize server manager with API client.

        Sets up the server manager with:
        1. API client for server information retrieval
        2. Logging configuration from API client
        3. Server cache initialization
        4. Failed servers tracking

        Args:
            api_client: NordVPN API client for server information

        """
        self.api_client = api_client
        self.logger = api_client.logger
        self._servers_cache: list[dict[str, Any]] | None = None
        self._last_cache_update: float = 0
        self._failed_servers = set()  # Track failed servers in this session

    def fetch_server_info(self, country: str | None = None) -> tuple[str, str] | None:
        """Fetch information about recommended servers supporting OpenVPN.

        Queries the NordVPN API for server recommendations based on:
        1. OpenVPN TCP support
        2. Server load
        3. Country preference (if specified)
        4. Server status and availability

        Args:
            country: Optional two-letter country code for filtering

        Returns:
            tuple: (hostname, station) if successful, None if no servers available
                  hostname: Server hostname for connection
                  station: Station identifier (if available)

        Raises:
            ServerError: If server fetch fails or no suitable servers found
                        Includes specific error for invalid country codes

        """
        url = "https://api.nordvpn.com/v1/servers/recommendations"
        params = {
            "filters[servers_technologies][identifier]": "openvpn_tcp",
            "limit": "5",
        }
        if country:
            from nyord_vpn.utils.utils import NORDVPN_COUNTRY_IDS

            country_id = NORDVPN_COUNTRY_IDS.get(country.upper())
            if not country_id:
                # Try to get country ID from API
                country_info = self.get_country_info(country)
                if country_info:
                    country_id = str(country_info["id"])
                else:
                    raise ServerError(f"Country code '{country}' not found")
            params["filters[country_id]"] = country_id

        try:
            response = requests.get(url, params=params, headers=API_HEADERS, timeout=10)
            response.raise_for_status()
            data = response.json()
            if not isinstance(data, list) or not data:
                params.pop("filters[servers_technologies][identifier]", None)
                response = requests.get(
                    url,
                    params=params,
                    headers=API_HEADERS,
                    timeout=10,
                )
                response.raise_for_status()
                data = response.json()
            if not isinstance(data, list) or not data:
                raise ServerError(
                    f"No servers available{' in ' + country.upper() if country else ''}",
                )
            if self.api_client.verbose:
                self.logger.debug("Available servers retrieved.")
            server = min(data, key=lambda x: x.get("load", 100))
            hostname = server.get("hostname")
            if not isinstance(hostname, str) or not hostname:
                raise ServerError("Invalid server data received.")
            return hostname, server.get("station", "")
        except requests.RequestException as e:
            raise ServerError(f"Failed to fetch server info: {e}")

    def get_servers_cache(self) -> dict:
        """Manage and retrieve server information cache.

        This method handles the complete server cache lifecycle:
        1. Checks for existing cache file
        2. Validates cache freshness and content
        3. Fetches fresh data from API if needed
        4. Filters and validates server information
        5. Updates cache with fresh data

        The cache includes:
        - Server information (hostname, load, status)
        - Country information
        - Cache metadata (last update, expiry)

        Returns:
            dict: Cache containing:
                - servers: List of valid server information
                - expires_at: Cache expiry timestamp
                - last_updated: Last update timestamp

        Note:
            The cache is considered valid if:
            1. The cache file exists
            2. The cache hasn't expired
            3. The cached servers are valid
            4. The cache format is correct

        """
        cache_file = CACHE_DIR / "servers.json"
        if cache_file.exists():
            try:
                cache = json.loads(cache_file.read_text())
                if (
                    isinstance(cache, dict)
                    and isinstance(cache.get("servers", []), list)
                    and time.time() < cache.get("expires_at", 0)
                ):
                    # Validate cached servers
                    valid_servers = [
                        s for s in cache["servers"] if self._is_valid_server(s)
                    ]
                    if valid_servers:
                        if self.api_client.verbose:
                            self.logger.debug(
                                f"Using cached server list with {len(valid_servers)} valid servers",
                            )
                        cache["servers"] = valid_servers
                        return cache
                    if self.api_client.verbose:
                        self.logger.warning(
                            "No valid servers in cache, fetching fresh data",
                        )
            except Exception as e:
                if self.api_client.verbose:
                    self.logger.warning(f"Failed to read cache: {e}")

        try:
            if self.api_client.verbose:
                self.logger.debug("Fetching server list from API...")

            # Use v2 API which has more detailed server info
            response = requests.get(
                "https://api.nordvpn.com/v1/servers",
                headers=API_HEADERS,
                timeout=10,
            )
            response.raise_for_status()
            data = response.json()

            if self.api_client.verbose:
                self.logger.debug("Successfully fetched server data from API")

            # Extract servers from response
            raw_servers: list[dict[str, Any]] = []

            if isinstance(data, list):
                raw_servers = [dict(s) for s in data]
                if self.api_client.verbose:
                    self.logger.debug(
                        f"Found {len(raw_servers)} servers in API response",
                    )
            else:
                raise ValueError(f"Unexpected API response format: {type(data)}")

            # Get countries info
            try:
                countries_response = requests.get(
                    "https://api.nordvpn.com/v1/servers/countries",
                    headers=API_HEADERS,
                    timeout=10,
                )
                countries_response.raise_for_status()
                countries_data = countries_response.json()

                # Create countries lookup
                countries = {}
                for country in countries_data:
                    if isinstance(country, dict):
                        country_id = str(country.get("id"))
                        if country_id:
                            countries[country_id] = {
                                "code": country.get("code", "").upper(),
                                "name": country.get("name", "Unknown"),
                            }
            except Exception as e:
                if self.api_client.verbose:
                    self.logger.warning(f"Failed to fetch countries: {e}")
                countries = {}

            # Filter and validate servers
            valid_servers = []
            invalid_count = 0
            for server in raw_servers:
                if not isinstance(server, dict):
                    invalid_count += 1
                    continue

                # Check if server is online and supports OpenVPN TCP
                if server.get("status") != "online":
                    if self.api_client.verbose:
                        self.logger.debug(
                            f"Skipping offline server: {server.get('hostname')}",
                        )
                    continue

                has_openvpn_tcp = False
                for tech in server.get("technologies", []):
                    if (
                        isinstance(tech, dict)
                        and tech.get("id") == 5
                        and tech.get("status") == "online"
                    ):
                        has_openvpn_tcp = True
                        break
                if not has_openvpn_tcp:
                    if self.api_client.verbose:
                        self.logger.debug(
                            f"Skipping server without OpenVPN TCP: {server.get('hostname')}",
                        )
                    continue

                # Get hostname and validate
                hostname = server.get("hostname")
                if not isinstance(hostname, str) or not hostname:
                    invalid_count += 1
                    continue

                # Get country info from location_ids
                country_info = None
                location_ids = server.get("location_ids", [])
                if isinstance(location_ids, list):
                    for location_id in location_ids:
                        if not isinstance(location_id, str | int):
                            continue
                        country_id = str(location_id)
                        country = countries.get(country_id)
                        if country and isinstance(country, dict):
                            country_info = country
                            break

                # If no country info from locations, try direct country field
                if not country_info:
                    country = server.get("country", {})
                    if isinstance(country, dict):
                        country_info = {
                            "code": country.get("code", "").upper(),
                            "name": country.get("name", "Unknown"),
                        }

                if not country_info:
                    if self.api_client.verbose:
                        self.logger.debug(
                            f"Skipping server without country info: {hostname}",
                        )
                    continue

                # Create normalized server entry
                valid_server = {
                    "hostname": hostname,
                    "load": int(server.get("load", 100)),
                    "country": country_info,
                    "status": server.get("status"),
                    "technologies": server.get("technologies", []),
                    "station": server.get("station"),
                }

                # Final validation
                if self._is_valid_server(valid_server):
                    valid_servers.append(valid_server)
                else:
                    invalid_count += 1

            if not valid_servers:
                raise ValueError(
                    f"No valid servers found in API response. "
                    f"Total servers: {len(raw_servers)}, Invalid: {invalid_count}",
                )

            if self.api_client.verbose:
                country_counts = {}
                for server in valid_servers:
                    code = server["country"]["code"]
                    country_counts[code] = country_counts.get(code, 0) + 1
                self.logger.debug(
                    f"Found {len(valid_servers)} valid servers. "
                    f"Country distribution: "
                    + ", ".join(f"{k}: {v}" for k, v in sorted(country_counts.items())),
                )

            cache = {
                "servers": valid_servers,
                "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                "expires_at": time.time() + CACHE_EXPIRY,
            }

            CACHE_DIR.mkdir(parents=True, exist_ok=True)
            cache_file.write_text(json.dumps(cache, indent=2))
            return cache

        except Exception as e:
            self.logger.exception(f"Failed to fetch servers: {e}")
            if cache_file.exists():
                try:
                    cache = json.loads(cache_file.read_text())
                    if isinstance(cache, dict) and isinstance(
                        cache.get("servers", []),
                        list,
                    ):
                        # Validate cached servers even in fallback
                        valid_servers = [
                            s for s in cache["servers"] if self._is_valid_server(s)
                        ]
                        if valid_servers:
                            if self.api_client.verbose:
                                self.logger.info(
                                    f"Using fallback cache with {len(valid_servers)} valid servers",
                                )
                            cache["servers"] = valid_servers
                            return cache
                except Exception:
                    pass
            return {"servers": [], "last_updated": "", "expires_at": 0}

    def _ping_server(self, hostname: str) -> float:
        """Ping a server and return response time in ms.

        Args:
            hostname: Server hostname to ping

        Returns:
            float: Ping time in milliseconds, or float('inf') if ping failed

        """
        try:
            # Platform-specific ping command
            import platform

            system = platform.system().lower()

            if system == "windows":
                cmd = ["ping", "-n", "2", "-w", "1000", hostname]
            elif system == "darwin":  # macOS
                cmd = ["ping", "-c", "2", "-W", "1", "-t", "1", hostname]
            else:  # Linux and others
                cmd = ["ping", "-c", "2", "-W", "1", hostname]

            if self.api_client.verbose:
                self.logger.debug(f"Running ping command: {' '.join(cmd)}")

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=3,
                check=False,  # Overall timeout
            )

            if result.returncode == 0:
                # Extract time from ping output more robustly
                min_time = float("inf")
                for line in result.stdout.splitlines():
                    if self.api_client.verbose:
                        self.logger.debug(f"Ping output line: {line}")

                    # Look for min/avg/max line
                    if "min/avg/max" in line:
                        try:
                            # Format: round-trip min/avg/max/stddev = 18.894/18.894/18.894/0.000 ms
                            stats = line.split("=")[1].strip().split("/")
                            min_time = float(stats[0])
                            if self.api_client.verbose:
                                self.logger.debug(
                                    f"Parsed min time from stats: {min_time}ms",
                                )
                            return min_time
                        except (IndexError, ValueError) as e:
                            if self.api_client.verbose:
                                self.logger.debug(
                                    f"Failed to parse min/avg/max line '{line}': {e}",
                                )
                            continue
                    # Look for individual ping responses
                    elif "time=" in line:
                        try:
                            time_str = line.split("time=")[1].split()[0].rstrip("ms")
                            ping_time = float(time_str)
                            min_time = min(min_time, ping_time)
                            if self.api_client.verbose:
                                self.logger.debug(
                                    f"Parsed time from response: {ping_time}ms",
                                )
                        except (IndexError, ValueError) as e:
                            if self.api_client.verbose:
                                self.logger.debug(
                                    f"Failed to parse time from line '{line}': {e}",
                                )
                            continue

                if min_time < float("inf"):
                    if self.api_client.verbose:
                        self.logger.debug(
                            f"Server {hostname} responded in {min_time}ms",
                        )
                    return min_time

                # If we couldn't parse any times but ping succeeded
                if self.api_client.verbose:
                    self.logger.debug(
                        f"Server {hostname} responded but couldn't parse time from output:\n{result.stdout}",
                    )
                return float("inf")
            if self.api_client.verbose:
                self.logger.debug(
                    f"Server {hostname} ping failed with code {result.returncode}:\n"
                    f"stdout: {result.stdout}\n"
                    f"stderr: {result.stderr}",
                )
            return float("inf")

        except subprocess.TimeoutExpired:
            if self.api_client.verbose:
                self.logger.debug(f"Server {hostname} ping timed out")
            return float("inf")
        except Exception as e:
            if self.api_client.verbose:
                self.logger.debug(f"Server {hostname} ping error: {e}")
                import traceback

                self.logger.debug(f"Traceback: {traceback.format_exc()}")
            return float("inf")

    def _is_valid_server(self, server: Any) -> bool:
        """Validate server data structure.

        Args:
            server: Server data to validate

        Returns:
            bool: True if server data is valid

        """
        if not isinstance(server, dict):
            return False

        # Check required fields
        hostname = server.get("hostname")
        if not isinstance(hostname, str) or not hostname:
            return False

        # Basic hostname validation
        if not hostname.endswith(".nordvpn.com"):
            return False

        # Check country info
        country = server.get("country")
        if not isinstance(country, dict):
            return False

        country_code = country.get("code")
        if not isinstance(country_code, str) or len(country_code) != 2:
            return False

        # Check server status
        status = server.get("status")
        if status != "online":
            return False

        # Check load value
        load = server.get("load")
        return not (not isinstance(load, int | float) or load < 0 or load > 100)

    def _test_server(self, server: dict[str, Any]) -> Tuple[dict[str, Any], float]:
        """Test a server's response time using both ping and TCP connection.

        Args:
            server: Server information dictionary

        Returns:
            Tuple of (server, score) where score is combined ping/TCP time
            Lower score is better, float('inf') means failed
        """
        hostname = server.get("hostname")
        if not hostname:
            return server, float("inf")

        try:
            # Platform-specific ping command
            import platform

            system = platform.system().lower()

            if system == "darwin":  # macOS
                cmd = ["ping", "-c", "1", "-W", "1000", "-t", "1", hostname]
            elif system == "windows":
                cmd = ["ping", "-n", "1", "-w", "1000", hostname]
            else:  # Linux and others
                cmd = ["ping", "-c", "1", "-W", "1", hostname]

            if self.api_client.verbose:
                self.logger.debug(f"Running ping command: {' '.join(cmd)}")

            # Run ping
            ping_result = subprocess.run(cmd, capture_output=True, text=True, timeout=2)

            if ping_result.returncode != 0:
                if self.api_client.verbose:
                    self.logger.debug(
                        f"Ping failed for {hostname}: {ping_result.stderr}"
                    )
                return server, float("inf")

            # Parse ping time based on platform
            ping_time = float("inf")
            output = ping_result.stdout

            if system == "darwin":
                # macOS format: round-trip min/avg/max/stddev = 20.237/20.237/20.237/0.000 ms
                for line in output.splitlines():
                    if "round-trip" in line:
                        try:
                            stats = line.split("=")[1].strip().split("/")
                            ping_time = float(stats[0])  # Use min time
                            break
                        except (IndexError, ValueError) as e:
                            if self.api_client.verbose:
                                self.logger.debug(
                                    f"Failed to parse macOS ping stats: {e}"
                                )
                            continue
            else:
                # Linux/Windows format: time=20.2 ms
                try:
                    ping_time = float(output.split("time=")[1].split()[0].rstrip("ms"))
                except (IndexError, ValueError) as e:
                    if self.api_client.verbose:
                        self.logger.debug(f"Failed to parse ping time: {e}")
                    return server, float("inf")

            if ping_time == float("inf"):
                if self.api_client.verbose:
                    self.logger.debug(
                        f"Could not parse ping time from output: {output}"
                    )
                return server, float("inf")

            # Quick TCP connection test to OpenVPN port
            start = time.time()
            try:
                with socket.create_connection((hostname, 443), timeout=2):
                    tcp_time = (time.time() - start) * 1000  # Convert to ms
            except (socket.timeout, socket.error) as e:
                if self.api_client.verbose:
                    self.logger.debug(f"TCP connection failed for {hostname}: {e}")
                return server, float("inf")

            # Combined score (70% ping, 30% TCP)
            score = (ping_time * 0.7) + (tcp_time * 0.3)

            if self.api_client.verbose:
                self.logger.debug(
                    f"Server {hostname} test results: "
                    f"ping={ping_time:.1f}ms, tcp={tcp_time:.1f}ms, score={score:.1f}ms"
                )

            return server, score

        except Exception as e:
            if self.api_client.verbose:
                self.logger.debug(f"Failed to test server {hostname}: {e}")
                import traceback

                self.logger.debug(f"Traceback: {traceback.format_exc()}")
            return server, float("inf")

    def _select_diverse_servers(
        self, servers: list[dict[str, Any]], count: int = 4
    ) -> list[dict[str, Any]]:
        """Select geographically diverse servers.

        When no country is specified, this ensures we test servers from different regions
        to find the best performing one regardless of location.

        Args:
            servers: List of server dictionaries
            count: Number of servers to select

        Returns:
            List of selected servers
        """
        # Group servers by region/continent
        regions = {}
        for server in servers:
            region = server.get("country", {}).get("region", {}).get("name", "Unknown")
            if region not in regions:
                regions[region] = []
            regions[region].append(server)

        # Select servers from different regions if possible
        selected = []
        region_names = list(regions.keys())

        while len(selected) < count and region_names:
            # Cycle through regions
            region = region_names.pop(random.randrange(len(region_names)))
            if region_servers := regions.get(region, []):
                # Select random server from region
                server = random.choice(region_servers)
                selected.append(server)

        # If we still need more servers, take random ones
        if len(selected) < count:
            remaining = random.sample(
                [s for s in servers if s not in selected],
                min(count - len(selected), len(servers)),
            )
            selected.extend(remaining)

        return selected

    def select_fastest_server(
        self,
        country_code: str | None = None,
        random_select: bool = False,
        _retry_count: int = 0,
    ) -> dict[str, Any] | None:
        """Select the optimal server based on parallel performance testing.

        Args:
            country_code: Optional two-letter country code
            random_select: Whether to randomize selection
            _retry_count: Internal retry counter

        Returns:
            Selected server info or None if no suitable server found

        Raises:
            ServerError: If country code is invalid or no servers are available
        """
        try:
            # Validate country code if provided
            if country_code:
                country_code = country_code.upper()
                if not isinstance(country_code, str) or len(country_code) != 2:
                    raise ServerError(
                        f"Invalid country code '{country_code}'. "
                        "Please use a two-letter country code (e.g. 'US', 'GB', 'DE')"
                    )

                # Check if country exists in our cache
                cache = self.get_servers_cache()
                valid_countries = {
                    s.get("country", {}).get("code", "").upper()
                    for s in cache.get("servers", [])
                    if s.get("country", {}).get("code")
                }

                if country_code not in valid_countries:
                    available = ", ".join(sorted(valid_countries))
                    raise ServerError(
                        f"Country code '{country_code}' not found. "
                        f"Available countries: {available}"
                    )

            if _retry_count >= 3:
                # After 3 retries with our testing method, try the NordVPN recommendations API
                try:
                    if self.api_client.verbose:
                        self.logger.info("Falling back to NordVPN recommendations API")

                    # Get recommended server
                    url = "https://api.nordvpn.com/v1/servers/recommendations"
                    params = {
                        "filters[servers_technologies][identifier]": "openvpn_tcp",
                        "limit": "5",
                    }

                    if country_code:
                        params["filters[country_id]"] = self._get_country_id(
                            country_code
                        )

                    response = requests.get(
                        url, params=params, headers=API_HEADERS, timeout=10
                    )
                    response.raise_for_status()
                    servers = response.json()

                    if not servers:
                        if self.api_client.verbose:
                            self.logger.error(
                                "No servers returned by recommendations API"
                            )
                        return None

                    # Get server with lowest load
                    server = min(servers, key=lambda x: x.get("load", 100))

                    # Convert to our format
                    return {
                        "hostname": server["hostname"],
                        "load": server.get("load", 0),
                        "country": {
                            "code": server.get("country", {}).get("code", ""),
                            "name": server.get("country", {}).get("name", "Unknown"),
                        },
                    }

                except Exception as e:
                    if self.api_client.verbose:
                        self.logger.error(f"Recommendations API fallback failed: {e}")
                    return None

            try:
                # Get cached servers
                cache = self.get_servers_cache()
                servers = cache.get("servers", [])

                if not servers:
                    return None

                # Filter by country if specified
                if country_code:
                    servers = [
                        s
                        for s in servers
                        if s.get("country", {}).get("code", "").upper()
                        == country_code.upper()
                    ]

                # Remove failed servers
                servers = [
                    s for s in servers if s.get("hostname") not in self._failed_servers
                ]

                if not servers:
                    if self._failed_servers:
                        self._failed_servers.clear()
                        return self.select_fastest_server(
                            country_code, random_select, _retry_count + 1
                        )
                    return None

                # Basic filtering
                servers = [
                    s for s in servers if s.get("load", 100) < 90
                ]  # Skip heavily loaded servers

                if random_select:
                    return random.choice(servers)

                # Select 4 servers - use geographic distribution if no country specified
                test_servers = (
                    self._select_diverse_servers(servers, 4)
                    if not country_code
                    else random.sample(servers, min(4, len(servers)))
                )

                # Test servers in parallel using ThreadPoolExecutor
                with ThreadPoolExecutor(max_workers=4) as executor:
                    # Map _test_server over servers in parallel
                    results = list(
                        executor.map(lambda s: self._test_server(s), test_servers)
                    )

                # Filter out failed servers and sort by score
                valid_results = [
                    (s, score) for s, score in results if score < float("inf")
                ]

                if not valid_results:
                    # If all servers failed, mark them as failed and retry
                    for server in test_servers:
                        if hostname := server.get("hostname"):
                            self._failed_servers.add(hostname)
                    return self.select_fastest_server(
                        country_code, random_select, _retry_count + 1
                    )

                # Return server with best score
                best_server = min(valid_results, key=lambda x: x[1])[0]

                if self.api_client.verbose:
                    self.logger.info(
                        f"Selected server: {best_server.get('hostname')} "
                        f"(load: {best_server.get('load')}%, "
                        f"score: {min(s for _, s in valid_results):.1f}ms)"
                    )

                return best_server

            except Exception as e:
                self.logger.error(f"Error selecting server: {e}")
                return None

        except Exception as e:
            self.logger.error(f"Error selecting server: {e}")
            return None

    def _get_country_id(self, country_code: str) -> str:
        """Get NordVPN country ID from country code.

        Args:
            country_code: Two-letter country code

        Returns:
            Country ID or empty string if not found
        """
        try:
            # First check our cache
            cache = self.get_servers_cache()
            for server in cache.get("servers", []):
                if (
                    server.get("country", {}).get("code", "").upper()
                    == country_code.upper()
                ):
                    if country_id := server.get("country", {}).get("id"):
                        return str(country_id)

            # If not in cache, try API
            response = requests.get(
                "https://api.nordvpn.com/v1/servers/countries",
                headers=API_HEADERS,
                timeout=10,
            )
            response.raise_for_status()

            for country in response.json():
                if country.get("code", "").upper() == country_code.upper():
                    return str(country["id"])

        except Exception as e:
            if self.api_client.verbose:
                self.logger.warning(f"Failed to get country ID: {e}")

        return ""

    def get_random_country(self) -> str:
        try:
            cache = self.get_servers_cache()
            countries = {
                s.get("country", {}).get("code")
                for s in cache.get("servers", [])
                if s.get("country", {}).get("code")
            }
            if not countries:
                raise ServerError("No countries found in server list")
            return random.choice(list(countries))
        except Exception as e:
            self.logger.exception(f"Failed to get random country: {e}")
            return "US"

    def get_country_info(self, country_code: str) -> dict[str, Any] | None:
        """Get country information from NordVPN API.

        Args:
            country_code: Two-letter country code

        Returns:
            Dictionary with country information or None if not found

        """
        try:
            # Use v1 API endpoint
            response = requests.get(
                "https://api.nordvpn.com/v1/servers/countries",
                headers=API_HEADERS,
                timeout=10,
            )
            response.raise_for_status()
            countries = response.json()

            # Find country by code
            for country in countries:
                if (
                    isinstance(country, dict)
                    and country.get("code", "").upper() == country_code.upper()
                ):
                    return {
                        "code": country["code"],
                        "name": country["name"],
                        "id": country["id"],
                    }

            return None

        except Exception as e:
            self.logger.exception(f"Failed to get country info: {e}")
            return None

================
File: src/nyord_vpn/network/vpn_commands.py
================
"""OpenVPN command construction and management.

this_file: src/nyord_vpn/network/vpn_commands.py

This module provides utilities for constructing and managing OpenVPN commands.
It centralizes all OpenVPN-related command construction to ensure consistency
and proper configuration across the application.
"""

from pathlib import Path
from typing import List

from nyord_vpn.exceptions import VPNConfigError


def get_openvpn_command(
    config_path: Path,
    auth_path: Path,
    log_path: Path | None = None,
    verbosity: int = 5,
    connect_retry: int = 2,
    connect_timeout: int = 10,
    ping_interval: int = 10,
    ping_restart: int = 60,
) -> List[str]:
    """Construct OpenVPN command with all necessary arguments.

    This is the central place for OpenVPN command construction. It provides
    a comprehensive set of options for connection management, monitoring,
    and error handling.

    Args:
        config_path: Path to OpenVPN config file
        auth_path: Path to authentication file
        log_path: Optional path to log file
        verbosity: Logging verbosity level (1-6)
        connect_retry: Number of connection retry attempts
        connect_timeout: Connection timeout in seconds
        ping_interval: Interval between ping tests in seconds
        ping_restart: Time without ping response before restart

    Returns:
        List of command arguments for OpenVPN

    Raises:
        VPNConfigError: If required files don't exist or aren't accessible

    Note:
        The command includes security-focused defaults and robust
        error handling parameters to ensure stable VPN connections.
    """
    # Validate required files
    if not config_path.exists():
        raise VPNConfigError(f"OpenVPN config file not found: {config_path}")
    if not auth_path.exists():
        raise VPNConfigError(f"OpenVPN auth file not found: {auth_path}")

    # Validate file permissions (should be readable)
    try:
        config_path.read_bytes()
        auth_path.read_bytes()
    except (PermissionError, OSError) as e:
        raise VPNConfigError(f"Cannot read OpenVPN files: {e}")

    # Create log directory if needed
    if log_path:
        log_path.parent.mkdir(parents=True, exist_ok=True)

    # Validate verbosity level
    if not 1 <= verbosity <= 6:
        raise VPNConfigError(f"Invalid verbosity level: {verbosity} (must be 1-6)")

    cmd = [
        "openvpn",
        "--config",
        str(config_path),
        "--auth-user-pass",
        str(auth_path),
        "--verb",
        str(verbosity),
        "--connect-retry",
        str(connect_retry),
        "--connect-timeout",
        str(connect_timeout),
        "--resolv-retry",
        "infinite",
        "--ping",
        str(ping_interval),
        "--ping-restart",
        str(ping_restart),
    ]

    if log_path:
        cmd.extend(["--log", str(log_path)])

    return cmd

================
File: src/nyord_vpn/network/vpn.py
================
"""VPN connection management module.

this_file: src/nyord_vpn/network/vpn.py

This module provides the VPNConnectionManager class that handles
OpenVPN connections to NordVPN servers.

Core Responsibilities:
1. OpenVPN process management and configuration
2. Connection establishment and verification
3. IP address tracking and validation
4. Connection state management
5. Config file generation and cleanup

Integration Points:
- Used by Client (core/client.py) for VPN operations
- Uses templates from utils/templates.py for config
- Uses connection utils from utils/connection.py
- Stores state via utils/utils.py

Security Features:
- Strong encryption (AES-256-GCM)
- Certificate validation
- DNS leak prevention
- Secure process management

Error Handling:
- Graceful process termination
- Connection verification
- State recovery
- Detailed error messages

The manager implements robust connection handling with:
- Automatic retry logic
- Connection health monitoring
- Process cleanup on errors
- State persistence for recovery
"""

import subprocess
import time
from pathlib import Path
from typing import Any
import requests
from rich.progress import Progress, SpinnerColumn, TextColumn
from loguru import logger
import shutil
import psutil
import os
import signal

from nyord_vpn.exceptions import (
    VPNError,
    VPNAuthenticationError,
    VPNConfigError,
    VPNProcessError,
)
from nyord_vpn.utils.templates import (
    get_config_path,
    download_config_zip,
)
from nyord_vpn.network.vpn_commands import get_openvpn_command
from nyord_vpn.utils.utils import (
    OPENVPN_AUTH,
    OPENVPN_CONFIG,
    OPENVPN_LOG,
    API_HEADERS,
)
from nyord_vpn.storage.state import save_vpn_state, load_vpn_state

# Constants
OPENVPN_AUTH = Path.home() / ".cache" / "nyord-vpn" / "openvpn.auth"
OPENVPN_LOG = Path.home() / ".cache" / "nyord-vpn" / "openvpn.log"


class VPNConnectionManager:
    """Manages VPN connections using OpenVPN.

    This class is responsible for the low-level VPN connection management:
    1. OpenVPN process control (start, stop, monitor)
    2. Configuration file management
    3. Connection state tracking and verification
    4. IP address monitoring and validation

    The manager maintains state about the current connection including:
    - Public IP when not connected to VPN
    - Connected IP after successful connection
    - Current server hostname
    - Connected country information
    """

    def __init__(self, verbose: bool = False) -> None:
        """Initialize VPN connection manager.

        Args:
            verbose: Whether to enable verbose logging

        """
        self.verbose = verbose
        self.logger = logger
        self.process: subprocess.Popen | None = None
        self.openvpn_path: str | None = None

        # Connection state
        self._normal_ip: str | None = None
        self._connected_ip: str | None = None
        self._server: str | None = None
        self._country_name: str | None = None

        # Load saved state
        state = load_vpn_state()
        self._normal_ip = state.get("normal_ip")
        self._connected_ip = state.get("connected_ip")
        self._server = state.get("server")
        self._country_name = state.get("country")

        # Ensure cache directory exists
        OPENVPN_AUTH.parent.mkdir(parents=True, exist_ok=True)

        # Try to find OpenVPN at init
        try:
            self.openvpn_path = self.check_openvpn_installation()
        except VPNError:
            if self.verbose:
                self.logger.warning("OpenVPN not found during initialization")

    def check_openvpn_installation(self) -> str:
        """Check if OpenVPN is installed and accessible.

        Returns:
            str: Path to OpenVPN executable

        Raises:
            VPNError: If OpenVPN is not installed or not accessible
        """
        try:
            # Try to find openvpn in common locations
            openvpn_paths = [
                "/usr/local/sbin/openvpn",  # Homebrew on macOS
                "/usr/sbin/openvpn",  # Linux
                "/opt/homebrew/sbin/openvpn",  # Apple Silicon macOS
            ]

            for path in openvpn_paths:
                if Path(path).exists():
                    # Verify we can run it
                    result = subprocess.run(
                        [path, "--version"], capture_output=True, text=True, check=False
                    )
                    if result.returncode == 0:
                        if self.verbose:
                            self.logger.debug(f"Found OpenVPN at {path}")
                        return path

            # If not found in common paths, try which
            try:
                result = subprocess.run(
                    ["which", "openvpn"], capture_output=True, text=True, check=True
                )
                path = result.stdout.strip()
                if path:
                    if self.verbose:
                        self.logger.debug(f"Found OpenVPN at {path}")
                    return path
            except subprocess.CalledProcessError:
                pass

            raise VPNError(
                "OpenVPN not found. Please install OpenVPN:\n"
                "  macOS: brew install openvpn\n"
                "  Linux: sudo apt install openvpn  # or your distro's package manager"
            )

        except Exception as e:
            if isinstance(e, VPNError):
                raise
            raise VPNError(f"Failed to verify OpenVPN installation: {e}")

    def setup_connection(self, hostname: str, username: str, password: str) -> None:
        """Set up VPN connection configuration.

        This method prepares the authentication and configuration files needed
        for establishing a VPN connection. It must be called before connect().

        Args:
            hostname: VPN server hostname to connect to
            username: NordVPN username
            password: NordVPN password

        Raises:
            VPNAuthenticationError: If credentials are invalid or auth file creation fails
            VPNConfigError: If config file creation fails
        """
        try:
            # Store Public IP before connecting
            if not self._normal_ip:
                self._normal_ip = self.get_current_ip()
                self._save_state()

            # Create auth file with credentials
            auth_content = f"{username}\n{password}"
            OPENVPN_AUTH.write_text(auth_content)
            OPENVPN_AUTH.chmod(0o600)

            if self.verbose:
                self.logger.debug(f"Created auth file at {OPENVPN_AUTH}")

        except Exception as e:
            raise VPNAuthenticationError(f"Failed to create auth file: {e}")

    def get_current_ip(self) -> str | None:
        """Get current IP address with retries and consensus.

        Attempts to get the current public IP address using multiple services
        with validation, retries and consensus checking. Uses a combination of:
        1. ipify.org (IPv4 and IPv6)
        2. ip-api.com
        3. icanhazip.com
        4. ifconfig.me
        5. ipecho.net

        Returns:
            Current public IP address or None if unavailable after all retries

        Note:
            Uses exponential backoff between retries and validates
            IP format before returning. Requires consensus among
            multiple services to ensure accuracy.
        """
        urls = [
            "https://api.ipify.org?format=json",
            "https://api64.ipify.org?format=json",
            "http://ip-api.com/json",
            "https://icanhazip.com",
            "https://ifconfig.me/ip",
            "https://ipecho.net/plain",
        ]

        def is_valid_ipv4(ip: str) -> bool:
            """Validate IPv4 address format."""
            try:
                parts = ip.strip().split(".")
                if len(parts) != 4:
                    return False
                return all(0 <= int(part) <= 255 for part in parts)
            except (AttributeError, TypeError, ValueError):
                return False

        # Track IP addresses seen from different services
        ip_counts: dict[str, int] = {}
        valid_ips: list[str] = []

        for attempt in range(3):
            for url in urls:
                try:
                    if self.verbose:
                        self.logger.debug(
                            f"Attempting to get IP from {url} (attempt {attempt + 1}/3)"
                        )

                    response = requests.get(url, timeout=5)
                    response.raise_for_status()

                    # Handle different API response formats
                    if url.endswith(("plain", "/ip")):
                        ip = response.text.strip()
                    else:
                        try:
                            data = response.json()
                            ip = data.get("ip") or data.get("query")
                        except requests.exceptions.JSONDecodeError:
                            continue

                    # Validate IP format
                    if ip and is_valid_ipv4(ip):
                        if self.verbose:
                            self.logger.debug(f"Got valid IP {ip} from {url}")
                        valid_ips.append(ip)
                        ip_counts[ip] = ip_counts.get(ip, 0) + 1

                        # If we have a strong consensus (same IP from 3+ services)
                        # or we've seen this IP from more than half of successful services
                        if (ip_counts[ip] >= 3) or (
                            ip_counts[ip] >= (len(valid_ips) + 1) // 2
                        ):
                            if self.verbose:
                                self.logger.debug(
                                    f"IP {ip} confirmed by {ip_counts[ip]} services"
                                )
                            return ip
                    elif self.verbose:
                        self.logger.debug(f"Invalid IP format from {url}: {ip}")

                except Exception as e:
                    if self.verbose:
                        self.logger.debug(f"Failed to get IP from {url}: {e}")
                    continue

            # If we have any valid IPs but no strong consensus,
            # return the most frequently seen one
            if valid_ips and not any(count >= 3 for count in ip_counts.values()):
                most_common_ip = max(ip_counts.items(), key=lambda x: x[1])[0]
                if self.verbose:
                    self.logger.debug(
                        f"Using most common IP {most_common_ip} seen "
                        f"{ip_counts[most_common_ip]} times"
                    )
                return most_common_ip

            # Wait before next attempt (exponential backoff)
            if attempt < 2:  # Don't sleep after last attempt
                time.sleep(2**attempt)

        if self.verbose:
            if valid_ips:
                self.logger.warning(
                    "Multiple IPs detected without consensus: "
                    + ", ".join(f"{ip}({count})" for ip, count in ip_counts.items())
                )
            else:
                self.logger.warning("Failed to get current IP after all retries")
        return None

    def _save_state(self) -> None:
        """Save current connection state."""
        current_ip = self.get_current_ip()
        state = {
            "connected": self.is_connected(),
            "current_ip": current_ip,  # Used to update normal_ip when disconnected
            "normal_ip": self._normal_ip,
            "connected_ip": self._connected_ip,
            "server": self._server,
            "country": self._country_name,
            "timestamp": time.time(),
        }
        save_vpn_state(state)

    def connect(self, server: dict[str, Any]) -> None:
        """Connect to a VPN server.

        Args:
            server: Server information dictionary containing:
                - hostname: Server hostname for connection
                - (optional) additional server metadata

        Raises:
            VPNError: If connection fails due to:
                - Invalid server information
                - Missing authentication
                - OpenVPN process failure
                - Connection verification failure
                - Timeout during connection

        Note:
            This method requires root/sudo privileges to establish the VPN connection.
            The authentication file should be at ~/.cache/nyord-vpn/openvpn.auth
            with username on first line and password on second line.
        """
        try:
            hostname = server.get("hostname")
            if not hostname:
                raise VPNError("Invalid server info - missing hostname")

            # Ensure OpenVPN is available
            if not self.openvpn_path:
                self.openvpn_path = self.check_openvpn_installation()

            if self.verbose:
                self.logger.debug(f"Connecting to {hostname}")

            # Store initial IP
            self._normal_ip = self.get_current_ip()

            # Get OpenVPN config
            config_path = get_config_path(hostname)
            if not config_path:
                raise VPNConfigError(f"Failed to get OpenVPN config for {hostname}")

            # Verify auth file exists and has correct format
            if not OPENVPN_AUTH.exists():
                raise VPNAuthenticationError(
                    "Authentication file not found. Please create ~/.cache/nyord-vpn/openvpn.auth with your NordVPN credentials:\n"
                    "  1. Set your credentials as environment variables:\n"
                    "     export NORD_USER='your_nordvpn_username'\n"
                    "     export NORD_PASSWORD='your_nordvpn_password'\n"
                    "  2. Create the auth file:\n"
                    '     echo "$NORD_USER" > ~/.cache/nyord-vpn/openvpn.auth\n'
                    '     echo "$NORD_PASSWORD" >> ~/.cache/nyord-vpn/openvpn.auth\n'
                    "\nThe file should contain your username on the first line and password on the second line.",
                )

            try:
                auth_lines = OPENVPN_AUTH.read_text().strip().splitlines()
                if len(auth_lines) != 2 or not all(line.strip() for line in auth_lines):
                    raise VPNAuthenticationError(
                        "Invalid auth file format. The file should contain exactly two non-empty lines:\n"
                        "  Line 1: Your NordVPN username\n"
                        "  Line 2: Your NordVPN password",
                    )
            except Exception as e:
                if isinstance(e, VPNAuthenticationError):
                    raise
                raise VPNAuthenticationError(f"Failed to read auth file: {e}")

            # Start OpenVPN process
            cmd = get_openvpn_command(
                config_path=config_path,
                auth_path=OPENVPN_AUTH,
                log_path=OPENVPN_LOG if self.verbose else None,
                verbosity=5 if self.verbose else 3,
            )

            if self.verbose:
                self.logger.debug("Running OpenVPN command:")
                self.logger.debug(" ".join(cmd))
                if OPENVPN_LOG:
                    self.logger.debug(f"OpenVPN log file: {OPENVPN_LOG}")

            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                transient=True,
            ) as progress:
                progress.add_task(description="Connecting...", total=None)

                try:
                    self.process = subprocess.Popen(
                        cmd,
                        stdout=subprocess.PIPE,  # Always capture output for error handling
                        stderr=subprocess.PIPE,  # Always capture errors
                        text=True,
                        bufsize=1,  # Line buffered
                    )
                except subprocess.SubprocessError as e:
                    self.logger.error(f"Failed to start OpenVPN process: {e}")
                    if self.verbose:
                        self.logger.error(f"Command was: {' '.join(cmd)}")
                        self.logger.error(f"Error: {e}")
                    raise VPNProcessError(f"Failed to start OpenVPN process: {e}")

                # Monitor OpenVPN output for 30 seconds or until connection established
                start_time = time.time()
                while time.time() - start_time < 30:
                    if self.process.poll() is not None:
                        stdout, stderr = self.process.communicate()
                        error_msg = (
                            f"OpenVPN process failed:\n"
                            f"Command: {' '.join(cmd)}\n"
                            f"Exit code: {self.process.returncode}\n"
                            f"Output: {stdout}\n"
                            f"Error: {stderr}"
                        )
                        self.logger.error(error_msg)
                        raise VPNProcessError(error_msg)

                    # Always read output for logging
                    if self.process.stdout:
                        while True:
                            line = self.process.stdout.readline()
                            if not line:
                                break
                            line = line.strip()
                            if line:
                                if self.verbose:
                                    self.logger.debug(f"OpenVPN: {line}")
                                # Check for critical errors in output
                                if "ERROR:" in line:
                                    self.logger.error(f"OpenVPN error: {line}")
                                    if "Cannot resolve host address" in line:
                                        raise VPNError(
                                            f"Failed to resolve server: {line}"
                                        )
                                    if "TLS key negotiation failed" in line:
                                        raise VPNError(
                                            "Failed to establish secure connection"
                                        )

                    # Check if connection is established
                    if OPENVPN_LOG and OPENVPN_LOG.exists():
                        try:
                            log_content = OPENVPN_LOG.read_text()
                            if "Initialization Sequence Completed" in log_content:
                                self.logger.info("OpenVPN connection established")
                                break
                            if "AUTH_FAILED" in log_content:
                                self.logger.error("OpenVPN authentication failed")
                                if self.verbose:
                                    self.logger.error(f"OpenVPN log: {log_content}")
                                    self.logger.error(
                                        "Please check your NordVPN credentials in the auth file:"
                                    )
                                    self.logger.error(f"  {OPENVPN_AUTH}")
                                    self.logger.error("The file should contain:")
                                    self.logger.error("  Line 1: Your NordVPN username")
                                    self.logger.error("  Line 2: Your NordVPN password")
                                raise VPNAuthenticationError(
                                    "Authentication failed - check your credentials"
                                )
                            if "TLS Error" in log_content:
                                self.logger.error("OpenVPN TLS handshake failed")
                                if self.verbose:
                                    self.logger.error(f"OpenVPN log: {log_content}")
                                raise VPNError(
                                    "TLS handshake failed - server may be down"
                                )
                        except Exception as e:
                            self.logger.error(f"Failed to read OpenVPN log: {e}")
                            if self.verbose:
                                self.logger.error(f"Log path: {OPENVPN_LOG}")

                    time.sleep(0.1)

                else:
                    self.logger.error("OpenVPN connection timed out")
                    if self.verbose and OPENVPN_LOG and OPENVPN_LOG.exists():
                        try:
                            self.logger.error(f"OpenVPN log: {OPENVPN_LOG.read_text()}")
                            self.logger.error(f"Command was: {' '.join(cmd)}")
                        except Exception as e:
                            self.logger.error(f"Failed to read OpenVPN log: {e}")
                    raise VPNError("Connection timed out after 30 seconds")

            # Verify connection is working
            if not self.verify_connection():
                raise VPNError("VPN connection failed verification")

            # Update connection info
            self._server = hostname
            self._connected_ip = self.get_current_ip()

            if self.verbose:
                self.logger.info(f"Connected to {hostname}")

        except Exception as e:
            if isinstance(e, (VPNError, VPNAuthenticationError, VPNConfigError)):
                raise
            raise VPNError(f"Failed to connect to VPN: {e}")

    def disconnect(self) -> None:
        """Disconnect from VPN and clean up.

        Performs a clean disconnection:
        1. Terminates OpenVPN process
        2. Updates connection state
        3. Records Public IP
        4. Cleans up resources
        """
        try:
            state = load_vpn_state()
            process_id = state.get("process_id")

            if process_id:
                try:
                    os.kill(process_id, signal.SIGTERM)
                    if self.verbose:
                        self.logger.debug(f"Terminated OpenVPN process {process_id}")
                except ProcessLookupError:
                    if self.verbose:
                        self.logger.debug(f"Process {process_id} already terminated")
                except Exception as e:
                    if self.verbose:
                        self.logger.warning(
                            f"Failed to terminate process {process_id}: {e}"
                        )

            # Get current IP for accurate state
            current_ip = self.get_current_ip()

            # Update state
            state.update(
                {
                    "connected": False,
                    "process_id": None,
                    "server": None,
                    "country": None,
                    "connected_ip": None,
                    "current_ip": current_ip,
                }
            )

            # If we have a current IP and no normal_ip, update it
            if current_ip and not state.get("normal_ip"):
                state["normal_ip"] = current_ip

            save_vpn_state(state)

            if self.verbose:
                self.logger.info(
                    f"Disconnected from VPN. Public IP: {state.get('normal_ip')}"
                )

        except Exception as e:
            if self.verbose:
                self.logger.error(f"Error during disconnect: {e}")
            raise VPNError("Failed to disconnect from VPN") from e

    def is_connected(self) -> bool:
        """Check if OpenVPN process is running."""
        return self.process is not None and self.process.poll() is None

    def verify_connection(self) -> bool:
        """Verify VPN connection is active and functioning.

        Performs multiple checks to ensure the VPN connection is working:
        1. Verifies OpenVPN process is running
        2. Checks current IP has changed from Public IP
        3. Validates connection with NordVPN API (if available)
        4. Ensures IP address is reachable

        Returns:
            bool: True if connection is verified active, False otherwise

        Note:
            This method is used both during connection establishment
            and for periodic connection health checks. It gracefully
            handles API failures by falling back to IP-based verification.
        """
        try:
            # Check if process is running
            if not self.is_connected():
                return False

            # Get current IP
            current_ip = self.get_current_ip()
            if not current_ip:
                return False

            # Check if IP has changed from Public IP
            if current_ip == self._normal_ip:
                return False

            # Check NordVPN API for connection status
            try:
                response = requests.get(
                    "https://nordvpn.com/wp-admin/admin-ajax.php?action=get_user_info_data",
                    headers=API_HEADERS,
                    timeout=5,
                )
                response.raise_for_status()
                nord_data = response.json()
                if not nord_data.get("status", False):
                    return False
            except Exception:
                # If API check fails, just verify IP change
                pass

            return True

        except Exception:
            return False

    def status(self) -> dict[str, Any]:
        """Get current VPN status.

        Returns:
            dict: Status information including:
                - connected (bool): Whether connected to VPN
                - ip (str): Current IP address
                - normal_ip (str): IP when not connected to VPN
                - server (str): Connected server if any
                - country (str): Connected country if any
        """
        try:
            # Get current IP
            current_ip = self.get_current_ip()
            if not current_ip:
                return {
                    "connected": False,
                    "ip": None,
                    "normal_ip": self._normal_ip,
                    "server": None,
                    "country": None,
                }

            # Load state
            state = load_vpn_state()

            # Check if OpenVPN is running
            openvpn_running = False
            for proc in psutil.process_iter(["name"]):
                if proc.info["name"] == "openvpn":
                    openvpn_running = True
                    break

            # Check NordVPN API for connection status
            try:
                response = requests.get(
                    "https://nordvpn.com/wp-admin/admin-ajax.php?action=get_user_info_data",
                    headers=API_HEADERS,
                    timeout=5,
                )
                response.raise_for_status()
                nord_data = response.json()

                # We're definitely not connected if current IP matches Public IP
                if self._normal_ip and current_ip == self._normal_ip:
                    is_connected = False
                else:
                    # Otherwise check all conditions:
                    # 1. OpenVPN is running
                    # 2. Current IP matches our last known VPN IP
                    # 3. Current IP is different from our Public IP
                    # 4. The IP is recognized by NordVPN
                    is_connected = (
                        openvpn_running
                        and current_ip == state.get("connected_ip")
                        and (not self._normal_ip or current_ip != self._normal_ip)
                        and nord_data.get("status", False)
                    )

                if is_connected:
                    # Update state to ensure it's fresh
                    self._connected_ip = current_ip
                    self._save_state()

                return {
                    "connected": is_connected,
                    "ip": current_ip,
                    "normal_ip": self._normal_ip,
                    "country": nord_data.get(
                        "country", state.get("country", "Unknown")
                    ),
                    "city": nord_data.get("city", "Unknown"),
                    "server": state.get("server"),
                }

            except requests.RequestException:
                # If NordVPN API check fails, use process and IP check
                # We're definitely not connected if current IP matches Public IP
                if self._normal_ip and current_ip == self._normal_ip:
                    is_connected = False
                else:
                    is_connected = (
                        openvpn_running
                        and current_ip == state.get("connected_ip")
                        and (not self._normal_ip or current_ip != self._normal_ip)
                    )

                return {
                    "connected": is_connected,
                    "ip": current_ip,
                    "normal_ip": self._normal_ip,
                    "country": state.get("country", "Unknown"),
                    "city": "Unknown",
                    "server": state.get("server"),
                }

        except Exception as e:
            raise VPNError(f"Failed to get status: {e}")

    def _is_process_running(self, process_id: int) -> bool:
        """Check if a process is running by its PID.

        Args:
            process_id: Process ID to check

        Returns:
            bool: True if running, False if not
        """
        try:
            os.kill(process_id, 0)
            return True
        except OSError:
            return False
        except Exception as e:
            if self.verbose:
                self.logger.debug(f"Error checking process {process_id}: {e}")
            return False

    def check_connection_state(self) -> bool:
        """Check current VPN connection state.

        Verifies the VPN connection by:
        1. Checking if OpenVPN process is running
        2. Validating current IP differs from Public IP
        3. Ensuring connection is established
        4. Updating state file with accurate IPs

        Returns:
            bool: True if connected to VPN, False otherwise
        """
        try:
            state = load_vpn_state()
            current_ip = self.get_current_ip()

            if not current_ip:
                if self.verbose:
                    self.logger.warning("Could not determine current IP")
                return False

            # If we're not connected, update the Public IP
            if not state.get("connected"):
                state["normal_ip"] = current_ip
                save_vpn_state(state)
                return False

            # Check if OpenVPN process is running
            process_id = state.get("process_id")
            if not process_id or not self._is_process_running(process_id):
                if self.verbose:
                    self.logger.debug("OpenVPN process not running")
                self.disconnect()
                return False

            # Compare current IP with Public IP
            normal_ip = state.get("normal_ip")
            if normal_ip == current_ip:
                if self.verbose:
                    self.logger.debug(
                        f"Current IP ({current_ip}) matches Public IP ({normal_ip})"
                    )
                self.disconnect()
                return False

            # Update state with current IP
            state["connected_ip"] = current_ip
            save_vpn_state(state)

            if self.verbose:
                self.logger.debug(
                    f"Connection verified - Public IP: {normal_ip}, VPN IP: {current_ip}"
                )

            return True

        except Exception as e:
            if self.verbose:
                self.logger.error(f"Error checking connection state: {e}")
            return False

================
File: src/nyord_vpn/scripts/__init__.py
================
"""Utility scripts for nyord-vpn."""

================
File: src/nyord_vpn/scripts/update_countries.py
================
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["requests", "rich"]
# ///

"""Script to fetch and update the country list from NordVPN API."""

import json
import sys
import time
from pathlib import Path
from typing import TypedDict

import requests
from rich import print as rprint
from rich.progress import Progress, SpinnerColumn, TextColumn


class City(TypedDict):
    """City information from NordVPN API."""

    dns_name: str
    hub_score: int
    id: int
    latitude: float
    longitude: float
    name: str
    serverCount: int


class Country(TypedDict):
    """Country information from NordVPN API."""

    cities: list[City]
    code: str
    id: int
    name: str
    serverCount: int


class CountryCache(TypedDict):
    """Cache file structure."""

    countries: list[Country]
    last_updated: str


def fetch_countries() -> list[Country]:
    """Fetch countries from NordVPN API."""
    url = "https://api.nordvpn.com/v1/servers/countries"

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task(
            description="Fetching country list from NordVPN API...",
            total=None,
        )
        response = requests.get(url, timeout=10)
        response.raise_for_status()

    # The API already returns the exact structure we want
    countries: list[Country] = response.json()
    return sorted(countries, key=lambda x: x["name"])


def main() -> None:
    """Update the country list cache file."""
    try:
        # Get package data directory
        package_dir = Path(__file__).parent.parent
        data_dir = package_dir / "data"
        cache_file = data_dir / "countries.json"

        # Ensure data directory exists
        data_dir.mkdir(parents=True, exist_ok=True)

        # Fetch fresh data
        countries = fetch_countries()

        # Calculate total servers across all countries
        total_servers = sum(country["serverCount"] for country in countries)
        total_cities = sum(len(country["cities"]) for country in countries)

        # Prepare cache data
        cache_data: CountryCache = {
            "countries": countries,
            "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        }

        # Save to file
        with cache_file.open("w") as f:
            json.dump(cache_data, f, indent=2, sort_keys=True)
        cache_file.chmod(0o644)

        rprint("[green] Updated country list cache with:[/green]")
        rprint(f"   [cyan]{len(countries)}[/cyan] countries")
        rprint(f"   [cyan]{total_cities}[/cyan] cities")
        rprint(f"   [cyan]{total_servers}[/cyan] servers")
        rprint(f"[blue]Cache file: {cache_file}[/blue]")

    except requests.RequestException as e:
        rprint(f"[red] Failed to fetch country list: {e}[/red]")
        sys.exit(1)
    except (OSError, json.JSONDecodeError) as e:
        rprint(f"[red] Failed to update cache file: {e}[/red]")
        sys.exit(1)


if __name__ == "__main__":
    main()

================
File: src/nyord_vpn/storage/models.py
================
"""Data models and exceptions for the NordVPN client.

this_file: src/nyord_vpn/storage/models.py

This module defines the core data structures and error handling for the client.
It provides type-safe models for API data and a comprehensive exception hierarchy.

Data Models:
1. TypedDict classes for API responses:
   - City: Server location information
   - Country: Country-level server data
   - CountryCache: Cache storage format

Integration Points:
- Used by Client (core/client.py) for data handling
- Used by NordVPNAPIClient (core/api.py) for responses
- Used by ServerManager (network/server.py) for data
- Used throughout codebase for error handling

Exception Hierarchy:
1. VPNError - Base exception for all client errors
2. Specific exceptions for different scenarios:
   - ServerError: Server selection issues
   - ConnectionError: Connection failures
   - AuthenticationError: Credential problems
   - StateError: State management issues
   - CacheError: Cache operation failures

Error Handling Design:
- Each exception provides detailed error messages
- Includes recovery suggestions in messages
- Maintains consistent error handling patterns
- Supports both CLI and library usage

The models ensure type safety and data validation throughout
the codebase, while the exception hierarchy provides clear
error handling patterns and user-friendly error messages.
"""

from typing import TypedDict


class City(TypedDict):
    """City information from NordVPN API.

    Represents a city where NordVPN servers are located, including:
    - Geographic information (coordinates)
    - Server infrastructure details
    - Connection quality metrics

    Attributes:
        dns_name: DNS hostname component for server addresses
        hub_score: Infrastructure quality score (0-100)
        id: Unique city identifier
        latitude: Geographic latitude
        longitude: Geographic longitude
        name: Human-readable city name
        serverCount: Number of available servers

    """

    dns_name: str
    hub_score: int
    id: int
    latitude: float
    longitude: float
    name: str
    serverCount: int


class Country(TypedDict):
    """Country information from NordVPN API.

    Represents a country with NordVPN server presence, containing:
    - Basic country information
    - List of cities with servers
    - Server availability metrics

    Attributes:
        cities: List of City objects with server information
        code: Two-letter ISO country code
        id: Unique country identifier
        name: Full country name
        serverCount: Total servers in the country

    Note:
        The serverCount is the sum of all servers across cities,
        providing a quick way to assess server availability.

    """

    cities: list[City]
    code: str
    id: int
    name: str
    serverCount: int


class CountryCache(TypedDict):
    """Cache structure for country and server information.

    Provides a persistent storage format for server data:
    - Complete country and city information
    - Cache metadata for freshness checking

    Attributes:
        countries: List of Country objects with full server info
        last_updated: ISO 8601 timestamp of last update

    Note:
        This structure is used for both file storage and memory
        caching, ensuring consistent data representation.

    """

    countries: list[Country]
    last_updated: str


class VPNError(Exception):
    """Base exception for all VPN-related errors.

    Provides common functionality for VPN error handling:
    1. Default error messages
    2. Optional custom messages
    3. Base for specific error types

    All VPN-related exceptions should inherit from this class
    to ensure consistent error handling throughout the client.
    """

    def __init__(self, message: str | None = None) -> None:
        """Initialize base VPN error.

        Args:
            message: Optional custom error message
                    Falls back to generic message if None

        """
        super().__init__(message or "An unknown VPN error occurred")


class ServerError(VPNError):
    """Exception for server selection and availability issues.

    Raised when:
    1. No servers available in selected country
    2. Server selection algorithm fails
    3. Selected server becomes unavailable
    4. Load balancing cannot find suitable server

    The error message includes suggestions for resolution,
    such as trying a different country or server.
    """

    def __init__(self, message: str | None = None) -> None:
        """Initialize server error with helpful message.

        Args:
            message: Optional specific error details
                    Falls back to guidance message if None

        """
        super().__init__(
            message
            or "Failed to select a server. Please try again or choose a different country.",
        )


class ConnectionError(VPNError):
    """Exception for VPN connection establishment failures.

    Raised when:
    1. OpenVPN process fails to start
    2. Connection times out
    3. Network is unreachable
    4. System configuration prevents connection

    Includes diagnostic information and recovery steps
    in the error message.
    """

    def __init__(self, message: str | None = None) -> None:
        """Initialize connection error with diagnostics.

        Args:
            message: Optional connection failure details
                    Falls back to troubleshooting steps if None

        """
        super().__init__(
            message
            or "Failed to establish VPN connection. Please check your internet connection and try again.",
        )


class AuthenticationError(VPNError):
    """Exception for NordVPN authentication failures.

    Raised when:
    1. Invalid credentials provided
    2. Account is inactive or expired
    3. API authentication fails
    4. Token refresh fails

    Provides clear guidance on credential verification
    and account status checking.
    """

    def __init__(self, message: str | None = None) -> None:
        """Initialize authentication error with guidance.

        Args:
            message: Optional auth failure details
                    Falls back to credential check message if None

        """
        super().__init__(
            message or "Authentication failed. Please check your NordVPN credentials.",
        )


class CredentialsError(VPNError):
    """Exception for missing or invalid credentials.

    Raised when:
    1. Required environment variables are missing
    2. Credentials file is not found
    3. Credentials format is invalid
    4. Credentials are not properly set

    Provides detailed instructions for credential setup
    including environment variables and file locations.
    """

    def __init__(self, message: str | None = None) -> None:
        """Initialize credentials error with setup instructions.

        Args:
            message: Optional specific error details
                    Falls back to setup instructions if None

        """
        super().__init__(
            message
            or (
                "NordVPN credentials not found. Please set environment variables:\n"
                "  export NORD_USER='your-username'\n"
                "  export NORD_PASSWORD='your-password'\n"
                "\nOr provide them directly when running the command:\n"
                "  NORD_USER='your-username' NORD_PASSWORD='your-password' nyord-vpn <command>"
            ),
        )


class StateError(VPNError):
    """Exception for VPN state management failures.

    Raised when:
    1. State file operations fail
    2. State becomes inconsistent
    3. State transition fails
    4. State validation fails

    Includes recovery steps to restore consistent state
    through disconnection and reconnection.
    """

    def __init__(self, message: str | None = None) -> None:
        """Initialize state error with recovery steps.

        Args:
            message: Optional state error details
                    Falls back to recovery instructions if None

        """
        super().__init__(
            message
            or "Failed to manage VPN state. Please try disconnecting and reconnecting.",
        )


class CacheError(VPNError):
    """Exception for cache operation failures.

    Raised when:
    1. Cache file operations fail
    2. Cache data is corrupted
    3. Cache update fails
    4. Cache validation fails

    Provides instructions for cache refresh and
    manual cache management when needed.
    """

    def __init__(self, message: str | None = None) -> None:
        """Initialize cache error with refresh instructions.

        Args:
            message: Optional cache error details
                    Falls back to refresh instructions if None

        """
        super().__init__(
            message
            or "Failed to manage cache. Try running 'nyord-vpn update' to refresh the cache.",
        )

================
File: src/nyord_vpn/storage/state.py
================
import json
import time

from nyord_vpn.utils.utils import STATE_FILE, logger


def save_vpn_state(state: dict) -> None:
    """Save VPN connection state to persistent storage.

    Maintains a record of the VPN connection state including:
    1. Connection status and timing
    2. IP address information (original and VPN)
    3. Server details and location
    4. State metadata

    Args:
        state: Dictionary containing state information:
            - connected (bool): Current connection status
            - normal_ip (str): IP address when not connected to VPN
            - connected_ip (str): VPN-assigned IP
            - server (str): Connected server hostname
            - country (str): Server country
            - timestamp (float): State update time

    Note:
        The state file is used for connection recovery
        and status monitoring. Failed saves are logged
        but don't raise exceptions to prevent disrupting
        VPN operations.
    """
    try:
        # If we're saving a disconnected state, update normal_ip
        if not state.get("connected"):
            current_ip = state.get("current_ip")
            if current_ip:
                state["normal_ip"] = current_ip

        # Load existing state to preserve normal_ip if not present
        if STATE_FILE.exists():
            try:
                existing = json.loads(STATE_FILE.read_text())
                if not state.get("normal_ip"):
                    state["normal_ip"] = existing.get("normal_ip")
            except json.JSONDecodeError:
                pass

        # Ensure timestamp is updated
        state["timestamp"] = time.time()

        STATE_FILE.write_text(json.dumps(state, indent=2))
    except Exception as e:
        logger.warning(f"Failed to save VPN state: {e}")


def load_vpn_state() -> dict:
    """Load VPN connection state from storage.

    Retrieves and validates the stored VPN state:
    1. Checks state file existence
    2. Validates state freshness (5 minute TTL)
    3. Provides default state if needed

    Returns:
        dict: State information containing:
            - connected (bool): Connection status
            - normal_ip (str|None): IP when not connected to VPN
            - connected_ip (str|None): VPN IP
            - server (str|None): Server hostname
            - country (str|None): Server country
            - timestamp (float): Update time

    Note:
        The state is considered stale after 5 minutes
        to prevent using outdated connection information.
        Failed loads return a safe default state.
    """
    try:
        if STATE_FILE.exists():
            state = json.loads(STATE_FILE.read_text())
            # State is valid for 5 minutes
            if time.time() - state.get("timestamp", 0) < 300:
                return state
    except Exception as e:
        logger.warning(f"Failed to load VPN state: {e}")

    return {
        "connected": False,
        "normal_ip": None,  # IP address when not connected to VPN
        "connected_ip": None,  # IP address when connected to VPN
        "server": None,
        "country": None,
        "timestamp": time.time(),
    }

================
File: src/nyord_vpn/utils/__init__.py
================
"""Utility modules for nyord-vpn.

this_file: src/nyord_vpn/utils/__init__.py

This package contains utility modules for configuration management,
file handling, and other helper functions.
"""

================
File: src/nyord_vpn/utils/connection.py
================
"""Network connection utilities for VPN management.

this_file: src/nyord_vpn/utils/connection.py

This module provides utilities for VPN connection verification and monitoring.
It implements robust connection checking by combining multiple data sources.

Core Functionality:
1. Process monitoring for OpenVPN
2. Connection status verification
3. IP address change detection
4. Multi-source status validation

Integration Points:
- Used by VPNConnectionManager (network/vpn.py)
- Used by Client (core/client.py) for status
- Works with utils/utils.py for state
- Supports error handling in models.py

Connection Verification:
The module implements a sophisticated verification system:
1. Process state monitoring
2. IP address validation
3. API status integration
4. State consistency checks

Design Philosophy:
- Prefers multiple verification sources
- Implements graceful fallbacks
- Provides detailed status info
- Supports debugging and logging

The utilities ensure reliable connection status reporting
by combining multiple indicators and implementing fallback
logic when certain checks fail.
"""

import psutil


def is_openvpn_running() -> bool:
    """Check if any OpenVPN process is currently running.

    Uses psutil to scan all running processes and identify
    any OpenVPN instances. This is a key component of
    connection verification, as a running OpenVPN process
    is necessary (but not sufficient) for an active VPN.

    Returns:
        bool: True if an OpenVPN process is found,
              False if no OpenVPN process is running

    Note:
        This function only checks for process existence,
        not whether the process is functioning correctly
        or if the VPN connection is actually established.

    """
    for proc in psutil.process_iter(["name"]):
        if proc.info.get("name") == "openvpn":
            return True
    return False


def compute_connection_status(
    current_ip: str,
    initial_ip: str | None,
    connected_ip: str | None,
    openvpn_running: bool,
    nord_status: bool | None = None,
) -> bool:
    """Determine VPN connection status through multiple checks.

    This function implements a comprehensive connection verification
    algorithm that combines multiple data points:

    1. Process Check:
       - Verifies OpenVPN process is running

    2. IP Address Validation:
       - Compares current IP against initial (pre-VPN) IP
       - Verifies current IP matches expected VPN IP

    3. NordVPN API Status (if available):
       - Incorporates server-side connection status

    The algorithm handles various edge cases:
    - Initial connection establishment
    - Connection drops and recoveries
    - API unavailability
    - Process state mismatches

    Args:
        current_ip: Currently detected IP address
        initial_ip: IP address before VPN connection (may be None)
        connected_ip: Expected VPN IP address (may be None)
        openvpn_running: Whether OpenVPN process is active
        nord_status: Optional NordVPN API connection status

    Returns:
        bool: True if VPN connection is verified active,
              False if any verification step fails

    Note:
        The function implements fallback logic when the API
        status is unavailable, relying more heavily on
        local indicators in such cases.

    """
    if nord_status is not None:
        is_connected = (
            openvpn_running
            and (current_ip == connected_ip or nord_status)
            and (initial_ip is None or current_ip != initial_ip)
        )
    else:
        is_connected = (
            openvpn_running
            and (current_ip == connected_ip)
            and (initial_ip is None or current_ip != initial_ip)
        )
    if not is_connected and openvpn_running and current_ip == connected_ip:
        is_connected = True
    return is_connected

================
File: src/nyord_vpn/utils/templates.py
================
"""OpenVPN configuration templates and utilities.

this_file: src/nyord_vpn/utils/templates.py

This module handles OpenVPN configuration file management:
1. Config directory setup and maintenance
2. Config file download and extraction
3. Path resolution for config files
"""

import io
import shutil
import zipfile
from pathlib import Path

import requests
from loguru import logger

from nyord_vpn.exceptions import VPNConfigError

# Constants
CACHE_DIR = Path.home() / ".cache" / "nyord-vpn"
CONFIG_DIR = CACHE_DIR / "configs"
CONFIG_ZIP = CACHE_DIR / "ovpn.zip"
OVPN_CONFIG_URL = "https://downloads.nordcdn.com/configs/archives/servers/ovpn.zip"

# Browser-like headers to avoid 403
HEADERS = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
    "Accept": "application/json",
    "Accept-Language": "en-US,en;q=0.9",
    "Referer": "https://nordvpn.com/",
    "Origin": "https://nordvpn.com",
}


def extract_config_zip() -> None:
    """Extract OpenVPN configuration ZIP file.

    Extracts the downloaded ZIP file containing OpenVPN configurations.
    Removes UDP configurations as they are not used.

    Raises:
        VPNConfigError: If extraction fails
    """
    try:
        # Create config directory if needed
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        logger.debug(f"Ensuring config directory exists: {CONFIG_DIR}")

        # Extract configurations
        logger.debug(f"Extracting configurations from {CONFIG_ZIP}")
        with zipfile.ZipFile(CONFIG_ZIP) as zip_ref:
            # Log zip contents
            logger.debug("ZIP contents:")
            for name in zip_ref.namelist()[:5]:  # Show first 5 files
                logger.debug(f"  {name}")
            zip_ref.extractall(CONFIG_DIR)

        # Remove UDP configs as they're not used
        udp_dir = CONFIG_DIR / "ovpn_udp"
        if udp_dir.exists():
            logger.debug(f"Removing UDP configs directory: {udp_dir}")
            shutil.rmtree(udp_dir)

        # Fix ownership of extracted files
        import os
        import subprocess

        user_id = os.getuid()
        group_id = os.getgid()
        logger.debug(f"Fixing ownership to {user_id}:{group_id}")
        subprocess.run(
            ["sudo", "chown", "-R", f"{user_id}:{group_id}", str(CONFIG_DIR)],
            check=True,
        )

        # Log final state
        logger.debug(f"Extraction complete. Contents of {CONFIG_DIR}:")
        for item in CONFIG_DIR.iterdir():
            logger.debug(f"  {item}")

        logger.debug(f"OpenVPN configurations extracted to {CONFIG_DIR}")
    except Exception as e:
        raise VPNConfigError(f"Failed to extract configurations: {e}")


def download_config_zip() -> None:
    """Download and cache the OpenVPN configuration ZIP file.

    Downloads the ZIP file containing all OpenVPN configurations from NordVPN
    and caches it locally. The ZIP contains two folders:
    - ovpn_tcp/: TCP configurations
    - ovpn_udp/: UDP configurations (not used)

    Raises:
        VPNConfigError: If download or caching fails
    """
    try:
        # Create cache directory if needed
        CACHE_DIR.mkdir(parents=True, exist_ok=True)

        # Download configurations
        logger.debug("Downloading OpenVPN configurations...")
        response = requests.get(OVPN_CONFIG_URL, headers=HEADERS, timeout=30)
        response.raise_for_status()

        # Cache the ZIP file
        CONFIG_ZIP.write_bytes(response.content)
        logger.debug(f"OpenVPN configurations cached at {CONFIG_ZIP}")

        # Extract the configurations
        extract_config_zip()

        # Clean up the ZIP file
        CONFIG_ZIP.unlink()
    except Exception as e:
        raise VPNConfigError(f"Failed to download/cache configurations: {e}")


def get_config_path(server: str) -> Path:
    """Get path to OpenVPN config file for server.

    Args:
        server: Server hostname (e.g. us123.nordvpn.com)

    Returns:
        Path to config file

    Raises:
        VPNConfigError: If config file cannot be found or downloaded
    """
    # Remove .tcp suffix if present as configs are already in tcp directory
    server = server.replace(".tcp", "")

    # The config files in the ZIP have .tcp.ovpn extension
    config_path = CONFIG_DIR / "ovpn_tcp" / f"{server}.tcp.ovpn"
    logger.debug(f"Looking for config file at: {config_path}")

    # Log the directory contents if it exists
    if CONFIG_DIR.exists():
        logger.debug(f"Contents of {CONFIG_DIR}:")
        try:
            for item in CONFIG_DIR.iterdir():
                logger.debug(f"  {item}")

            tcp_dir = CONFIG_DIR / "ovpn_tcp"
            if tcp_dir.exists():
                logger.debug(f"Contents of {tcp_dir} (sample):")
                for item in list(tcp_dir.iterdir())[:5]:  # Show first 5 files
                    logger.debug(f"  {item}")
            else:
                logger.warning(f"TCP config directory not found at: {tcp_dir}")
        except Exception as e:
            logger.error(f"Error listing directory contents: {e}")

    # If config doesn't exist, try downloading
    if not config_path.exists():
        logger.debug(f"Config file not found at: {config_path}")
        logger.debug("Attempting to download configurations...")
        download_config_zip()

        # Verify config exists after download
        if not config_path.exists():
            logger.error(
                f"Config file still not found at: {config_path} after download"
            )
            logger.debug("Directory structure after download:")
            try:
                for item in CONFIG_DIR.iterdir():
                    logger.debug(f"  {item}")
                tcp_dir = CONFIG_DIR / "ovpn_tcp"
                if tcp_dir.exists():
                    logger.debug(f"Sample contents of {tcp_dir}:")
                    for item in list(tcp_dir.iterdir())[:5]:
                        logger.debug(f"  {item}")
            except Exception as e:
                logger.error(f"Error listing directory contents: {e}")
            raise VPNConfigError(f"Config file not found for server: {server}")
        else:
            logger.debug(f"Successfully found config at: {config_path} after download")

    return config_path

================
File: src/nyord_vpn/utils/utils.py
================
"""Utility functions and constants for the NordVPN client.

this_file: src/nyord_vpn/utils/utils.py

This module provides core utilities and configuration management.
It handles file paths, state persistence, and common functionality.

Directory Structure:
1. Cache Directory (~/.cache/nyord-vpn/):
   - Server information cache
   - Connection state
   - OpenVPN configuration
   - Authentication data

2. Config Directory (~/.cache/nyord-vpn/):
   - User configuration
   - Custom settings
   - Persistent data

3. Package Data:
   - Country mappings
   - Default configurations
   - Templates

Integration Points:
- Used throughout codebase for paths
- Used by Client (core/client.py) for state
- Used by VPNConnectionManager for config
- Used by API client for caching

Constants and Settings:
1. File Paths:
   - Cache locations
   - Config locations
   - State management
   - Log files

2. API Configuration:
   - Request headers
   - Cache settings
   - Country mappings

3. OpenVPN Settings:
   - Configuration paths
   - Authentication paths
   - Log paths

State Management:
- Implements atomic file operations
- Handles concurrent access
- Provides fallback data
- Manages cache lifecycle

The module ensures proper directory structure exists
and provides fallback data when needed, serving as
the foundation for the client's file operations and
state management.
"""

import json
import os
import sys
import subprocess
import time
from pathlib import Path

from platformdirs import user_cache_dir, user_config_dir
from rich.console import Console
from loguru import logger

console = Console()

# Application directories
APP_NAME = "nyord-vpn"
APP_AUTHOR = "twardoch"
CACHE_DIR = Path(user_cache_dir(APP_NAME, APP_AUTHOR))
CONFIG_DIR = Path(user_config_dir(APP_NAME, APP_AUTHOR))

# Ensure directories exist
CACHE_DIR.mkdir(parents=True, exist_ok=True)
CONFIG_DIR.mkdir(parents=True, exist_ok=True)

# File paths
PACKAGE_DIR = Path(__file__).parent
DATA_DIR = PACKAGE_DIR / "data"
CACHE_FILE = DATA_DIR / "countries.json"
COUNTRIES_CACHE = CACHE_DIR / "countries.json"
COUNTRY_IDS_FILE = DATA_DIR / "country_ids.json"
STATE_FILE = CACHE_DIR / "vpn_state.json"
OPENVPN_CONFIG = CACHE_DIR / "openvpn.ovpn"
OPENVPN_AUTH = CACHE_DIR / "openvpn.auth"
OPENVPN_LOG = CACHE_DIR / "openvpn.log"

# Cache expiry in seconds (24 hours)
CACHE_EXPIRY = 24 * 60 * 60  # 24 hours in seconds


def check_root() -> bool:
    """Check if running with root privileges.

    Returns:
        bool: True if already running as root, False if needs elevation
    """
    return os.geteuid() == 0


def ensure_root() -> None:
    """Request root privileges using sudo.

    This function checks if the current process has root privileges.
    If not, it attempts to re-run the script with sudo.

    The function will:
    1. Check current user's effective UID
    2. If not root, re-run with sudo
    3. Display appropriate messages
    4. Exit with status code on failure

    Note:
        This is required for OpenVPN operations which need
        root access to configure network interfaces.
    """
    if not check_root():
        try:
            # Get the original command without sudo
            cmd = sys.argv[:]
            if cmd[0].startswith("sudo"):
                cmd = cmd[1:]

            # Re-run the script with sudo, preserving environment variables
            env = os.environ.copy()

            # If in virtualenv, use nyord-vpn from virtualenv bin
            if os.environ.get("VIRTUAL_ENV"):
                nyord_vpn_path = os.path.join(
                    os.environ["VIRTUAL_ENV"], "bin", "nyord-vpn"
                )
                if os.path.exists(nyord_vpn_path):
                    args = ["sudo", "-E", nyord_vpn_path, *cmd[1:]]
                else:
                    # Fallback to system nyord-vpn
                    args = ["sudo", "-E", "nyord-vpn", *cmd[1:]]
            else:
                # Not in virtualenv, use system nyord-vpn
                args = ["sudo", "-E", "nyord-vpn", *cmd[1:]]

            console.print(
                "[yellow]This command requires admin privileges.[/yellow]",
            )
            console.print(
                "[cyan]Enter your computer admin (sudo) password when asked.[/cyan]"
            )

            if logger.level("DEBUG").no <= logger.level("INFO").no:
                logger.debug(f"Running command: {' '.join(args)}")

            subprocess.run(args, env=env, check=True)
            sys.exit(0)
        except subprocess.CalledProcessError as e:
            console.print("[red]Error: Admin privileges required.[/red]")
            console.print("[yellow]Run the command again with sudo:[/yellow]")
            console.print(f"[blue]sudo -E {' '.join(sys.argv)}[/blue]")
            if logger.level("DEBUG").no <= logger.level("INFO").no:
                logger.debug(f"Command failed with error: {e}")
            sys.exit(1)


def is_process_running(process_id: int) -> bool | None:
    """Check if a process is running by its PID.

    Args:
        process_id: Process ID to check

    Returns:
        bool: True if running, False if not, None if check fails
    """
    try:
        os.kill(process_id, 0)
        return True
    except OSError:
        return False
    except Exception:
        return None


def ensure_data_dir() -> None:
    """Ensure data directory exists and is writable."""
    DATA_DIR.mkdir(parents=True, exist_ok=True)


# Initialize data directory
ensure_data_dir()


# Load country ID mappings with fallback data
try:
    with open(COUNTRY_IDS_FILE) as f:
        NORDVPN_COUNTRY_IDS: dict[str, str] = json.load(f)
except (FileNotFoundError, json.JSONDecodeError):
    # Fallback to core countries if file is missing/invalid
    NORDVPN_COUNTRY_IDS = {
        "US": "228",  # United States
        "GB": "227",  # United Kingdom
        "DE": "81",  # Germany
    }

# API request headers to mimic browser behavior
API_HEADERS = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
    "Accept": "application/json",
    "Accept-Language": "en-US,en;q=0.9",
    "Referer": "https://nordvpn.com/",
    "Origin": "https://nordvpn.com",
}


def save_vpn_state(state: dict) -> None:
    """Save VPN connection state to persistent storage.

    Maintains a record of the VPN connection state including:
    1. Connection status and timing
    2. IP address information (original and VPN)
    3. Server details and location
    4. State metadata

    Args:
        state: Dictionary containing state information:
            - connected (bool): Current connection status
            - normal_ip (str): IP address when not connected to VPN
            - connected_ip (str): VPN-assigned IP
            - server (str): Connected server hostname
            - country (str): Server country
            - timestamp (float): State update time

    Note:
        The state file is used for connection recovery
        and status monitoring. Failed saves are logged
        but don't raise exceptions to prevent disrupting
        VPN operations.
    """
    try:
        # If we're saving a disconnected state, update normal_ip
        if not state.get("connected"):
            current_ip = state.get("current_ip")
            if current_ip:
                state["normal_ip"] = current_ip

        # Load existing state to preserve normal_ip if not present
        if STATE_FILE.exists():
            try:
                existing = json.loads(STATE_FILE.read_text())
                if not state.get("normal_ip"):
                    state["normal_ip"] = existing.get("normal_ip")
            except json.JSONDecodeError:
                pass

        # Ensure timestamp is updated
        state["timestamp"] = time.time()

        STATE_FILE.write_text(json.dumps(state, indent=2))
    except Exception as e:
        logger.warning(f"Failed to save VPN state: {e}")


def load_vpn_state() -> dict:
    """Load VPN connection state from storage.

    Retrieves and validates the stored VPN state:
    1. Checks state file existence
    2. Validates state freshness (5 minute TTL)
    3. Provides default state if needed

    Returns:
        dict: State information containing:
            - connected (bool): Connection status
            - normal_ip (str|None): IP when not connected to VPN
            - connected_ip (str|None): VPN IP
            - server (str|None): Server hostname
            - country (str|None): Server country
            - timestamp (float): Update time

    Note:
        The state is considered stale after 5 minutes
        to prevent using outdated connection information.
        Failed loads return a safe default state.
    """
    try:
        if STATE_FILE.exists():
            state = json.loads(STATE_FILE.read_text())
            # State is valid for 5 minutes
            if time.time() - state.get("timestamp", 0) < 300:
                return state
    except Exception as e:
        logger.warning(f"Failed to load VPN state: {e}")

    return {
        "connected": False,
        "normal_ip": None,  # IP address when not connected to VPN
        "connected_ip": None,  # IP address when connected to VPN
        "server": None,
        "country": None,
        "timestamp": time.time(),
    }

================
File: src/nyord_vpn/__init__.py
================
"""Modern Python client for NordVPN with automatic API fallback.

this_file: src/nyord_vpn/__init__.py

This package provides a comprehensive VPN client for NordVPN,
offering both a command-line interface and a Python library.

Package Structure:
1. Core Components (core/):
   - client.py: Main client implementation
   - api.py: NordVPN API client
   - base.py: Base classes and interfaces

2. Network Components (network/):
   - vpn.py: OpenVPN connection management
   - server.py: Server selection and management
   - country.py: Country information handling

3. Storage Components (storage/):
   - models.py: Data models and exceptions
   - state.py: State management

4. Utilities (utils/):
   - connection.py: Connection verification
   - templates.py: OpenVPN templates
   - utils.py: Common utilities

Command-Line Interface:
    nyord-vpn go <country>     Connect to VPN in specified country
    nyord-vpn bye             Disconnect from VPN
    nyord-vpn info            Show connection status
    nyord-vpn where           List available countries
    nyord-vpn update          Update country/server cache

Python Library Usage:
    from nyord_vpn import Client

    client = Client(username="user", password="pass")
    client.go("us")  # Connect to US server
    client.status()  # Check connection
    client.disconnect()  # Disconnect

Features:
1. Modern Security
   - AES-256-GCM encryption
   - ChaCha20-Poly1305 support
   - Strong certificate validation
   - DNS leak prevention

2. Smart Server Selection
   - Load-based balancing
   - Geographic optimization
   - Connection quality metrics
   - Automatic failover

3. Robust Error Handling
   - Comprehensive exception hierarchy
   - Detailed error messages
   - Recovery suggestions
   - Automatic retries

4. Performance Optimization
   - Connection caching
   - State persistence
   - Smart reconnection
   - API result caching

Requirements:
- OpenVPN (install via package manager)
- Python 3.9+
- Root/sudo access for VPN connections

Environment Variables:
    NORD_USER: NordVPN username
    NORD_PASSWORD: NordVPN password
"""

from nyord_vpn.core.client import Client
from nyord_vpn.storage.models import (
    ConnectionError,
    CredentialsError,
    ServerError,
    VPNError,
)

__version__ = "0.1.0"
__all__ = [
    "Client",
    "ConnectionError",
    "CredentialsError",
    "ServerError",
    "VPNError",
]

================
File: src/nyord_vpn/__main__.py
================
"""Command line interface for nyord-vpn."""

import os
import sys
import json
import subprocess
import time

import fire
from rich.console import Console
from rich.table import Table
from dotenv import load_dotenv

from nyord_vpn.core.client import Client, VPNError
from nyord_vpn.scripts.update_countries import fetch_countries
from nyord_vpn.utils.utils import check_root

console = Console()

# Load environment variables
load_dotenv()


class CLI:
    """NordVPN CLI interface."""

    def __init__(self, verbose: bool = False) -> None:
        """Initialize CLI."""
        try:
            # Get credentials from environment
            username = os.getenv("NORD_USER") or os.getenv("NORDVPN_LOGIN")
            password = os.getenv("NORD_PASSWORD") or os.getenv("NORDVPN_PASSWORD")

            if not username or not password:
                console.print("[red]Error: Missing credentials[/red]")
                console.print("Please set the following environment variables:")
                console.print("  NORD_USER or NORDVPN_LOGIN")
                console.print("  NORD_PASSWORD or NORDVPN_PASSWORD")
                sys.exit(1)

            self.client = Client(username, password, verbose=verbose)
        except VPNError as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)

    def go(self, country_code: str) -> None:
        """Connect to VPN in specified country."""
        check_root()
        try:
            self.client.go(country_code)
        except VPNError as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)

    def bye(self) -> None:
        """Disconnect from VPN."""
        check_root()
        try:
            self.client.bye()
        except VPNError as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)

    def info(self) -> None:
        """Display current VPN status."""
        try:
            self.client.info()
        except VPNError as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)

    def update(self) -> None:
        """Update country information."""
        try:
            fetch_countries()
            console.print("[green]Successfully updated country information[/green]")
        except Exception as e:
            console.print(f"[red]Error updating country information:[/red] {e}")
            sys.exit(1)


def main() -> None:
    """Main entry point."""
    try:
        fire.Fire(CLI)
    except Exception as e:
        console.print(f"[red]Error:[/red] {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()

================
File: src/nyord_vpn/exceptions.py
================
"""Custom exceptions for the NordVPN client.

this_file: src/nyord_vpn/exceptions.py

This module defines custom exceptions used throughout the NordVPN client.
Each exception type corresponds to a specific category of errors that may
occur during VPN operations.
"""


class NyordVPNError(Exception):
    """Base exception for all NordVPN client errors."""


class VPNError(NyordVPNError):
    """Base exception for VPN-related errors."""


class CredentialsError(NyordVPNError):
    """Raised when there are issues with VPN credentials."""


class ConnectionError(NyordVPNError):
    """Raised when connection to VPN server fails."""


class DisconnectionError(NyordVPNError):
    """Raised when disconnection from VPN fails."""


class ServerNotFoundError(NyordVPNError):
    """Raised when a VPN server cannot be found."""


class VPNConfigError(VPNError):
    """Raised when there are issues with OpenVPN configuration."""


class VPNServerError(NyordVPNError):
    """Raised when there are issues with VPN server selection or availability."""


class VPNAuthenticationError(VPNError):
    """Raised when authentication fails."""


class VPNTimeoutError(NyordVPNError):
    """Raised when VPN operations timeout."""


class VPNProcessError(VPNError):
    """Raised when there are issues with the OpenVPN process."""


class VPNConnectionError(VPNError):
    """Raised when connection establishment fails."""


class VPNDisconnectionError(VPNError):
    """Raised when disconnection fails."""

================
File: tests/integration/__init__.py
================
"""Integration tests for nyord_vpn."""

================
File: tests/integration/test_config_loading.py
================
"""Integration tests for configuration loading."""

import pytest
from pathlib import Path
import json

from nyord_vpn.core.client import VPNClient
from nyord_vpn.core.config import VPNConfig
from tests.conftest import TEST_PASSWORD, TEST_USERNAME


@pytest.mark.integration
async def test_file_loading(temp_dir) -> None:
    """Test configuration loading from file."""
    # Create config file with all options
    config_file = temp_dir / "config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "default_country": "Sweden",
        "retry_attempts": 5,
        "use_legacy_fallback": False,
        "config_dir": "custom/config/dir",
        "api_timeout": 60,
    }
    config_file.write_text(json.dumps(config_data))

    # Test loading with VPNClient
    client = VPNClient.from_file(config_file)
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.default_country == "Sweden"
    assert client.config.retry_attempts == 5
    assert client.config.use_legacy_fallback is False
    assert client.config.config_dir == Path("custom/config/dir").resolve()
    assert client.config.api_timeout == 60

    # Test loading with VPNConfig
    config = VPNConfig.from_file(config_file)
    assert config.username == TEST_USERNAME
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert config.default_country == "Sweden"
    assert config.retry_attempts == 5
    assert config.use_legacy_fallback is False
    assert config.config_dir == Path("custom/config/dir").resolve()
    assert config.api_timeout == 60


@pytest.mark.integration
async def test_environment_loading_unprefixed(monkeypatch) -> None:
    """Test configuration loading from unprefixed environment variables."""
    # Set environment variables
    monkeypatch.setenv("NORD_USER", TEST_USERNAME)
    monkeypatch.setenv("NORD_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Norway")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "4")

    # Test loading with VPNClient
    client = VPNClient.from_env()
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.default_country == "Norway"
    assert client.config.retry_attempts == 4


@pytest.mark.integration
async def test_environment_loading_prefixed(monkeypatch) -> None:
    """Test configuration loading from prefixed environment variables."""
    # Set environment variables
    monkeypatch.setenv("NORDVPN_USERNAME", TEST_USERNAME)
    monkeypatch.setenv("NORDVPN_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Sweden")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "5")

    # Test loading with VPNClient
    client = VPNClient.from_env()
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.default_country == "Sweden"
    assert client.config.retry_attempts == 5


@pytest.mark.integration
async def test_environment_loading_precedence(monkeypatch) -> None:
    """Test precedence between prefixed and unprefixed environment variables."""
    # Set both prefixed and unprefixed variables
    monkeypatch.setenv("NORD_USER", "unprefixed_user")
    monkeypatch.setenv("NORD_PASSWORD", "unprefixed_pass")
    monkeypatch.setenv("NORDVPN_USERNAME", "prefixed_user")
    monkeypatch.setenv("NORDVPN_PASSWORD", "prefixed_pass")

    # Unprefixed should take precedence
    client = VPNClient.from_env()
    assert client.config.username == "unprefixed_user"
    assert client.config.password.get_secret_value() == "unprefixed_pass"


@pytest.mark.integration
async def test_default_values() -> None:
    """Test configuration default values."""
    # Test with minimal configuration
    config = VPNConfig(username="test", password="test")
    assert config.username == "test"
    assert config.password.get_secret_value() == "test"
    assert config.default_country == "United States"
    assert config.retry_attempts == 3
    assert config.use_legacy_fallback is True
    assert config.config_dir == Path.home() / ".cache" / "nyord-vpn"
    assert config.api_timeout == 30

    # Test with VPNClient
    client = VPNClient(username="test", password="test")
    assert client.config.username == "test"
    assert client.config.password.get_secret_value() == "test"
    assert client.config.default_country == "United States"
    assert client.config.retry_attempts == 3
    assert client.config.use_legacy_fallback is True
    assert client.config.config_dir == Path.home() / ".cache" / "nyord-vpn"
    assert client.config.api_timeout == 30


@pytest.mark.integration
async def test_config_file_precedence(temp_dir, monkeypatch) -> None:
    """Test configuration loading precedence between file and environment."""
    # Create config file
    config_file = temp_dir / "config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "default_country": "Sweden",
        "retry_attempts": 5,
    }
    config_file.write_text(json.dumps(config_data))

    # Set environment variables
    monkeypatch.setenv("NORD_USER", "env_user")
    monkeypatch.setenv("NORD_PASSWORD", "env_pass")
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Norway")
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "45")

    # Test with VPNClient - explicit args > file > env > defaults
    client = VPNClient.from_file(
        config_file,
        username="arg_user",
        password=TEST_PASSWORD.get_secret_value(),
    )
    assert client.config.username == "arg_user"  # From arg
    assert (
        client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    )  # From arg
    assert client.config.default_country == "Sweden"  # From file
    assert client.config.retry_attempts == 5  # From file
    assert client.config.api_timeout == 45  # From env
    assert client.config.use_legacy_fallback is True  # Default

    # Test with VPNConfig - file > env > defaults
    config = VPNConfig.from_file(config_file)
    assert config.username == TEST_USERNAME  # From file
    assert (
        config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    )  # From file
    assert config.default_country == "Sweden"  # From file
    assert config.retry_attempts == 5  # From file
    assert config.api_timeout == 45  # From env
    assert config.use_legacy_fallback is True  # Default


@pytest.mark.integration
async def test_config_validation(temp_dir) -> None:
    """Test configuration validation."""
    # Test invalid retry attempts
    config_file = temp_dir / "invalid_retry.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "retry_attempts": 0,
    }
    config_file.write_text(json.dumps(config_data))
    with pytest.raises(ValueError, match="ensure this value is greater than 0"):
        VPNConfig.from_file(config_file)

    # Test invalid timeout
    config_file = temp_dir / "invalid_timeout.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "api_timeout": -1,
    }
    config_file.write_text(json.dumps(config_data))
    with pytest.raises(ValueError, match="ensure this value is greater than 0"):
        VPNConfig.from_file(config_file)

    # Test invalid config directory
    config_file = temp_dir / "invalid_dir.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "config_dir": "/nonexistent/dir",
    }
    config_file.write_text(json.dumps(config_data))
    with pytest.raises(ValueError, match="Failed to setup config directory"):
        VPNConfig.from_file(config_file)

    # Test missing required fields
    config_file = temp_dir / "missing_fields.json"
    config_data = {
        "default_country": "Sweden",
        "retry_attempts": 5,
    }
    config_file.write_text(json.dumps(config_data))
    with pytest.raises(ValueError, match="Field required"):
        VPNConfig.from_file(config_file)


def test_load_from_file(tmp_path: Path) -> None:
    """Test loading configuration from file."""
    # Create config file
    config_path = tmp_path / "config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "api_timeout": 30,
        "retry_attempts": 5,
    }
    config_path.write_text(json.dumps(config_data))

    # Test client initialization from file
    client = VPNClient(config_file=config_path)
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.api_timeout == 30
    assert client.config.retry_attempts == 5

    # Test direct config loading
    config = VPNConfig.from_file(config_path)
    assert config.username == TEST_USERNAME
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert config.api_timeout == 30
    assert config.retry_attempts == 5


def test_load_from_env(monkeypatch) -> None:
    """Test loading configuration from environment variables."""
    # Set environment variables
    monkeypatch.setenv("NORDVPN_USERNAME", TEST_USERNAME)
    monkeypatch.setenv("NORDVPN_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "30")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "5")

    # Test client initialization from env
    client = VPNClient()  # Will load from env by default
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.api_timeout == 30
    assert client.config.retry_attempts == 5

    # Test direct config loading
    config = VPNConfig.from_env()
    assert config.username == TEST_USERNAME
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert config.api_timeout == 30
    assert config.retry_attempts == 5


def test_direct_initialization() -> None:
    """Test direct initialization with parameters."""
    # Test config initialization
    config = VPNConfig(
        username=TEST_USERNAME,
        password=TEST_PASSWORD.get_secret_value(),
    )
    assert config.username == TEST_USERNAME
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()

    # Test client initialization
    client = VPNClient(
        username=TEST_USERNAME,
        password=TEST_PASSWORD.get_secret_value(),
    )
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()


def test_invalid_config_file(tmp_path: Path) -> None:
    """Test handling of invalid configuration files."""
    # Test non-existent file
    with pytest.raises(FileNotFoundError):
        VPNConfig.from_file(tmp_path / "nonexistent.json")

    # Test invalid JSON
    invalid_path = tmp_path / "invalid.json"
    invalid_path.write_text("invalid json content")
    with pytest.raises(json.JSONDecodeError):
        VPNConfig.from_file(invalid_path)

    # Test missing required fields
    empty_path = tmp_path / "empty.json"
    empty_path.write_text("{}")
    with pytest.raises(ValueError):
        VPNConfig.from_file(empty_path)


def test_invalid_environment(monkeypatch) -> None:
    """Test handling of invalid environment variables."""
    # Test missing required variables
    with pytest.raises(ValueError):
        VPNConfig.from_env()

    # Test invalid values
    monkeypatch.setenv("NORDVPN_USERNAME", TEST_USERNAME)
    monkeypatch.setenv("NORDVPN_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "invalid")
    with pytest.raises(ValueError):
        VPNConfig.from_env()

================
File: tests/integration/test_connection.py
================
"""Integration tests for VPN connection."""

import asyncio
import pytest

from nyord_vpn.core.exceptions import VPNError, VPNConnectionError


@pytest.mark.integration
@pytest.mark.asyncio
async def test_connection_success(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
) -> None:
    """Test successful VPN connection."""
    # Test primary API
    async with mock_client as client:
        await client.connect()
        status = await client.status()
        assert status["connected"] is True
        assert status["country"] == "Test Country"
        assert status["ip"] == "1.2.3.4"
        assert status["server"] == "test.server.com"

    # Test fallback API
    mock_client.primary_api.connect.side_effect = VPNError("Primary API failed")
    async with mock_client as client:
        await client.connect()
        status = await client.status()
        assert status["connected"] is True
        assert status["country"] == "Test Country"
        assert status["ip"] == "1.2.3.4"
        assert status["server"] == "test.server.com"


@pytest.mark.integration
@pytest.mark.asyncio
async def test_connection_failure(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
) -> None:
    """Test VPN connection failure handling."""
    # Test primary API failure
    mock_client.primary_api.connect.side_effect = VPNError("Primary API failed")
    mock_client.fallback_api.connect.side_effect = VPNError("Fallback API failed")

    with pytest.raises(VPNConnectionError, match="Both primary and fallback failed"):
        async with mock_client as client:
            await client.connect()

    # Test network error
    mock_aiohttp_session.get.side_effect = asyncio.TimeoutError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()

    # Test subprocess error
    mock_subprocess.side_effect = Exception("Subprocess error")
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_country_selection(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
) -> None:
    """Test VPN country selection."""
    # Test valid country
    async with mock_client as client:
        await client.connect("Test Country")
        status = await client.status()
        assert status["country"] == "Test Country"

    # Test invalid country
    mock_client.primary_api.connect.side_effect = VPNError("Invalid country")
    mock_client.fallback_api.connect.side_effect = VPNError("Invalid country")
    with pytest.raises(VPNConnectionError, match="Invalid country"):
        async with mock_client as client:
            await client.connect("Invalid Country")

================
File: tests/integration/test_errors.py
================
"""Integration tests for error handling."""

import asyncio
import pytest
from unittest.mock import AsyncMock, MagicMock
import json
from pathlib import Path
import subprocess

from nyord_vpn.core.client import VPNClient
from nyord_vpn.core.exceptions import VPNError, VPNConnectionError, VPNConfigError
from tests.conftest import TEST_PASSWORD, TEST_USERNAME


@pytest.mark.integration
@pytest.mark.asyncio
async def test_network_errors(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
) -> None:
    """Test handling of network-related errors."""
    # Test connection timeout
    mock_aiohttp_session.get.side_effect = asyncio.TimeoutError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()

    # Test connection refused
    mock_aiohttp_session.get.side_effect = ConnectionRefusedError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()

    # Test DNS resolution error
    mock_aiohttp_session.get.side_effect = Exception("DNS resolution failed")
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()

    # Test SSL error
    mock_aiohttp_session.get.side_effect = Exception("SSL verification failed")
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_subprocess_errors(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
) -> None:
    """Test handling of subprocess-related errors."""
    # Test OpenVPN not found
    mock_subprocess.side_effect = FileNotFoundError("openvpn not found")
    with pytest.raises(VPNConfigError):
        async with mock_client as client:
            await client.connect()

    # Test OpenVPN error
    mock_subprocess.side_effect = subprocess.SubprocessError("OpenVPN error")
    with pytest.raises(VPNConnectionError):
        async with mock_client as client:
            await client.connect()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_configuration_errors(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    temp_dir,
) -> None:
    """Test handling of configuration-related errors."""
    # Test missing credentials
    with pytest.raises(VPNConfigError, match="Field required"):
        VPNClient()

    # Test invalid config file
    config_file = temp_dir / "invalid.toml"
    config_file.write_text("invalid = toml [ content")
    with pytest.raises(VPNConfigError, match="Failed to load configuration"):
        VPNClient(config_file=config_file)

    # Test non-existent config file
    with pytest.raises(VPNConfigError, match="Failed to load configuration"):
        VPNClient(config_file=temp_dir / "nonexistent.toml")

    # Test invalid config directory
    config_file = temp_dir / "config.toml"
    config_file.write_text(
        """
        username = "test_user"
        password = "test_pass"
        config_dir = "/nonexistent/dir"
        """,
    )
    with pytest.raises(VPNConfigError, match="Failed to setup config directory"):
        VPNClient(config_file=config_file)


@pytest.mark.integration
@pytest.mark.asyncio
async def test_api_errors(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
) -> None:
    """Test handling of API-related errors."""
    # Test API error response
    mock_aiohttp_session.get.return_value.__aenter__.return_value.json.return_value = {
        "error": "API error",
    }
    with pytest.raises(VPNConnectionError):
        async with mock_client as client:
            await client.connect()

    # Test invalid API response
    mock_aiohttp_session.get.return_value.__aenter__.return_value.json.side_effect = (
        json.JSONDecodeError("Invalid JSON", "{", 0)
    )
    with pytest.raises(VPNConnectionError):
        async with mock_client as client:
            await client.connect()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_error_recovery(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
) -> None:
    """Test error recovery behavior."""
    # Test recovery after network error
    mock_aiohttp_session.get.side_effect = [
        asyncio.TimeoutError(),  # First attempt fails
        MagicMock(  # Second attempt succeeds
            status=200,
            json=AsyncMock(
                return_value={
                    "ip": "1.2.3.4",
                    "country": "Test Country",
                    "hostname": "test.server.com",
                },
            ),
        ),
    ]

    async with mock_client as client:
        result = await client.connect()
        assert result is True

        # Verify status
        status = await client.status()
        assert status["connected"] is True

    # Test recovery after subprocess error
    mock_subprocess.side_effect = [
        Exception("First attempt failed"),  # First attempt fails
        MagicMock(  # Second attempt succeeds
            returncode=0,
            communicate=AsyncMock(return_value=(b"Success", b"")),
        ),
    ]

    async with mock_client as client:
        result = await client.connect()
        assert result is True

        # Verify status
        status = await client.status()
        assert status["connected"] is True


@pytest.mark.asyncio
async def test_invalid_credentials() -> None:
    """Test handling of invalid credentials."""
    client = VPNClient(username="invalid", password=TEST_PASSWORD.get_secret_value())
    with pytest.raises(VPNConnectionError):
        await client.connect()


@pytest.mark.asyncio
async def test_network_errors() -> None:
    """Test handling of network errors."""
    client = VPNClient(
        username=TEST_USERNAME,
        password=TEST_PASSWORD.get_secret_value(),
    )

    # Test connection with network error
    with pytest.raises(VPNConnectionError):
        await client.connect()

    # Test status check with network error
    with pytest.raises(VPNError):
        await client.status()

    # Test country listing with network error
    with pytest.raises(VPNError):
        await client.list_countries()


@pytest.mark.asyncio
async def test_timeout_handling(tmp_path: Path) -> None:
    """Test handling of timeouts."""
    # Create config with short timeout
    config_path = tmp_path / "timeout_config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "api_timeout": 1,
    }
    config_path.write_text(json.dumps(config_data))

    client = VPNClient(config_file=config_path)

    # Test connection timeout
    with pytest.raises(VPNConnectionError):
        await client.connect()

    # Test status check timeout
    with pytest.raises(VPNError):
        await client.status()


@pytest.mark.asyncio
async def test_retry_behavior(tmp_path: Path) -> None:
    """Test retry behavior on failures."""
    # Create config with retry settings
    config_path = tmp_path / "retry_config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "retry_attempts": 2,
    }
    config_path.write_text(json.dumps(config_data))

    client = VPNClient(config_file=config_path)

    # Test connection retries
    with pytest.raises(VPNConnectionError):
        await client.connect()

    # Test status check retries
    with pytest.raises(VPNError):
        await client.status()


@pytest.mark.asyncio
async def test_fallback_behavior() -> None:
    """Test fallback to legacy API."""
    client = VPNClient(
        username=TEST_USERNAME,
        password=TEST_PASSWORD.get_secret_value(),
        use_legacy_fallback=True,
    )

    # Test connection with fallback
    assert await client.connect() is True
    status = await client.status()
    assert status["connected"] is True

    # Cleanup
    await client.disconnect()


@pytest.mark.asyncio
async def test_invalid_country() -> None:
    """Test handling of invalid country names."""
    client = VPNClient(
        username=TEST_USERNAME,
        password=TEST_PASSWORD.get_secret_value(),
    )

    # Test connection with invalid country
    with pytest.raises(VPNConnectionError):
        await client.connect("Invalid Country")

    # Test connection with empty country
    with pytest.raises(VPNConnectionError):
        await client.connect("")


@pytest.mark.integration
@pytest.mark.asyncio
async def test_cleanup_after_error(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
) -> None:
    """Test cleanup after errors."""
    # Test cleanup after connection error
    mock_client.primary_api.connect.side_effect = VPNError("Connection failed")
    mock_client.fallback_api.connect.side_effect = VPNError("Connection failed")

    try:
        async with mock_client as client:
            await client.connect()
    except VPNConnectionError:
        pass

    # Verify cleanup
    status = mock_client.status()
    assert status["connected"] is False
    assert status["server"] == ""

================
File: tests/integration/test_validation_integration.py
================
"""Integration tests for validation."""

import os
import pytest

from nyord_vpn.core.exceptions import VPNError
from nyord_vpn.api.njord import NjordVPNClient
from nyord_vpn.api.legacy import LegacyVPNClient


@pytest.fixture(autouse=True)
def clear_env():
    """Clear environment variables before each test."""
    os.environ.pop("NORD_USER", None)
    os.environ.pop("NORD_PASSWORD", None)
    yield
    os.environ.pop("NORD_USER", None)
    os.environ.pop("NORD_PASSWORD", None)


def test_invalid_credentials_njord() -> None:
    """Test invalid credentials with Njord API."""
    with pytest.raises(VPNError, match="Missing credentials"):
        NjordVPNClient()


def test_invalid_credentials_legacy() -> None:
    """Test invalid credentials with Legacy API."""
    with pytest.raises(VPNError, match="Missing credentials"):
        LegacyVPNClient()


def test_invalid_country_njord() -> None:
    """Test invalid country with Njord API."""
    os.environ["NORD_USER"] = "test_user"
    os.environ["NORD_PASSWORD"] = "test_pass"
    with pytest.raises(VPNError):
        client = NjordVPNClient()
        client.connect("Invalid Country")


def test_invalid_country_legacy() -> None:
    """Test invalid country with Legacy API."""
    os.environ["NORD_USER"] = "test_user"
    os.environ["NORD_PASSWORD"] = "test_pass"
    with pytest.raises(VPNError):
        client = LegacyVPNClient()
        client.connect("Invalid Country")

================
File: tests/__init__.py
================
"""Test suite for nyord-vpn package."""

================
File: tests/conftest.py
================
"""Test fixtures and configuration."""

from unittest.mock import patch
import json

import pytest

from nyord_vpn.core.client import VPNClient


@pytest.fixture
def mock_env_credentials(monkeypatch) -> None:
    """Mock environment variables for testing."""
    monkeypatch.setenv("NORD_USER", "test_user")
    monkeypatch.setenv("NORD_PASSWORD", "test_pass")


@pytest.fixture
def mock_openvpn():
    """Mock OpenVPN command."""
    with patch("subprocess.run") as mock_run:
        mock_run.return_value.stdout = b"OpenVPN 2.5.0\n"
        yield mock_run


@pytest.fixture
def mock_requests():
    """Mock requests for API calls."""
    with patch("requests.get") as mock_get:
        # Mock server recommendations
        mock_get.return_value.json.return_value = [
            {"hostname": "test.server.com", "load": 10, "status": "online"},
        ]
        mock_get.return_value.status_code = 200
        yield mock_get


@pytest.fixture
def mock_process():
    """Mock subprocess for OpenVPN."""
    with patch("subprocess.Popen") as mock_popen:
        mock_popen.return_value.pid = 12345
        mock_popen.return_value.returncode = 0
        yield mock_popen


@pytest.fixture
def mock_client(mock_env_credentials, mock_openvpn, mock_requests, mock_process):
    """Create a mock VPN client."""
    with patch("nyord_vpn.api.legacy.LegacyVPNClient") as mock_legacy:
        # Setup mock APIs
        mock_legacy.return_value.connect.return_value = True
        mock_legacy.return_value.disconnect.return_value = True
        mock_legacy.return_value.status.return_value = {
            "connected": True,
            "country": "Test Country",
            "ip": "1.2.3.4",
            "server": "test.server.com",
        }
        mock_legacy.return_value.list_countries.return_value = [
            {"name": "Country 1", "code": "1"},
            {"name": "Country 2", "code": "2"},
        ]

        # Create client
        client = VPNClient()
        yield client


@pytest.fixture
def temp_config_file(tmp_path):
    """Create a temporary config file."""
    config = {
        "username": "test_user",
        "password": "test_pass",
        "default_country": "us",
        "use_legacy_fallback": True,
    }

    config_file = tmp_path / "config.json"
    config_file.write_text(json.dumps(config))
    return config_file


@pytest.fixture
def mock_ip_info():
    """Mock IP info response."""
    with patch("requests.get") as mock_get:
        mock_get.return_value.json.return_value = {
            "ip": "1.2.3.4",
            "country": "US",
            "org": "NordVPN",
        }
        mock_get.return_value.status_code = 200
        yield mock_get

================
File: tests/test_client.py
================
"""Tests for VPN client."""

import pytest

from nyord_vpn.core.exceptions import VPNError


def test_client_connect(mock_client) -> None:
    """Test VPN client connect."""
    # Test successful connection
    result = mock_client.connect("Test Country")
    assert result is True

    # Test connection status
    status = mock_client.status()
    assert status["connected"] is True
    assert status["country"] == "Test Country"
    assert status["ip"] == "1.2.3.4"
    assert status["server"] == "test.server.com"


def test_client_disconnect(mock_client) -> None:
    """Test VPN client disconnect."""
    # Connect first
    mock_client.connect("Test Country")

    # Test disconnection
    result = mock_client.disconnect()
    assert result is True

    # Test status after disconnect
    status = mock_client.status()
    assert status["connected"] is False


def test_client_list_countries(mock_client) -> None:
    """Test VPN client country listing."""
    countries = mock_client.list_countries()
    assert isinstance(countries, list)
    assert len(countries) > 0
    assert all(isinstance(c, dict) for c in countries)
    assert all("name" in c and "code" in c for c in countries)


def test_client_error_handling(mock_client, mocker) -> None:
    """Test VPN client error handling."""
    # Mock API to raise error
    mocker.patch.object(
        mock_client._connect,
        "__call__",
        side_effect=VPNError("Test error"),
    )

    # Test error handling
    with pytest.raises(VPNError, match="Test error"):
        mock_client.connect("Test Country")


@pytest.mark.asyncio
async def test_client_context_manager(mock_client) -> None:
    """Test VPN client context manager."""
    async with mock_client as client:
        # Test connection inside context
        result = await client.connect("Test Country")
        assert result is True

        # Test status
        status = await client.status()
        assert status["connected"] is True

    # Test auto-disconnect after context
    status = await mock_client.status()
    assert status["connected"] is False

================
File: tests/test_legacy_api.py
================
"""Tests for LegacyVPNClient implementation."""

import pytest
import requests
import os
import subprocess

from nyord_vpn.core.exceptions import VPNError
from nyord_vpn.api.legacy import LegacyVPNClient


def test_init(mock_env_credentials, mock_openvpn) -> None:
    """Test LegacyVPNClient initialization."""
    api = LegacyVPNClient()
    assert api.username == os.getenv("NORD_USER")
    assert isinstance(api.password, str)
    assert api.password == os.getenv("NORD_PASSWORD")


def test_connect_success(
    mock_env_credentials,
    mock_openvpn,
    mock_requests,
    mock_process,
    mock_ip_info,
) -> None:
    """Test successful connection."""
    api = LegacyVPNClient()
    assert api.connect() is True


def test_connect_failure(
    mock_env_credentials,
    mock_openvpn,
    mock_requests,
    mock_process,
) -> None:
    """Test connection failure."""
    mock_process.side_effect = requests.RequestException("Failed to connect")
    api = LegacyVPNClient()
    with pytest.raises(VPNError, match="Failed to connect"):
        api.connect()


def test_disconnect_success(mock_env_credentials, mock_openvpn, mock_process) -> None:
    """Test successful disconnection."""
    api = LegacyVPNClient()
    assert api.disconnect() is True


def test_status_connected(mock_env_credentials, mock_openvpn, mock_ip_info) -> None:
    """Test status when connected."""
    api = LegacyVPNClient()
    status = api.status()
    assert status["connected"] is True
    assert status["country"] == "US"
    assert status["ip"] == "1.2.3.4"
    assert status["server"] == ""


def test_list_countries(mock_env_credentials, mock_openvpn, mock_requests) -> None:
    """Test listing available countries."""
    mock_requests.return_value.json.return_value = [
        {"name": "United States", "id": 228},
        {"name": "United Kingdom", "id": 227},
    ]
    api = LegacyVPNClient()
    countries = api.list_countries()
    assert len(countries) == 2
    assert all(isinstance(c, dict) for c in countries)
    assert all("name" in c and "code" in c for c in countries)
    assert countries[0]["name"] == "United Kingdom"
    assert countries[1]["name"] == "United States"


def test_openvpn_not_found(mock_env_credentials) -> None:
    """Test OpenVPN not found error."""
    with pytest.raises(VPNError, match="OpenVPN not found"):
        LegacyVPNClient()


def test_server_not_found(mock_env_credentials, mock_openvpn, mock_requests) -> None:
    """Test server not found error."""
    mock_requests.return_value.json.return_value = []
    api = LegacyVPNClient()
    with pytest.raises(VPNError, match="No servers found"):
        api.connect("invalid_country")


def test_config_download_error(
    mock_env_credentials, mock_openvpn, mock_requests
) -> None:
    """Test config download error."""
    mock_requests.side_effect = requests.RequestException("Failed to download")
    api = LegacyVPNClient()
    with pytest.raises(VPNError, match="Failed to download"):
        api.connect()


def test_process_error(
    mock_env_credentials, mock_openvpn, mock_requests, mock_process
) -> None:
    """Test process error handling."""
    mock_process.side_effect = subprocess.SubprocessError("Process failed")
    api = LegacyVPNClient()
    with pytest.raises(VPNError, match="Failed to connect"):
        api.connect()


def test_api_credentials() -> None:
    """Test API credentials are set correctly."""
    api = LegacyVPNClient()
    assert api.username == os.getenv("NORD_USER")
    assert api.password == os.getenv("NORD_PASSWORD")

================
File: tests/test_package.py
================
"""Test suite for nyord_vpn."""


def test_version() -> None:
    """Verify package exposes version."""
    import nyord_vpn

    assert nyord_vpn.__version__

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.toml
================
# Package configuration
[package]
include_cli = true        # Include CLI boilerplate
include_logging = true    # Include logging setup
use_pydantic = true      # Use Pydantic for data validation
use_rich = true          # Use Rich for terminal output

[features]
mkdocs = false           # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows

================
File: pyproject.toml
================
# this_file: pyproject.toml
[build-system]
requires = ["setuptools>=45", "setuptools-scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "nyord-vpn"
version = "0.1.0"
description = "NordVPN client with API fallback support"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT"}
keywords = ["vpn", "nordvpn", "security"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "njord>=0.0.1",
    "tenacity>=8.0.0",
    "backoff>=2.0.0",
    "rich>=13.4.2",
    "fire>=0.7.0",
    "pydantic>=2.10.6",
    "pydantic-settings>=2.8.0",
    "requests>=2.31.0",
    "keyring>=24.2.0",
    "pycountry>=24.6.1",
    "psutil>=5.9.5",
    "python-dotenv>=1.0.0",
    "aiohttp>=3.11.0",
    "cryptography>=42.0.0",
    "black>=23.7.0",
    "bleach>=6.0.0",
    "build>=0.10.0",
    "certifi>=2023.5.7",
    "charset-normalizer>=3.2.0",
    "click>=8.1.5",
    "docutils>=0.20.1",
    "idna>=3.4",
    "importlib-metadata>=6.8.0",
    "jaraco-classes>=3.3.0",
    "markdown-it-py>=3.0.0",
    "mdurl>=0.1.2",
    "more-itertools>=9.1.0",
    "mypy-extensions>=1.0.0",
    "packaging>=23.1",
    "pathspec>=0.11.1",
    "pkginfo>=1.9.6",
    "platformdirs>=3.9.1",
    "pygments>=2.15.1",
    "pyproject-hooks>=1.0.0",
    "readme-renderer>=40.0",
    "requests-toolbelt>=1.0.0",
    "rfc3986>=2.0.0",
    "six>=1.16.0",
    "tomli>=2.0.1",
    "twine>=4.0.2",
    "typing-extensions>=4.7.1",
    "urllib3>=2.0.3",
    "webencodings>=0.5.1",
    "zipp>=3.16.2",
    "loguru>=0.7.3",
]

[project.optional-dependencies]
dev = [
    "pre-commit>=3.6.0",
    "ruff>=0.9.7",
    "mypy>=1.0.0",
    "pyupgrade>=3.19.0",
    "autoflake>=2.0.0",
    "isort>=5.10.1",
]

test = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.25.0",
    "pytest-mock>=3.12.0",
    "pytest-timeout>=2.3.0",
    "pytest-xdist>=3.5.0",
]

[project.scripts]
nyord-vpn = "nyord_vpn.__main__:main"

[tool.setuptools]
package-dir = {"" = "src"}
packages = ["nyord_vpn"]
package-data = {"nyord_vpn" = ["data/*.json"]}

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/nyord-vpn#readme"
Issues = "https://github.com/twardoch/nyord-vpn/issues"
Source = "https://github.com/twardoch/nyord-vpn"

[tool.coverage.paths]
nyord_vpn = ["src/nyord_vpn", "*/nyord-vpn/src/nyord_vpn"]
tests = ["tests", "*/nyord-vpn/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
]

[tool.coverage.run]
source_pkgs = ["nyord_vpn", "tests"]
branch = true
parallel = true
omit = [
    "src/nyord_vpn/__about__.py",
]

[tool.hatch.build.hooks.vcs]
version-file = "src/nyord_vpn/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/nyord_vpn"]

[tool.hatch.envs.default]
dependencies = [
]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests {args:tests}"
type-check = "mypy src/nyord_vpn tests"
lint = ["ruff check src/nyord_vpn tests", "ruff format --respect-gitignore src/nyord_vpn tests"]
fix = ["ruff check  --fix --unsafe-fixes src/nyord_vpn tests", "ruff format --respect-gitignore src/nyord_vpn tests"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/nyord_vpn tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.25.0",
    "pytest-mock>=3.12.0",
    "pytest-timeout>=2.3.0",
    "pytest-xdist>=3.5.0",
]

[tool.hatch.envs.test.scripts]
test = "python -m pytest {args:tests}"
test-cov = "python -m pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests {args:tests}"
bench = "python -m pytest -v tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[tool.ruff]
target-version = "py310"
line-length = 88

[tool.ruff.lint]
select = [
    "A",
    "ANN",
    "ARG",
    "ASYNC",
    "B",
    "C",
    "C4",
    "C90",
    "COM",
    "D",
    "DOC",
    "DTZ",
    "E",
    "ERA",
    "EXE",
    "F",
    "FA",
    "FBT",
    "FIX",
    "FLY",
    "FURB",
    "I",
    "ICN",
    "INP",
    "ISC",
    "N",
    "NPY",
    "PD",
    "PERF",
    "PIE",
    "PL",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "PT",
    "PTH",
    "PYI",
    "Q",
    "RET",
    "RSE",
    "RUF",
    "S",
    "SIM",
    "SLF",
    "T",
    "TC",
    "TD",
    "TID",
    "TRY",
    "UP",
    "W",
    "YTT",
]
ignore = ["ARG001", "COM812", "D203", "D213", "E501", "I001", "RUF001", "PLR2004", "EXE003", "ISC001"]

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase --timeout=30 -n auto"
asyncio_mode = "strict"
asyncio_default_fixture_loop_scope = "function"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning",
    "ignore::pytest.PytestDeprecationWarning",
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "async_test: mark a test as an async test",
    "config: mark a test as a configuration test",
    "connection: mark a test as a connection test",
    "security: mark a test as a security test",
]
testpaths = ["tests"]
timeout = 30

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]

================
File: README.md
================
# nyord-vpn

nyord-vpn is a simple NordVPN client for macOS users. It provides an easy way to manage VPN connections. 

nyord-vpn is primarily designed for macOS, as it relies on OpenVPN, which is easily installable via Homebrew. However, with some modifications, it might be possible to use it on other platforms like Linux or Windows. Contributions to support additional platforms are welcome.

## Key Features

- **Simple and Reliable Connection Management:** Connect and disconnect from VPN with minimal hassle.
- **Support for Legacy OpenVPN and njord APIs:** Choose between different API versions for flexibility.
- **Country Selection:** Connect to servers in specific countries easily.
- **Status Monitoring:** Check the current status of your VPN connection.
- **Clear Error Messages:** Resolve issues quickly with informative error messages.
- **Minimal Dependencies:** Lightweight and easy to set up.

## Installation

To use nyord-vpn, you need to install some system requirements and the package itself.

### System Requirements

- macOS operating system
- OpenVPN installed

### Installing OpenVPN

Install OpenVPN using Homebrew:

```bash
brew install openvpn
```

### Installing nyord-vpn

Install the package using pip:

```bash
pip install nyord-vpn
```


## Configuration

Before using nyord-vpn, set your NordVPN credentials as environment variables:

```bash
export NORD_USER="your-username"
export NORD_PASSWORD="your-password"
```

Replace `"your-username"` and `"your-password"` with your actual NordVPN credentials.

## Usage

nyord-vpn can be used via the command line interface (CLI) or programmatically through its Python API.

### API Options

### CLI Commands

Here are the available CLI commands:

- **`nyord-vpn connect`**: Connects to a NordVPN server. Defaults to a server in the United States.
- **`nyord-vpn connect --country <country>`**: Connects to a server in the specified country. Replace `<country>` with the country name or code (e.g., `netherlands`).
- **`nyord-vpn --api njord connect`**: Uses the njord API to connect to the VPN.
- **`nyord-vpn --verbose connect`**: Connects to the VPN with verbose logging enabled for debugging.
- **`nyord-vpn status`**: Displays the current status of the VPN connection, including connection status, server, and IP address.
- **`nyord-vpn list-countries`**: Lists all available countries with NordVPN servers.
- **`nyord-vpn disconnect`**: Disconnects from the VPN.

**Note:** Some commands, such as connecting and disconnecting, may require sudo privileges. You might be prompted to enter your password.

### Python API

You can use nyord-vpn programmatically in Python:

```python
from nyord_vpn.core.factory import create_client

# Create a client (choose "legacy" or "njord")
client = create_client("legacy")

# Connect to VPN in a specific country
client.connect("netherlands")

# Check connection status
status = client.status()
print(f"Connected to {status['server']} ({status['ip']})")

# Disconnect from VPN
client.disconnect()
```

Ensure you have the necessary permissions to run OpenVPN when using the Python API.

## Development

To contribute to nyord-vpn or modify the code:

1. **Install dependencies:**

   ```bash
   pip install -r requirements.txt
   ```

2. **Install optional njord support:**

   ```bash
   pip install njord
   ```

3. **Run with debug logging:**

   ```bash
   NORD_USER="username" NORD_PASSWORD="password" nyord-vpn --verbose connect
   ```

For a full development setup, clone the repository, create a virtual environment, and install the package in editable mode:

```bash
git clone https://github.com/yourusername/nyord-vpn.git
cd nyord-vpn
python -m venv venv
source venv/bin/activate
pip install -e .
```

Replace `yourusername` with the actual repository owner.

## Error Handling and Troubleshooting

nyord-vpn provides clear error messages to help resolve issues. Common errors include:

- **`VPNCredentialsError`**: Missing or invalid credentials. Ensure `NORD_USER` and `NORD_PASSWORD` are set correctly.
- **`VPNConnectionError`**: Failed to connect or disconnect. Check your internet connection and try again.
- **`VPNConfigError`**: Configuration issues, such as missing OpenVPN. Install OpenVPN if not already installed.
- **`VPNServerError`**: Failed to get server information. Try again later or check your network connection.

### Troubleshooting Tips

- **"OpenVPN not found" error:** Install OpenVPN using `brew install openvpn`.
- **"Authentication failed" error:** Verify your NordVPN credentials in the environment variables.
- **"Failed to connect" error:** Check your internet connection or try a different country/server.
- **"No servers available" error:** Wait a few minutes and try again; this may be a temporary API issue.

### Security Considerations

- **Keep Credentials Secure:** Do not hardcode credentials; use environment variables or secure storage.
- **Update Regularly:** Keep nyord-vpn and dependencies up to date for security patches.
- **Monitor Connections:** Regularly check your connection status.
- **Use Strong Passwords:** Ensure your NordVPN account has a strong, unique password.

## Contributing

We welcome contributions to nyord-vpn! To contribute:

1. Fork the repository.
2. Create a feature branch for your changes.
3. Make your changes and commit them.
4. Submit a pull request with a clear description of your changes.

For issues or questions, open an issue on the [GitHub repository](https://github.com/yourusername/nyord-vpn).

## License

nyord-vpn is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

================
File: TODO.md
================
# TODO

Do it! Remember, keep it simple, effective, eyes on the goal!

### 0.1. Enhanced Server Selection

- [ ] Switch to v2/servers API for better efficiency:
  ```python
  def get_servers_cache() -> dict:
      """Fetch and cache full server list from v2/servers:
      1. Single API call to get all servers
      2. Cache for hour
      3. Local filtering by country/load/features
      """
  ```
- [ ] Implement fast server selection:
  ```python
  def select_fastest_server(country_code: str, servers: dict) -> str:
      """Select fastest server:
      1. Filter cached servers by country
      2. Take top 5 by load
      3. Parallel ping test
      4. Return fastest responding server
      """
  ```

### 0.2. Simplified Setup
- [ ] Create one-command initialization:
  ```bash
  nyord init  # Sets up everything needed
  ```
  - Validate OpenVPN installation
  - Create config directories
  - Set up credential storage
  - Test API connectivity
  - Generate initial config

### 0.3. API Usage Optimization
- [ ] Switch to https://api.nordvpn.com/v2/servers for server data fetching (the local "cached" file should be made compatible with the v2 format)
- [ ] Retire both https://api.nordvpn.com/v1/servers/countries and https://api.nordvpn.com/v1/servers/recommendations  the v2 API is better because we don't want a list of all countries in the world, just the ones that have servers :) 
  - Single API call instead of multiple v1 endpoints
  - Local filtering instead of multiple API requests
  - Simpler error handling (only one endpoint)

Keep it focused on these core improvements that directly enhance user experience.

### 0.4. Retry, switch gears

- [ ] Make sure that if the country is not specified, we choose the country randomly
- [ ] Implement a bool parameter "random" that chooses a random server (rather than "the fasterst") from the country 
- [ ] When we're connecting, we should retry connection once and if that's not successful, we should try another random server from the same country. See below for some ideas. 



### 0.5. ANALYSIS FOR "RETRY, SWITCH GEARS"

Outofthebox, both reengage and tenacity are designed to reinvoke your function with the same arguments on each attempt. They dont automatically step through a list of alternative parameter values. 

That said, with tenacity you can customize the retry behavior by using callback hooks (such as the after hook) to modify the functions keyword arguments between attempts. For example, you can write a small helper like this:

```python
from tenacity import retry, stop_after_attempt, RetryCallState

def update_B(new_value):
    def after_callback(retry_state: RetryCallState):
        # Update the value for the parameter "B" for the next attempt
        retry_state.kwargs['B'] = new_value
    return after_callback

# First, try with B=5 (the default).
# After two failures, update B to 7.
@retry(stop=stop_after_attempt(2), after=update_B(7))
def func(A, B=5):
    print(f"Attempt with B={B}")
    # Example failure condition
    if B < 11:
        raise Exception("Not high enough!")
    return f"Success with B={B}"

try:
    result = func("some_value")
except Exception as e:
    # You might even chain another retry that sets B to 11 after another round
    print("Initial retry block failed:", e)
    # You can redecorate or call a wrapper that uses the next parameter value.
    # For example, you could write a loop that tries B from a list [5,7,11]
    for new_B in [7, 11]:
        try:
            result = func("some_value", B=new_B)
            break
        except Exception:
            continue
    else:
        result = None

print("Result:", result)
```

In this example, the tenacity decorators after hook is used to modify the value of B for the next attempt. (A similar idea was discussed on Stack Overflow, where an answer demonstrated using an aftercallback to change a parameter dynamically.) citeturn0search0

If you need a more complex sequence (like try with B=5, if that fails twice then use B=7, then 11), you might either chain multiple decorators or, more simply, write a custom wrapper that iterates over your list of values and calls your function accordingly.

In summary, while neither library provides a oneline decorator that automatically steps through alternative argument values, tenacitys flexible callback hooks let you implement that behavior with a bit of extra code.

Both the **Re-Engage** and **Tenacity** libraries provide decorators for retrying functions until success or failure, but they do not natively support the specific use case of trying different arguments upon failure. However, you can implement this functionality using a combination of decorators and custom logic.

## 1. Overview of Libraries

### 1.1. Re-Engage
- **Re-Engage** is a fork of the original backoff library, designed for retrying function calls with decorators like `@backoff.on_exception` and `@backoff.on_predicate`. These decorators allow you to specify conditions under which to retry a function based on exceptions or return values[1].

### 1.2. Tenacity
- **Tenacity** is a general-purpose retrying library that simplifies adding retry behavior to functions. It allows for extensive customization through decorators like `@retry`, which can be configured with various parameters such as maximum attempts, delay between retries, and conditions for retrying[2].

## 2. Implementing Dynamic Argument Retrying

To achieve the desired behavior of trying different arguments after failures, you can create a custom decorator that wraps your function and manages the argument variations. Heres an example implementation:

```python
from tenacity import retry, stop_after_attempt

def dynamic_retry(args_list):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for args in args_list:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"Failed with args {args}: {e}")
            raise Exception("All attempts failed.")
        return wrapper
    return decorator

@dynamic_retry([(5,), (7,), (11,)])  # List of argument tuples
def my_function(b):
    # Simulate a function that may fail
    if b != 11:  # Let's say it fails unless b is 11
        raise ValueError("Failed!")
    return "Success!"

# Usage
result = my_function(5)  # This will try 5, then 7, then 11.
print(result)  # Outputs: Success!
```

### 2.1. Explanation:
- The `dynamic_retry` decorator takes a list of argument tuples.
- The `wrapper` function iterates over these arguments, attempting to call the target function.
- If an exception occurs, it catches the error, logs it, and moves on to the next set of arguments.
- If all attempts fail, it raises an exception.

## 3. Conclusion

While neither Re-Engage nor Tenacity directly supports dynamically changing function arguments upon failure out-of-the-box, you can implement this functionality using custom decorators. This approach allows you to maintain flexibility in your retry logic while leveraging the robust features provided by existing libraries.

Based on the search results and your specific question about retrying with different arguments, I'll provide a comprehensive answer about implementing such functionality.

Let me break this down step by step:

### 3.1. Current State of Retry Libraries

The common retry libraries like `tenacity` and `re-engage` focus primarily on retrying with the same arguments. While they're powerful for basic retry scenarios, they don't directly support changing arguments between retries [0].

### 3.2. Custom Solution Implementation

Here's a custom decorator implementation that allows retrying with different arguments:

```python
from functools import wraps
from typing import List, Any, Callable
import time

def retry_with_different_args(arg_sequences: List[Any], delay: int = 1):
    """
    Retry decorator that attempts the function with different argument values.
    
    Args:
        arg_sequences: List of values to try for the decorated function's first argument
        delay: Delay between retries in seconds
    """
    def decorator(func: Callable):
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            
            # Replace the first argument with each value in the sequence
            for arg_value in arg_sequences:
                try:
                    new_args = (arg_value,) + args[1:]
                    return func(*new_args, **kwargs)
                except Exception as e:
                    last_exception = e
                    print(f"Attempt with value {arg_value} failed: {str(e)}")
                    time.sleep(delay)
            
            # If we get here, all attempts failed
            raise last_exception or Exception("All retry attempts failed")
            
        return wrapper
    return decorator
```

Example usage:

```python
# Example using the decorator
@retry_with_different_args([5, 7, 11])
def divide_number(divisor: int, number: int = 100):
    if divisor == 7:
        raise ValueError("Don't like 7")
    return number / divisor

# This will try with divisor=5, then 7, then 11
try:
    result = divide_number(5, number=100)
    print(f"Success: {result}")
except Exception as e:
    print(f"Final failure: {e}")
```

### 3.3. Key Points to Consider

1. **Flexibility**: This implementation allows you to specify a sequence of values to try for a specific argument [0].

2. **Error Handling**: Each attempt is wrapped in a try-except block, allowing you to catch and handle specific exceptions [0].

3. **Delay Control**: You can specify delays between attempts to prevent overwhelming systems [0].

### 3.4. Best Practices

1. **Specific Exceptions**: Always catch specific exceptions rather than using a broad Exception catch.

2. **Logging**: Include proper logging to track retry attempts and failures.

3. **Timeout Consideration**: Consider implementing an overall timeout mechanism.

4. **State Management**: Be careful with stateful operations when retrying with different arguments.

### 3.5. Alternative Approach Using Tenacity

While tenacity doesn't directly support changing arguments, you can achieve similar functionality by combining it with a custom retry strategy:

```python
from tenacity import retry, stop_after_attempt
from functools import partial

def retry_sequence(func, arg_sequences):
    for arg in arg_sequences:
        try:
            return func(arg)
        except Exception:
            continue
    raise Exception("All attempts failed")

# Usage example
@retry(stop=stop_after_attempt(1))
def wrapped_function(x):
    return retry_sequence(some_function, [5, 7, 11])
```

This solution provides a way to work with existing retry libraries while adding the functionality to try different arguments, though it's not as elegant as the custom decorator approach.



================================================================
End of Codebase
================================================================
