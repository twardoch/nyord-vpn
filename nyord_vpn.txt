This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/**/*.md, .venv/**, _private/**, CLEANUP.txt, **/*.json, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    filetree.mdc
    nyord-vpn.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  nyord_vpn/
    api/
      api.py
      v1_countries.py
      v1_groups.py
      v1_recommendations.py
      v1_technologies.py
      v2_servers.py
    core/
      __init__.py
      api.py
      base.py
      client.py
    data/
      .specstory/
        history/
          .what-is-this.md
    network/
      __init__.py
      country.py
      server.py
      vpn_commands.py
      vpn.py
    scripts/
      __init__.py
      update_countries.py
    storage/
      models.py
      state.py
    utils/
      __init__.py
      connection.py
      templates.py
      utils.py
    __init__.py
    __main__.py
    exceptions.py
tests/
  integration/
    __init__.py
    test_config_loading.py
    test_connection.py
    test_errors.py
    test_validation_integration.py
  __init__.py
  conftest.py
  test_client.py
  test_legacy_api.py
  test_package.py
  test_server_manager.py
.gitignore
.pre-commit-config.yaml
cleanup.py
LICENSE
package.toml
pyproject.toml
README.md
TODO.md

================================================================
Files
================================================================

================
File: .cursor/rules/filetree.mdc
================
---
description: File tree of the project
globs: 
---
[ 832]  .
├── [  96]  .cursor
│   └── [ 128]  rules
│       ├── [9.0K]  filetree.mdc
│       └── [4.0K]  nyord-vpn.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 532]  .pre-commit-config.yaml
├── [ 128]  .specstory
│   └── [1.9K]  history
│       ├── [2.0K]  .what-is-this.md
│       ├── [452K]  2025-02-22_19-00-comparison-of-njord-and-nyord-vpn-implementations.md
│       ├── [ 913]  2025-02-22_19-00-fixing-logging-format-error-in-python.md
│       ├── [167K]  2025-02-22_20-24-managing-todos-and-development-tasks.md
│       ├── [8.3K]  2025-02-22_21-08-final-decision-and-todo-update.md
│       ├── [203K]  2025-02-22_21-21-git-management-and-todo-updates.md
│       ├── [ 39K]  2025-02-22_21-59-git-management-and-todo-updates.md
│       ├── [363K]  2025-02-22_22-27-git-management-and-todo-updates.md
│       ├── [ 52K]  2025-02-22_23-26-nordvpn-client-implementation-discussion.md
│       ├── [137K]  2025-02-22_23-35-task-management-and-project-update.md
│       ├── [ 58K]  2025-02-22_23-55-updating-todo-md-and-project-management.md
│       ├── [ 61K]  2025-02-23_00-02-task-management-and-collaboration-strategy.md
│       ├── [165K]  2025-02-23_00-09-updating-todo-md-and-task-prioritization.md
│       ├── [217K]  2025-02-23_01-01-codebase-analysis-and-optimization-discussion.md
│       ├── [101K]  2025-02-23_01-43-importerror-in-nyord-vpn-module.md
│       ├── [ 53K]  2025-02-23_01-55-understanding-vpn-cli-commands-and-issues.md
│       ├── [216K]  2025-02-23_02-15-python-virtual-environment-setup-and-testing.md
│       ├── [ 26K]  2025-02-23_02-34-vpn-connection-troubleshooting-with-python.md
│       ├── [189K]  2025-02-23_04-09-executing-python-vpn-connection-command.md
│       ├── [156K]  2025-02-23_04-56-vpn-connection-troubleshooting.md
│       ├── [ 44K]  2025-02-23_05-42-vpn-connection-status-troubleshooting.md
│       ├── [2.9K]  2025-02-23_05-54-comparing-vpn-management-tools-openpyn-vs-nyord.md
│       ├── [ 16K]  2025-02-23_06-04-untitled.md
│       ├── [ 16K]  2025-02-23_06-09-improving-nyord-vpn-server-selection-and-setup.md
│       ├── [ 76K]  2025-02-23_06-46-implementing-todo-items-in-project.md
│       ├── [156K]  2025-02-23_06-52-code-optimization-and-refactoring-discussion.md
│       ├── [227K]  2025-02-23_07-19-vpn-connection-troubleshooting-log.md
│       ├── [673K]  2025-02-23_07-30-vpn-connection-issues-and-server-selection-errors.md
│       ├── [432K]  2025-02-23_07-55-vpn-client-initialization-and-connection-logs.md
│       ├── [359K]  2025-02-23_08-03-nordvpn-client-initialization-logs.md
│       ├── [410K]  2025-02-23_08-18-vpn-client-frustrations-and-logs.md
│       ├── [6.0K]  2025-02-23_23-48-hierarchical-representation-of-codebase-structure.md
│       ├── [7.9K]  2025-02-23_23-48-nordvpn-client-codebase-organization.md
│       ├── [ 93K]  2025-02-24_00-09-code-analysis-and-docstring-enhancement.md
│       ├── [2.8K]  2025-02-24_01-16-vpn-configuration-file-retrieval-and-security.md
│       ├── [ 70K]  2025-02-24_01-29-improving-nyord-vpn-configuration-method.md
│       ├── [ 42K]  2025-02-24_01-47-openvpn-configuration-and-debugging.md
│       ├── [ 95K]  2025-02-24_02-10-vpn-connection-error-troubleshooting.md
│       ├── [ 58K]  2025-02-24_02-47-vpn-connection-troubleshooting-openvpn-auth-failure.md
│       ├── [ 12K]  2025-02-24_03-15-questioning-openvpn-command-location-in-code.md
│       ├── [ 20K]  2025-02-24_03-31-untitled.md
│       ├── [184K]  2025-02-24_03-36-zip-extraction-to-cache-directory.md
│       ├── [224K]  2025-02-24_04-13-vpn-connection-management-and-ip-tracking-issues.md
│       ├── [1.8M]  2025-02-24_04-43-vpn-connection-debugging-and-ip-verification.md
│       ├── [168K]  2025-02-24_05-02-optimizing-vpn-config-extraction-process.md
│       ├── [579K]  2025-02-24_05-33-vpn-connection-troubleshooting-and-debugging.md
│       ├── [287K]  2025-02-24_06-17-vpn-connection-management-with-nyord-vpn.md
│       ├── [210K]  2025-02-24_06-58-vpn-connection-troubleshooting.md
│       ├── [105K]  2025-02-24_07-15-vpn-connection-troubleshooting-and-improvements.md
│       ├── [6.2K]  2025-02-24_07-20-fixing-import-error-in-vpn-module.md
│       ├── [1006K]  2025-02-24_07-36-fixing-importerror-in-nyord-vpn-code.md
│       ├── [618K]  2025-02-24_07-57-vpn-server-connection-debugging.md
│       ├── [403K]  2025-02-24_08-01-vpn-server-selection-errors-and-debugging.md
│       ├── [245K]  2025-02-24_08-10-vpn-server-availability-issues.md
│       ├── [244K]  2025-02-24_17-19-vpn-country-resolution-issue.md
│       ├── [164K]  2025-02-24_17-43-vpn-connection-issue-no-servers-in-germany.md
│       ├── [ 20K]  2025-02-24_18-03-refining-api-documentation-and-structure.md
│       └── [ 25K]  2025-02-24_18-41-untitled.md
├── [ 160]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [5.5K]  README.md
├── [ 11K]  TODO.md
├── [ 12K]  cleanup.py
├── [  96]  dist
│   └── [   1]  .gitkeep
├── [131K]  nyord_vpn.txt
├── [ 426]  package.toml
├── [6.9K]  pyproject.toml
├── [ 160]  src
│   ├── [   0]  __init__.py
│   └── [ 448]  nyord_vpn
│       ├── [2.3K]  __init__.py
│       ├── [2.5K]  __main__.py
│       ├── [ 448]  api
│       │   ├── [7.7K]  api.py
│       │   ├── [ 27K]  v1_countries.json
│       │   ├── [4.9K]  v1_countries.py
│       │   ├── [5.2K]  v1_groups.json
│       │   ├── [3.9K]  v1_groups.py
│       │   ├── [ 67K]  v1_recommendations.json
│       │   ├── [6.6K]  v1_recommendations.py
│       │   ├── [4.2K]  v1_technologies.json
│       │   ├── [3.5K]  v1_technologies.py
│       │   ├── [ 97K]  v2_servers.json
│       │   └── [9.3K]  v2_servers.py
│       ├── [ 256]  core
│       │   ├── [ 178]  __init__.py
│       │   ├── [9.1K]  api.py
│       │   ├── [6.4K]  base.py
│       │   └── [ 15K]  client.py
│       ├── [ 192]  data
│       │   ├── [  96]  .specstory
│       │   │   └── [  96]  history
│       │   │       └── [2.0K]  .what-is-this.md
│       │   ├── [ 93K]  countries.json
│       │   └── [ 963]  country_ids.json
│       ├── [7.2K]  exceptions.py
│       ├── [ 288]  network
│       │   ├── [ 204]  __init__.py
│       │   ├── [1.0K]  country.py
│       │   ├── [ 36K]  server.py
│       │   ├── [ 47K]  vpn.py
│       │   └── [4.7K]  vpn_commands.py
│       ├── [ 192]  scripts
│       │   ├── [  37]  __init__.py
│       │   └── [3.0K]  update_countries.py
│       ├── [ 224]  storage
│       │   ├── [   0]  __init__.py
│       │   ├── [8.8K]  models.py
│       │   └── [4.0K]  state.py
│       └── [ 288]  utils
│           ├── [ 194]  __init__.py
│           ├── [3.8K]  connection.py
│           ├── [  64]  data
│           ├── [ 12K]  templates.py
│           └── [9.4K]  utils.py
├── [ 352]  tests
│   ├── [  40]  __init__.py
│   ├── [2.6K]  conftest.py
│   ├── [ 288]  integration
│   │   ├── [  39]  __init__.py
│   │   ├── [ 12K]  test_config_loading.py
│   │   ├── [2.9K]  test_connection.py
│   │   ├── [9.3K]  test_errors.py
│   │   └── [1.4K]  test_validation_integration.py
│   ├── [2.0K]  test_client.py
│   ├── [3.5K]  test_legacy_api.py
│   ├── [ 159]  test_package.py
│   └── [6.3K]  test_server_manager.py
└── [264K]  uv.lock

22 directories, 121 files

================
File: .cursor/rules/nyord-vpn.mdc
================
---
description: nyord-vpn
globs: *.py
---
# nyord-vpn

A modern Python client for NordVPN with automatic API fallback support, providing both a CLI interface and a Python library.

```bash
# Install system requirements first
brew install openvpn  # macOS
sudo apt install openvpn  # Ubuntu/Debian
sudo dnf install openvpn  # Fedora/RHEL

# Then install and use the package
pip install nyord-vpn
export NORD_USER="username" NORD_PASSWORD="password"
nyord-vpn connect de  # Connect to a German VPN
nyord-vpn status  # Check status
nyord-vpn disconnect  # Disconnect
```

## DEVELOPMENT

After each set of changes, update @TODO.md with what you've done (`- [x] `). Upgrade priorities for NEXT TODO (`- [!]`), re-think the normal TODO (`- [ ] `)

Periodically do:

```
uv venv; source .venv/bin/activate; uv pip install -e .[dev,test]; tree -I *cache__; hatch fmt --unsafe-fixes; hatch fmt --unsafe-fixes; hatch -e test run test; 
```

and react to the results. Use `uv pip...` instead of `pip...` if needed. 

## Working modality

You'll lead two experts: "Ideot" for creative, unorthodox ideas and "Critin" to critique flawed thinking and moderate for balanced discussions. The three of you shall illuminate knowledge with concise, beautiful responses, process methodically for clear answers, collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

Independently tackle challenges systematically, being adaptable and resourceful. Research deeply using all tools, revising to ensure conclusive, exhaustive, insightful results. When you’re finished, print "Wait, but" to go back, think & reflect, revise & improvement what you’ve done (but don’t invent functionality freely). Repeat this. Focus on minimal viable next versions of the code. Ship often and early. 

## General coding principles

Verify info. No assumptions. No apologies. No major invented changes. No unneeded confirmations or checks. Keep existing code and structures unless they need to change. No unnecessary updates or current implementation discussion. Avoid magic numbers, handle edge cases, use assertions to validate assumptions and catch potential errors early.

Every code can fail. Write code that fails gracefully and is UX friendly: uses retries (within reason), does not make stupid assumptions, tests successes, uses fallbacks and backoffs, and then, if the code needs to message the user, be clear and suggest to the user the next steps. Don't prompt the user to do something that the computer can obviously do. The code should ask the user only if there is a real decision to be made. And you should ask me only if a real decision is needed.  

## Keep track of paths

In every source file you create or edit, always maintain the up-to-date `this_file` record that shows the path of the current file relative to the root of the project. Place the `this_file` record near the top of the file, as a comment after the shebangs, or in the YAML Markdown frontmatter. Use these records for orientation. 

## Follow this style for Python

Follow PEP 8. Write clear names. Keep it simple (PEP 20). Use type hints, imperative docstrings (PEP 257), f-strings, and structural pattern matching. Extract repeated logic. Handle errors. Keep functions small. Prefer flat structures. Use pathlib, pydantic as needed. Write maintainable code. 

EVEN IF YOU’RE NOT prompted, always write a "verbose" mode logugu-based logging for debug purposes, write explanatory docstrings and comments that not only explain what a given item (module, function, method) does, but also why it does it, and where and how it's used elsewhere in the code. 

ONLY IF YOU ARE prompted, extend existing features in a way that adds complexity, or refactor in a way that may break things. Remember: minimal viable next version is always our goal. IF NOT PROMPTED, do NOT make such changes. 

For CLI Python scripts, use fire & rich, and start the script with 

```
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

================
File: .github/workflows/push.yml
================
name: Build & Test
on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:
permissions:
  contents: write
  id-token: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"
      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"
  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}
      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"
      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests tests/
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml
  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release
on:
  push:
    tags: ["v*"]
permissions:
  contents: write
  id-token: write
jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/nyord-vpn
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/nyord_vpn/api/api.py
================
class NordVPNAPI:
    def __init__(self, timeout: int = 10) -> None:
        self.recommendations = v1_recommendations.NordVPNRecommendationsV1(
        self.technologies = v1_technologies.NordVPNTechnologiesV1(timeout=timeout)
        self.groups = v1_groups.NordVPNGroupsV1(timeout=timeout)
        self.countries = v1_countries.NordVPNCountriesV1(timeout=timeout)
        self.servers = v2_servers.NordVPNServersV2(timeout=timeout)
    def get_recommended_servers(
            self._recommended_servers = self.recommendations.fetch_recommendations()
    def get_technologies(
            self._technologies = self.technologies.fetch_technologies()
    def get_groups(self, refresh: bool = False) -> list[v1_groups.Group]:
            self._groups = self.groups.fetch_groups()
    def get_countries(self, refresh: bool = False) -> list[v1_countries.Country]:
            self._countries = self.countries.fetch_countries()
    def get_servers(self, refresh: bool = False) -> ServerTuple:
            result = self.servers.fetch_all()
            self._servers = cast(ServerTuple, result)
    def find_best_server(
        servers = self.get_recommended_servers()
                and server.locations[0].country.code.upper() == country_code.upper()
                if any(group.identifier == group_identifier for group in server.groups)
            raise ValueError(
        return min(servers, key=lambda s: s.load)
    def get_server_stats(self) -> dict:
        countries = self.get_countries()
        servers = self.get_servers()[0]
        groups = self.get_groups()
            "total_countries": len(countries),
            "total_servers": len(servers),
            "total_groups": len(groups),
                for country in sorted(
                group.identifier: len(
                        if any(g.identifier == group.identifier for g in server.groups)
    api = NordVPNAPI()
        stats = api.get_server_stats()
        logger.info("\nNordVPN Server Statistics:")
        logger.info(f"Total Countries: {stats['total_countries']}")
        logger.info(f"Total Servers: {stats['total_servers']}")
        logger.info(f"Total Groups: {stats['total_groups']}")
        logger.info("\nTop 5 Countries by Server Count:")
        for code, count in list(stats["servers_by_country"].items())[:5]:
            logger.info(f"{code}: {count} servers")
        logger.info("\nServers by Group:")
        for group, count in stats["servers_by_group"].items():
            logger.info(f"{group}: {count} servers")
            best_us_p2p = api.find_best_server(
            logger.info("\nBest US P2P Server:")
            logger.info(f"Name: {best_us_p2p.name}")
            logger.info(f"Hostname: {best_us_p2p.hostname}")
            logger.info(f"Load: {best_us_p2p.load}%")
            logger.error(e)
        logger.error(f"Error accessing NordVPN API: {e}")

================
File: src/nyord_vpn/api/v1_countries.py
================
class City(BaseModel):
class Country(BaseModel):
class NordVPNCountriesV1:
    def __init__(self, timeout: int = DEFAULT_TIMEOUT) -> None:
    def fetch_countries(self) -> list[Country]:
            response = requests.get(COUNTRIES_V1_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
            return [Country.model_validate(country) for country in data]
            logger.error(f"Failed to fetch NordVPN countries: {e}")
def get_country_by_code(countries: list[Country], country_code: str) -> Country:
        if country.code.upper() == country_code.upper():
    raise ValueError(f"No country found with code: {country_code}")
def get_countries_by_min_servers(
def get_city_by_name(country: Country, city_name: str) -> City:
        if city.name.lower() == city_name.lower():
    raise ValueError(f"No city found with name '{city_name}' in {country.name}")
    client = NordVPNCountriesV1()
        countries = client.fetch_countries()
        logger.info("Server availability by country:")
        for country in sorted(countries, key=lambda x: x.server_count, reverse=True)[
            logger.info(
                logger.info(f"  - {city.name}: {city.server_count} servers")
        large_countries = get_countries_by_min_servers(countries, 100)
        logger.info(f"\nCountries with 100+ servers: {len(large_countries)}")
            logger.info(f"- {country.name}: {country.server_count} servers")
            us = get_country_by_code(countries, "US")
            nyc = get_city_by_name(us, "New York")
            logger.info("\nNew York server details:")
            logger.info(f"Total servers: {nyc.server_count}")
            logger.info(f"Location: {nyc.latitude}, {nyc.longitude}")
            logger.info(f"DNS name: {nyc.dns_name}")
            logger.error(e)
        logger.error(f"Failed to fetch countries: {e}")

================
File: src/nyord_vpn/api/v1_groups.py
================
class GroupType(BaseModel):
class Group(BaseModel):
class NordVPNGroupsV1:
    def __init__(self, timeout: int = DEFAULT_TIMEOUT) -> None:
    def fetch_groups(self) -> list[Group]:
            response = requests.get(GROUPS_V1_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
            return [Group.model_validate(group) for group in data]
            logger.error(f"Failed to fetch NordVPN server groups: {e}")
def get_groups_by_type(groups: list[Group], type_identifier: str) -> list[Group]:
def get_group_by_identifier(groups: list[Group], identifier: str) -> Group:
    raise ValueError(f"No group found with identifier: {identifier}")
    client = NordVPNGroupsV1()
        groups = client.fetch_groups()
        logger.info("Server groups by type:")
            type_groups = get_groups_by_type(groups, type_id)
            logger.info(f"\n{type_groups[0].type.title}:")
                logger.info(f"- {group.title} ({group.identifier})")
            p2p_group = get_group_by_identifier(groups, "legacy_p2p")
            logger.info("\nP2P group details:")
            logger.info(f"Title: {p2p_group.title}")
            logger.info(f"Type: {p2p_group.type.title}")
            logger.info(f"Added: {p2p_group.created_at}")
            logger.error(e)
        logger.error(f"Failed to fetch groups: {e}")

================
File: src/nyord_vpn/api/v1_recommendations.py
================
class City(BaseModel):
class Country(BaseModel):
class Location(BaseModel):
class Service(BaseModel):
class TechnologyMetadata(BaseModel):
class TechnologyPivot(BaseModel):
class Technology(BaseModel):
class GroupType(BaseModel):
class Group(BaseModel):
class SpecificationValue(BaseModel):
class Specification(BaseModel):
class IP(BaseModel):
class ServerIP(BaseModel):
class RecommendedServer(BaseModel):
class NordVPNRecommendationsV1:
    def __init__(self, timeout: int = DEFAULT_TIMEOUT) -> None:
    def fetch_recommendations(self) -> list[RecommendedServer]:
            response = requests.get(RECOMMENDATIONS_V1_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
            return [RecommendedServer.model_validate(server) for server in data]
            logger.error(f"Failed to fetch NordVPN server recommendations: {e}")
def get_recommendations_by_country(
        and server.locations[0].country.code.upper() == country_code.upper()
def get_recommendations_by_group(
        if any(group.identifier == group_identifier for group in server.groups)
    client = NordVPNRecommendationsV1()
        recommended_servers = client.fetch_recommendations()
            logger.info(
                logger.info(f"  Location: {loc.country.name}, {loc.country.city.name}")
                    f"  Groups: {', '.join(group.title for group in server.groups)}"
                    f"  Services: {', '.join(service.name for service in server.services)}"
            logger.info("---")
        us_servers = get_recommendations_by_country(recommended_servers, "US")
        logger.info(f"\nNumber of US recommended servers: {len(us_servers)}")
        p2p_servers = get_recommendations_by_group(recommended_servers, "legacy_p2p")
        logger.info(f"\nNumber of recommended P2P servers: {len(p2p_servers)}")
        logger.error(f"Failed to fetch server recommendations: {e}")

================
File: src/nyord_vpn/api/v1_technologies.py
================
class Technology(BaseModel):
class NordVPNTechnologiesV1:
    def __init__(self, timeout: int = DEFAULT_TIMEOUT) -> None:
    def fetch_technologies(self) -> list[Technology]:
            response = requests.get(TECHNOLOGIES_V1_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
            return [Technology.model_validate(tech) for tech in data]
            logger.error(f"Failed to fetch NordVPN technologies: {e}")
def get_technology_by_identifier(
    raise ValueError(f"No technology found with identifier: {identifier}")
    client = NordVPNTechnologiesV1()
        technologies = client.fetch_technologies()
        logger.info("Available VPN technologies:")
            logger.info(f"- {tech.name} ({tech.identifier})")
            logger.info(f"  Internal ID: {tech.internal_identifier}")
            logger.info(f"  Added: {tech.created_at}")
            logger.info("---")
            wireguard = get_technology_by_identifier(technologies, "wireguard_udp")
            logger.info("\nWireGuard details:")
            logger.info(f"Name: {wireguard.name}")
            logger.info(f"Internal identifier: {wireguard.internal_identifier}")
            logger.info(f"Added: {wireguard.created_at}")
            logger.error(e)
        logger.error(f"Failed to fetch technologies: {e}")

================
File: src/nyord_vpn/api/v2_servers.py
================
class TechnologyMetadata(BaseModel):
class Technology(BaseModel):
class IP(BaseModel):
class ServerIP(BaseModel):
class SpecificationValue(BaseModel):
class Specification(BaseModel):
class GroupType(BaseModel):
class Group(BaseModel):
class Service(BaseModel):
class City(BaseModel):
class Country(BaseModel):
class Location(BaseModel):
class Server(BaseModel):
class NordVPNServersV2:
    def __init__(self, timeout: int = DEFAULT_TIMEOUT) -> None:
            "servers": TypeAdapter(list[Server]),
            "groups": TypeAdapter(list[Group]),
            "services": TypeAdapter(list[Service]),
            "locations": TypeAdapter(list[Location]),
            "technologies": TypeAdapter(list[Technology]),
    def fetch_all(
            response = requests.get(SERVERS_V2_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
                key: self._type_adapters[key].validate_python(data[key])
                self._link_server_relations(server, maps)
            logger.error(f"Failed to fetch NordVPN server data: {e}")
    def _link_server_relations(self, server: Server, maps: dict) -> None:
            for group_id in getattr(server, "group_ids", [])
            for service_id in getattr(server, "service_ids", [])
            for location_id in getattr(server, "location_ids", [])
            if hasattr(server, attr):
                delattr(server, attr)
def get_servers_by_country(servers: list[Server], country_code: str) -> list[Server]:
        and server.locations[0].country.code.upper() == country_code.upper()
def get_servers_by_group(servers: list[Server], group_identifier: str) -> list[Server]:
        if any(group.identifier == group_identifier for group in server.groups)
    client = NordVPNServersV2()
        servers, groups, services, locations, technologies = client.fetch_all()
            logger.info(
                logger.info(f"  Location: {loc.country.name}, {loc.country.city.name}")
                    f"  Groups: {', '.join(group.title for group in server.groups)}"
                    f"  Services: {', '.join(service.name for service in server.services)}"
            logger.info("---")
        us_servers = get_servers_by_country(servers, "US")
        logger.info(f"\nNumber of US servers: {len(us_servers)}")
        p2p_servers = get_servers_by_group(servers, "legacy_p2p")
        logger.info(f"\nNumber of P2P servers: {len(p2p_servers)}")
        logger.error(f"Failed to fetch server data: {e}")

================
File: src/nyord_vpn/core/__init__.py
================


================
File: src/nyord_vpn/core/api.py
================
class NordVPNAPIClient:
    def __init__(self, username: str, password: str, verbose: bool = False) -> None:
    def list_countries(self, use_cache: bool = True) -> list[Country]:
            response = get(url, headers=API_HEADERS, timeout=10)
            response.raise_for_status()
            countries: list[Country] = response.json()
                "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            cache_countries(cache_data)
            self.logger.warning(f"Failed to fetch countries: {e}")
            cached = get_cached_countries()
    def get_country_by_code(self, code: str) -> Country | None:
        code = code.upper()
        for country in self.list_countries():
    def get_country_by_name(self, name: str) -> Country | None:
        name = name.lower()
            if country["name"].lower() == name:
    def get_available_locations(self) -> list[str]:
        for country in sorted(self.list_countries(), key=lambda x: x["name"]):
            locations.append(
                f"{country['name']} ({country['code'].lower()}) - {total_servers} servers",
            for city in sorted(country["cities"], key=lambda x: x["name"]):
                locations.append(f"  {city['name']} - {city['serverCount']} servers")
    def get_best_city(self, country_code: str) -> City | None:
        country = self.get_country_by_code(country_code)
        sorted_cities = sorted(
    def test_api_connectivity(self) -> bool:
            response = get(
                self.logger.exception(f"API connectivity test failed: {e}")

================
File: src/nyord_vpn/core/base.py
================
class NordVPNClient:
    def __init__(self, username: str, password: str, verbose: bool = False) -> None:
        self.countries = self._load_countries()
        self.logger.add(sys.stdout, level="DEBUG" if self.verbose else "INFO")
    def _load_countries(self) -> list[Country]:
            with open(self.cache_file) as f:
                cache_data: CountryCache = json.load(f)
            self.logger.warning(f"Failed to load cache: {e}. Using fallback data.")
    def get_country_by_code(self, code: str) -> Country | None:
        code = code.upper()
    def get_country_by_name(self, name: str) -> Country | None:
        name = name.lower()
            if country["name"].lower() == name:
    def get_available_locations(self) -> list[str]:
        for country in sorted(self.countries, key=lambda x: x["name"]):
            locations.append(
                f"{country['name']} ({country['code'].lower()}) - {total_servers} servers",
            for city in sorted(country["cities"], key=lambda x: x["name"]):
                locations.append(f"  {city['name']} - {city['serverCount']} servers")
    def get_best_city(self, country_code: str) -> City | None:
        country = self.get_country_by_code(country_code)
        sorted_cities = sorted(
    def list_countries(self, use_cache: bool = True) -> list[Country]:
            response = requests.get(url, headers=API_HEADERS, timeout=10)
            response.raise_for_status()
            countries: list[Country] = response.json()
                "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            cache_countries(cache_data)
            self.logger.warning(f"Failed to fetch countries: {e}")
            cached = get_cached_countries()

================
File: src/nyord_vpn/core/client.py
================
load_dotenv()
logger.configure(
            "sink": RichHandler(),
PACKAGE_DIR = Path(__file__).parent
console = Console()
class City(TypedDict):
class Country(TypedDict):
class CountryCache(TypedDict):
class Client:
    def __init__(
            or os.environ.get("NORD_USER")
            or os.environ.get("NORDVPN_LOGIN")
            or os.environ.get("NORD_PASSWORD")
            or os.environ.get("NORDVPN_PASSWORD")
            raise VPNError(
        self.api_client = NordVPNAPIClient(self.username, self.password, verbose)
        self.server_manager = ServerManager(self.api_client)
        self.vpn_manager = VPNConnectionManager(
            self.vpn_manager.setup_connection("", self.username, self.password)
            if "hostname" in str(e).lower():
    def is_protected(self) -> bool:
        status = self.status()
        return status.get("connected", False)
    def status(self) -> dict[str, Any]:
        return self.vpn_manager.status()
    def go(self, country_code: str) -> None:
            if status.get("connected", False):
                    self.logger.info(
            servers = self.server_manager.select_fastest_server(country_code)
                raise VPNError(f"No servers available in {country_code}")
            hostname = server.get("hostname")
                raise VPNError("Selected server has no hostname")
                self.logger.info(f"Selected server: {hostname}")
                console.print(f"Selected server: [cyan]{hostname}[/cyan]")
                raise VPNError("Missing VPN credentials")
            self.vpn_manager.setup_connection(hostname, self.username, self.password)
                self.logger.info("Establishing VPN connection...")
                console.print("Establishing VPN connection...")
            self.vpn_manager.connect(servers)  # Pass all servers to try in order
            console.print("[green]Successfully connected to VPN[/green]")
            console.print(f"Private IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
            console.print(f"Country: [cyan]{status.get('country', 'Unknown')}[/cyan]")
            console.print(f"Server: [cyan]{status.get('server', 'Unknown')}[/cyan]")
            raise VPNError(f"Failed to connect: {e}")
    def bye(self) -> None:
            logger.info("Checking current connection status...")
            status = self.vpn_manager.status()
                self.vpn_manager.disconnect()
                logger.info("No active VPN connection found")
            logger.error(f"Error during disconnect: {e}")
        current_ip = self.vpn_manager.get_current_ip()
            self.logger.info("Checking current connection status...")
        if self.vpn_manager.is_connected():
                self.logger.info("Disconnecting from VPN...")
            console.print("[green]Disconnected from VPN[/green]")
                self.logger.info("No active VPN connection found")
            console.print("[yellow]Not connected to VPN[/yellow]")
        public_ip = self.vpn_manager.get_current_ip()
            "timestamp": time.time(),
        save_vpn_state(state)
            console.print(f"Public IP: [cyan]{public_ip}[/cyan]")
            console.print("[yellow]Could not determine IP[/yellow]")
    def info(self) -> None:
                console.print("[green]VPN Status: Connected[/green]")
                console.print(
                    f"Country: [cyan]{status.get('country', 'Unknown')}[/cyan]"
                console.print("[yellow]VPN Status: Not Connected[/yellow]")
                console.print(f"Public IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
            raise VPNError(f"Failed to get status: {e}")
    def init(self) -> None:
            openvpn_path = self.vpn_manager.check_openvpn_installation()
                self.logger.info(f"Found OpenVPN at: {openvpn_path}")
                directory.mkdir(parents=True, exist_ok=True)
                    self.logger.info(f"Created directory: {directory}")
            if not self.api_client.test_api_connectivity():
                raise ConnectionError("Failed to connect to NordVPN API")
                self.logger.info("Successfully connected to NordVPN API")
            initial_ip = self.vpn_manager.get_current_ip()
                raise ConnectionError("Failed to get initial IP")
                self.logger.info(f"Initial IP: {initial_ip}")
                self.logger.info("Client environment initialized successfully")
            raise ConnectionError(f"Failed to initialize client environment: {e}")
    def get_current_ip(self) -> str | None:
        return self.vpn_manager.get_current_ip()
    def _save_state(self) -> None:
            "connected": self.is_protected(),
            "initial_ip": self.get_current_ip(),
            "connected_ip": self.get_current_ip(),
            "server": self.status().get("server", "Unknown"),
            "country": self.status().get("country", "Unknown"),

================
File: src/nyord_vpn/data/.specstory/history/.what-is-this.md
================
# SpecStory Artifacts Directory
    
This directory is automatically created and maintained by the SpecStory extension to preserve your Cursor composer and chat history.
    
## What's Here?
    
- `.specstory/history`: Contains markdown files of your AI coding sessions
- Each file represents a separate chat or composer session
- Files are automatically updated as you work

## Valuable Uses
    
- Capture: Keep your context window up-to-date when starting new Chat/Composer sessions via @ references
- Search: For previous prompts and code snippets 
- Learn: Meta-analyze your patterns and learn from your past experiences
    
## Version Control
    
We recommend keeping this directory under version control to maintain a history of your AI interactions. However, if you prefer not to version these files, you can exclude them by adding this to your `.gitignore`:
    
```
.specstory/**
```
    
## Searching Your Codebase
    
When searching your codebase in Cursor, search results may include your previous AI coding interactions. To focus solely on your actual code files, you can exclude the AI interaction history from search results.
    
To exclude AI interaction history:
    
1. Open the "Find in Files" search in Cursor (Cmd/Ctrl + Shift + F)
2. Navigate to the "files to exclude" section
3. Add the following pattern:
    
```
.specstory/*
```
    
This will ensure your searches only return results from your working codebase files.

## Notes

- Auto-save only works when Cursor/sqlite flushes data to disk. This results in a small delay after the AI response is complete before SpecStory can save the history.
- Auto-save does not yet work on remote WSL workspaces.

## Settings
    
You can control auto-saving behavior in Cursor:
    
1. Open Cursor → Settings → VS Code Settings (Cmd/Ctrl + ,)
2. Search for "SpecStory"
3. Find "Auto Save" setting to enable/disable
    
Auto-save occurs when changes are detected in Cursor's sqlite database, or every 2 minutes as a safety net.

================
File: src/nyord_vpn/network/__init__.py
================


================
File: src/nyord_vpn/network/country.py
================
def get_cached_countries() -> CountryCache | None:
        if not COUNTRIES_CACHE.exists():
        if time.time() - COUNTRIES_CACHE.stat().st_mtime > CACHE_EXPIRY:
        return json.loads(COUNTRIES_CACHE.read_text())
def cache_countries(data: CountryCache) -> None:
        COUNTRIES_CACHE.parent.mkdir(parents=True, exist_ok=True)
        COUNTRIES_CACHE.write_text(json.dumps(data, indent=2, sort_keys=True))
        COUNTRIES_CACHE.chmod(0o644)  # Make readable for all users

================
File: src/nyord_vpn/network/server.py
================
class Country(TypedDict):
class ServerLocation(TypedDict):
class Technology(TypedDict):
class ServerInfo(TypedDict):
class ServerCache(TypedDict):
def _safe_dict_get(d: dict[str, Any], key: str, default: Any = None) -> Any:
    return d.get(key, default) if isinstance(d, dict) else default
def _safe_get(d: dict[str, Any] | None, key: str, default: Any = None) -> Any:
    return _safe_dict_get(d, key, default)
def _safe_str_get(s: str | None, key: str, default: Any = None) -> Any:
        return s[int(key)] if key.isdigit() else default
def _safe_dict_access(d: dict[str, Any], key: str) -> Any:
    if not isinstance(d, dict) or key not in d:
        raise KeyError(f"Required key {key} not found in dictionary")
def _safe_dict_cast(d: Any) -> dict[str, Any]:
    if not isinstance(d, dict):
    return cast(dict[str, Any], d)
def _safe_dict_get_str(d: dict[str, Any], key: str, default: str = "") -> str:
    value = _safe_dict_get(d, key, default)
    return str(value) if value is not None else default
def _safe_dict_get_int(d: dict[str, Any], key: str, default: int = 0) -> int:
        return int(value) if value is not None else default
def _safe_dict_get_list(
    return value if isinstance(value, list) else default
def _safe_dict_get_dict(
    return value if isinstance(value, dict) else default
def cache_servers(data: dict[str, Any]) -> None:
        if not isinstance(data, dict):
            logger.warning("Invalid server data format")
        SERVERS_CACHE_FILE.parent.mkdir(parents=True, exist_ok=True)
        temp_file = SERVERS_CACHE_FILE.with_suffix(".tmp")
        temp_file.write_text(json.dumps(data, indent=2))
        temp_file.replace(SERVERS_CACHE_FILE)
        logger.warning(f"Failed to cache server information: {e}")
def _parse_timestamp(timestamp: Any) -> float:
    if isinstance(timestamp, int | float):
        return float(timestamp)
    if isinstance(timestamp, str):
                dt = datetime.fromisoformat(timestamp.replace("Z", "+00:00"))
                return dt.timestamp()
def get_cached_servers() -> ServerCache | None:
        if not SERVERS_CACHE_FILE.exists():
        data = json.loads(SERVERS_CACHE_FILE.read_text())
        last_updated = _parse_timestamp(_safe_dict_get(data, "last_updated", 0))
        if time.time() - last_updated > SERVERS_CACHE_TTL:
            "servers": cast(list[ServerInfo], _safe_dict_get_list(data, "servers", [])),
            "locations": cast(
                dict[str, ServerLocation], _safe_dict_get_dict(data, "locations", {})
        logger.warning(f"Failed to read server cache: {e}")
class ServerManager:
    def __init__(self, api_client: NordVPNAPIClient) -> None:
        self._failed_servers = set()  # Track failed servers in this session
    def _validate_country_code(self, country_code: str | None) -> str | None:
        normalized = country_code.upper()
        if not isinstance(normalized, str) or len(normalized) != 2:
            raise ServerError(f"Invalid country code format: {country_code}")
        cache = self.get_servers_cache()
            raise ServerError("No server information available")
        for location in cache["locations"].values():
            if location["country"]["code"].upper() == normalized:
        available_countries = sorted(
                loc["country"]["code"].upper()
                for loc in cache["locations"].values()
        raise ServerError(
            f"Available countries: {', '.join(available_countries)}"
    def fetch_server_info(self, country: str | None = None) -> tuple[str, str] | None:
                raise ServerError("Failed to get server list")
            for loc_id, location in locations.items():
                if isinstance(location, dict):
                    location_lookup[str(loc_id)] = location
                    normalized_country = self._validate_country_code(country)
                        location = location_lookup.get(str(loc_id))
                            and location["country"]["code"].upper()
                filtered_servers.append(server)
                        for loc in locations.values()
                    f"No servers available{' in ' + country.upper() if country else ''}"
                        f"\nAvailable countries: {', '.join(available_countries)}"
                raise ServerError(error_msg)
            server = min(filtered_servers, key=lambda x: x["load"])
                raise ServerError("Invalid server data received")
                self.logger.debug(
            return hostname, server.get("station", "")
            raise ServerError(f"Failed to fetch server info: {e}")
    def get_servers_cache(self) -> ServerCache | None:
                and time.time() - self._last_cache_update <= SERVERS_CACHE_TTL
            file_cache = get_cached_servers()
                self._last_cache_update = time.time()
            response = requests.get(
            response.raise_for_status()
            api_data = response.json()
            if not isinstance(api_data, dict):
                self.logger.warning(
                "last_updated": time.time(),
            for location in api_data.get("locations", []):
                if not isinstance(location, dict):
                location_id = str(location.get("id", ""))
                country_data = location.get("country", {})
                if isinstance(country_data, dict):
                        "name": str(country_data.get("name", "")),
                        "code": str(country_data.get("code", "")),
            for item in api_data.get("servers", []):
                if not isinstance(item, dict):
                for tech in item.get("technologies", []):
                    if not isinstance(tech, dict):
                    tech_id = tech.get("id")
                        "id": int(tech_id),
                        "status": str(tech.get("status", "")),
                    if tech.get("metadata"):
                        technology["metadata"] = cast(
                    technologies.append(technology)
                    "hostname": str(item.get("hostname", "")),
                    "location_ids": [str(lid) for lid in item.get("location_ids", [])],
                    "status": str(item.get("status", "")),
                    "load": int(item.get("load", 0)),
                servers.append(server_info)
            cache_servers(cast(dict[str, Any], new_cache))
            self.logger.warning(f"Failed to get server information: {e}")
    def _ping_server(self, hostname: str) -> float:
            system = platform.system().lower()
                self.logger.debug(f"Running ping command: {' '.join(cmd)}")
            result = subprocess.run(
                min_time = float("inf")
                for line in result.stdout.splitlines():
                        self.logger.debug(f"Ping output line: {line}")
                            stats = line.split("=")[1].strip().split("/")
                            min_time = float(stats[0])
                            time_str = line.split("time=")[1].split()[0].rstrip("ms")
                            ping_time = float(time_str)
                            min_time = min(min_time, ping_time)
                if min_time < float("inf"):
                return float("inf")
                self.logger.debug(f"Server {hostname} ping timed out")
                self.logger.debug(f"Server {hostname} ping error: {e}")
                self.logger.debug(f"Traceback: {traceback.format_exc()}")
    def _is_valid_server(self, server: Any) -> bool:
        if not isinstance(server, dict):
        hostname = server.get("hostname")
        if not isinstance(hostname, str) or not hostname:
        for tech in server.get("technologies", []):
            tech_name = tech.get("name", "")
                isinstance(tech, dict)
                and isinstance(tech_name, str)
    def _test_server(self, server: dict[str, Any]) -> tuple[dict[str, Any], float]:
        hostname = _safe_dict_get(server, "hostname")
            return server, float("inf")
            tcp_time = float("inf")
                context = ssl.create_default_context()
                start = time.time()
                with socket.create_connection((hostname, 443), timeout=1) as sock:
                    tcp_time = (time.time() - start) * 1000  # Convert to ms
                        with context.wrap_socket(
                            ssock.do_handshake()
                    self.logger.debug(f"TCP test failed for {hostname}: {e}")
            ping_time = float("inf")
                                    ping_time = float(
                                        line.split("=")[1].strip().split("/")[0]
                        with contextlib.suppress(IndexError, ValueError):
                                result.stdout.split("time=")[1].split()[0].rstrip("ms")
                    self.logger.debug(f"Ping failed for {hostname}: {e}")
                self.logger.debug(f"Failed to test server {hostname}: {e}")
    def _select_diverse_servers(
            region = server.get("country", {}).get("region", {}).get("name", "Unknown")
            regions[region].append(server)
        region_names = list(regions.keys())
        while len(selected) < count and region_names:
            region = region_names.pop(random.randrange(len(region_names)))
            if region_servers := regions.get(region, []):
                server = random.choice(region_servers)
                selected.append(server)
        if remaining_servers and len(selected) < count:
            sample_size = min(count - len(selected), len(remaining_servers))
                remaining = random.sample(remaining_servers, sample_size)
                selected.extend(remaining)
                selected.append(random.choice(servers))
    def select_fastest_server(
                raise ServerError("No servers available")
            location_lookup = {str(loc["id"]): loc for loc in locations.values()}
                country_code = country_code.upper()
                            and location["country"]["code"].upper() == country_code
                self._failed_servers.clear()  # Reset failed servers if none left
                return self.select_fastest_server(country_code)  # Try again
            servers.sort(key=lambda x: x["load"])
            logger.debug(servers)
                server_result, score = self._test_server(cast(dict[str, Any], server))
                if score < float("inf"):
                    results.append((server_result, score))
            results.sort(key=lambda x: x[1])
            if isinstance(e, ServerError):
            raise ServerError(f"Failed to select server: {e}")
    def _get_country_id(self, country_code: str) -> str:
                if isinstance(location, dict) and isinstance(
                    location.get("country"), dict
                    if country.get("code", "").upper() == country_code.upper():
                        return str(country.get("id", ""))
                self.logger.warning(f"Failed to get country ID: {e}")
    def get_random_country(self) -> str:
                raise ServerError("No countries found in server list")
            selected = random.choice(list(countries))
                self.logger.debug(f"Selected random country: {selected}")
            self.logger.warning(f"Failed to get random country: {e}")
    def get_country_info(self, country_code: str) -> dict[str, Any] | None:
                self.logger.warning(f"Failed to get country info for {normalized}: {e}")

================
File: src/nyord_vpn/network/vpn_commands.py
================
def get_openvpn_command(
    if not config_path.exists():
        raise VPNConfigError(f"OpenVPN config file not found: {config_path}")
    if not auth_path.exists():
        raise VPNConfigError(f"OpenVPN auth file not found: {auth_path}")
        config_path.read_bytes()
        auth_path.read_bytes()
        raise VPNConfigError(f"Cannot read OpenVPN files: {e}")
        log_path.parent.mkdir(parents=True, exist_ok=True)
        raise VPNConfigError(f"Invalid verbosity level: {verbosity} (must be 1-6)")
        str(config_path),
        str(auth_path),
        str(verbosity),
        str(connect_retry),
        str(connect_timeout),
        str(ping_interval),
        str(ping_restart),
    system = platform.system().lower()
        cmd.extend(
        resolv_conf_script = Path("/etc/openvpn/update-resolv-conf")
        if resolv_conf_script.exists():
                    str(resolv_conf_script),
        cmd.extend(["--log", str(log_path)])

================
File: src/nyord_vpn/network/vpn.py
================
console = Console()
OPENVPN_AUTH = Path.home() / ".cache" / "nyord-vpn" / "openvpn.auth"
OPENVPN_LOG = Path.home() / ".cache" / "nyord-vpn" / "openvpn.log"
class VPNConnectionManager:
    def __init__(
        state = load_vpn_state()
        self._normal_ip = state.get("normal_ip")
        self._connected_ip = state.get("connected_ip")
        self._server = state.get("server")
        self._country_name = state.get("country")
        OPENVPN_AUTH.parent.mkdir(parents=True, exist_ok=True)
            self.openvpn_path = self.check_openvpn_installation()
                self.logger.warning("OpenVPN not found during initialization")
    def check_openvpn_installation(self) -> str:
                if Path(path).exists():
                    result = subprocess.run(
                            self.logger.debug(f"Found OpenVPN at {path}")
                path = result.stdout.strip()
            raise VPNError(
            if isinstance(e, VPNError):
            raise VPNError(f"Failed to verify OpenVPN installation: {e}")
    def setup_connection(self, hostname: str, username: str, password: str) -> None:
            if not username or not isinstance(username, str):
                raise VPNAuthenticationError("Username must be a non-empty string")
            username = username.strip()
                raise VPNAuthenticationError("Username cannot be empty")
            if not password or not isinstance(password, str):
                raise VPNAuthenticationError("Password must be a non-empty string")
            password = password.strip()
                raise VPNAuthenticationError("Password cannot be empty")
            if len(password) < 8:
                raise VPNAuthenticationError("Password must be at least 8 characters")
            auth_dir.mkdir(mode=0o700, parents=True, exist_ok=True)
            temp_auth = auth_dir / f".openvpn.auth.{os.getpid()}.tmp"
                temp_auth.write_text(f"{username}\n{password}")
                temp_auth.chmod(0o600)
                temp_auth.replace(OPENVPN_AUTH)
                    self.logger.debug(f"Created auth file at {OPENVPN_AUTH}")
                    if temp_auth.exists():
                        temp_auth.unlink()
                raise VPNAuthenticationError(
                stat = OPENVPN_AUTH.stat()
                    OPENVPN_AUTH.chmod(0o600)
                        self.logger.debug("Fixed auth file permissions")
                lines = OPENVPN_AUTH.read_text().strip().split("\n")
                if len(lines) != 2:
                if lines[0].strip() != username or lines[1].strip() != password:
                if isinstance(e, VPNAuthenticationError):
            raise VPNAuthenticationError(str(e))
    def get_current_ip(self) -> str | None:
        def is_valid_ipv4(ip: str) -> bool:
                parts = ip.strip().split(".")
                if len(parts) != 4:
                return all(0 <= int(part) <= 255 for part in parts)
        for attempt in range(2):
                    self.logger.debug(
                response = requests.get("https://api.ipify.org?format=json", timeout=3)
                response.raise_for_status()
                data = response.json()
                ip = data.get("ip")
                if ip and is_valid_ipv4(ip):
                        self.logger.debug(f"Got valid IP {ip} from api.ipify.org")
                    time.sleep(0.5)
                response = requests.get("http://ip-api.com/json", timeout=3)
                ip = data.get("query")
                        self.logger.debug(f"Got valid IP {ip} from ip-api.com")
                self.logger.debug("Checking IP with ifconfig.me (final attempt)")
            response = requests.get("https://ifconfig.me/ip", timeout=3)
            ip = response.text.strip()
                    self.logger.debug(f"Got valid IP {ip} from ifconfig.me")
                self.logger.debug(f"Final IP check failed: {e}")
            self.logger.warning("Failed to get current IP from any service")
    def _save_state(self) -> None:
        current_ip = self.get_current_ip()
            "connected": self.is_connected(),
            "timestamp": time.time(),
        save_vpn_state(state)
    def connect(self, servers: list[dict[str, Any]]) -> None:
                hostname = server.get("hostname")
                    raise VPNError("Invalid server info - missing hostname")
                    self.disconnect()
                        self.logger.warning(
                    for proc in psutil.process_iter(["name", "pid", "cmdline"]):
                                cmdline = proc.info.get("cmdline", [])
                                if any("nordvpn.com" in arg for arg in cmdline):
                                        os.kill(proc.info["pid"], signal.SIGKILL)
                                        time.sleep(0.1)  # Brief pause after kill
                    location_ids = server.get("location_ids", [])
                    locations = self.server_manager.get_servers_cache().get(
                        location = locations.get(str(loc_id))
                        if location and location.get("country"):
                    self.logger.debug(f"Connecting to {hostname}")
                config_path = get_config_path(hostname)
                    raise VPNConfigError(f"Failed to get OpenVPN config for {hostname}")
                        config_content = config_path.read_text()
                        self.logger.debug(f"OpenVPN config for {hostname}:")
                        for line in config_content.splitlines():
                            if not line.strip().startswith("#"):  # Skip comments
                                self.logger.debug(f"  {line}")
                        self.logger.warning(f"Failed to read config file: {e}")
                if not OPENVPN_AUTH.exists():
                    raise VPNError("Auth file not found - please run setup first")
                    auth_content = OPENVPN_AUTH.read_text().strip().split("\n")
                    if len(auth_content) != 2:
                        self.logger.debug("Auth file exists and has correct format")
                    raise VPNError(f"Failed to read auth file: {e}")
                cmd = get_openvpn_command(
                    self.logger.debug("Running OpenVPN command:")
                    self.logger.debug(" ".join(cmd))
                    if OPENVPN_LOG and OPENVPN_LOG.exists():
                        OPENVPN_LOG.unlink()
                    self.process = subprocess.Popen(
                    if self.process.poll() is not None:
                        stdout, stderr = self.process.communicate()
                    raise VPNError(f"Failed to start OpenVPN process: {e}")
                start_time = time.time()
                while time.time() - start_time < 30:  # 30 second timeout
                                log_content = OPENVPN_LOG.read_text()
                                    self.logger.debug("OpenVPN log content:")
                                    for line in log_content.splitlines():
                                self.logger.warning(f"Failed to read OpenVPN log: {e}")
                                    for line in log_content.splitlines()
                                    self.logger.debug("Auth-related log lines:")
                                    self.logger.debug("Auth progress:")
                    time.sleep(0.1)
                    if self.process and self.process.poll() is None:
                            self.process.terminate()
                            if self.process.poll() is None:
                                self.process.kill()
                        error_messages.append(
                time.sleep(1)  # Brief pause to let connection stabilize
                if not self.verify_connection():
                        self.logger.warning(error_msg)
                    error_messages.append(error_msg)  # Collect
                    self.logger.info(f"Connected to {hostname}")
                        time.sleep(0.1)  # Brief pause
                error_messages.append(str(e))  # Collect
                if isinstance(e, VPNError | VPNAuthenticationError | VPNConfigError):
            "Failed to connect after trying all servers:\n" + "\n".join(error_messages)
    def disconnect(self) -> None:
                    for _ in range(10):  # 1 second total
                        self.logger.warning(f"Error terminating tracked process: {e}")
                                os.kill(proc.info["pid"], signal.SIGTERM)
                                if self._is_process_running(proc.info["pid"]):
                            remaining.append(proc.info["pid"])
                        self.logger.debug("Cleaned up OpenVPN log file")
                        self.logger.warning(f"Failed to clean up OpenVPN log: {e}")
            self._invalidate_ip_cache()
                self.logger.info("Disconnected from VPN")
            if isinstance(e, ProcessLookupError):
                error_details.append("Process not found")
            elif isinstance(e, PermissionError):
                error_details.append("Permission denied")
                error_details.append(str(e))
                self.logger.exception(
                    f"Error during disconnect: {'; '.join(error_details)}"
                f"Failed to disconnect from VPN: {'; '.join(error_details)}"
    def is_connected(self) -> bool:
        return self.process is not None and self.process.poll() is None
    def verify_connection(self) -> bool:
            if not self.process or self.process.poll() is not None:
                    self.logger.debug("OpenVPN process not running")
                    output = subprocess.check_output(["ifconfig"], text=True)
                    if not any(
                        line.startswith("utun") and "UP" in line
                        for line in output.split("\n")
                            self.logger.debug("No active utun interface found")
                        self.logger.debug("Failed to check TUN interface")
                    output = subprocess.check_output(
                            self.logger.debug("TUN interface not up")
                socket.gethostbyname("nordvpn.com")
                    self.logger.debug("DNS resolution failed")
                        self.logger.debug("Failed to get current IP")
                normal_ip = state.get("normal_ip")
                        self.logger.debug("IP has not changed from pre-connection IP")
                    self.logger.debug(f"IP verification failed: {e}")
                self.logger.debug(f"Connection verification failed: {e}")
    def status(self) -> dict[str, Any]:
            "ip": self.get_current_ip(),
                cache = self.server_manager.get_servers_cache()
                if cache and cache.get("servers"):
                        if server.get("hostname") == self._server:
                            locations = cache.get("locations", {})
                    country_code = self._server.split(".")[0][:2].upper()
                    country = self.api_client.get_country_by_code(country_code)
    def _is_process_running(self, process_id: int) -> bool:
            os.kill(process_id, 0)
                self.logger.debug(f"Error checking process {process_id}: {e}")
    def check_connection_state(self) -> bool:
            process_id = state.get("process_id")
            if not process_id or not self._is_process_running(process_id):
                if state.get("connected"):
                            self.logger.debug("OpenVPN connection verified")
                        self.logger.debug(f"Failed to read OpenVPN log: {e}")
                self.logger.exception(f"Error checking connection state: {e}")
    def _invalidate_ip_cache(self) -> None:
            self.logger.debug("IP cache invalidated")
    def go(self, country_code: str) -> None:
        if not check_root():
            ensure_root()
            status = self.status()
            if status.get("connected", False):
                    self.logger.info(
            servers = self.server_manager.select_fastest_server(country_code)
                raise VPNError(f"No servers available in {country_code}")
                self.logger.info(f"Selected {len(servers)} servers to try")
                for i, server in enumerate(servers, 1):
                        f"{i}. {server.get('hostname')} (load: {server.get('load')}%)"
                        self.logger.info(f"Trying server: {hostname}")
                        console.print(f"Trying server: [cyan]{hostname}[/cyan]")
                    self.setup_connection(
                    self.connect([server])  # Pass as list for compatibility
                        self.logger.info(f"Successfully connected to {hostname}")
                    errors.append(error_msg)
                + "\n".join(f"- {e}" for e in errors)
            raise VPNError(f"Failed to connect: {e}")

================
File: src/nyord_vpn/scripts/__init__.py
================


================
File: src/nyord_vpn/scripts/update_countries.py
================
class City(TypedDict):
class Country(TypedDict):
class CountryCache(TypedDict):
def fetch_countries() -> list[Country]:
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        progress.add_task(
        response = requests.get(url, timeout=10)
        response.raise_for_status()
    countries: list[Country] = response.json()
    return sorted(countries, key=lambda x: x["name"])
def main() -> None:
        package_dir = Path(__file__).parent.parent
        data_dir.mkdir(parents=True, exist_ok=True)
        countries = fetch_countries()
        total_servers = sum(country["serverCount"] for country in countries)
        total_cities = sum(len(country["cities"]) for country in countries)
            "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        with cache_file.open("w") as f:
            json.dump(cache_data, f, indent=2, sort_keys=True)
        cache_file.chmod(0o644)
        rprint("[green]✓ Updated country list cache with:[/green]")
        rprint(f"  • [cyan]{len(countries)}[/cyan] countries")
        rprint(f"  • [cyan]{total_cities}[/cyan] cities")
        rprint(f"  • [cyan]{total_servers}[/cyan] servers")
        rprint(f"[blue]Cache file: {cache_file}[/blue]")
        rprint(f"[red]✗ Failed to fetch country list: {e}[/red]")
        sys.exit(1)
        rprint(f"[red]✗ Failed to update cache file: {e}[/red]")
    main()

================
File: src/nyord_vpn/storage/models.py
================
class City(TypedDict):
class Country(TypedDict):
class CountryCache(TypedDict):
class VPNError(Exception):
    def __init__(self, message: str | None = None) -> None:
        super().__init__(message or "An unknown VPN error occurred")
class ServerError(VPNError):
        super().__init__(
class ConnectionError(VPNError):
class AuthenticationError(VPNError):
class CredentialsError(VPNError):
class StateError(VPNError):
class CacheError(VPNError):

================
File: src/nyord_vpn/storage/state.py
================
def save_vpn_state(state: dict) -> None:
        if STATE_FILE.exists():
            with contextlib.suppress(json.JSONDecodeError):
                existing = json.loads(STATE_FILE.read_text())
        current_ip = state.get("current_ip")
        if not state.get("connected") and current_ip:
        elif state.get("connected") and current_ip:
            if not state.get("normal_ip") and existing.get("normal_ip"):
                state["normal_ip"] = existing.get("normal_ip")
        state["timestamp"] = time.time()
        temp_state = STATE_FILE.with_suffix(".tmp")
        temp_state.write_text(json.dumps(state, indent=2))
        temp_state.replace(STATE_FILE)
        logger.warning(f"Failed to save VPN state: {e}")
def load_vpn_state() -> dict:
            state = json.loads(STATE_FILE.read_text())
            if time.time() - state.get("timestamp", 0) < 300:
                "normal_ip": state.get("normal_ip"),
                "timestamp": time.time(),
        logger.warning(f"Failed to load VPN state: {e}")

================
File: src/nyord_vpn/utils/__init__.py
================


================
File: src/nyord_vpn/utils/connection.py
================
def is_openvpn_running() -> bool:
    for proc in psutil.process_iter(["name"]):
        if proc.info.get("name") == "openvpn":
def compute_connection_status(

================
File: src/nyord_vpn/utils/templates.py
================
CACHE_DIR = Path.home() / ".cache" / "nyord-vpn"
def log_debug(msg: str, *args: object, **kwargs: object) -> None:
    if logger.level("DEBUG").no <= logger.level("INFO").no:
        logger.debug(msg.format(*args, **kwargs))
def calculate_sha256(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()
def verify_file_integrity(path: Path, expected_hash: str) -> bool:
        actual_hash = calculate_sha256(path.read_bytes())
        log_debug("Failed to verify file integrity: {}", e)
def get_zip_age() -> timedelta | None:
        if not CONFIG_ZIP.exists():
        mtime = datetime.fromtimestamp(CONFIG_ZIP.stat().st_mtime)
        return datetime.now() - mtime
        log_debug("Failed to get ZIP file age: {}", e)
def is_zip_expired() -> bool:
    age = get_zip_age()
    return age > timedelta(days=ZIP_MAX_AGE_DAYS)
def secure_directory(path: Path, mode: int = 0o700) -> None:
        path.mkdir(mode=mode, parents=True, exist_ok=True)
        stat_info = path.stat()
            path.chmod(mode)
            log_debug("Fixed directory permissions for {}", path)
        user_id = os.getuid()
        group_id = os.getgid()
            os.chown(path, user_id, group_id)
                subprocess.run(
                    ["sudo", "chown", f"{user_id}:{group_id}", str(path)],
                raise VPNConfigError(
                    f"Failed to set ownership with sudo: {e.stderr.decode()}"
        log_debug("Set ownership of {} to {}:{}", path, user_id, group_id)
        raise VPNConfigError(f"Failed to secure directory {path}: {e}")
def cleanup_old_configs() -> None:
        existing_configs = list(CONFIG_DIR.glob("*.tcp.ovpn"))
        if len(existing_configs) > MAX_CACHED_CONFIGS:
            log_debug("Cleaning up old config files...")
            existing_configs.sort(key=lambda p: p.stat().st_mtime)
                    config.unlink()
                    log_debug("Removed old config: {}", config)
                    log_debug("Failed to remove old config {}: {}", config, e)
        log_debug("Failed to cleanup old configs: {}", e)
def download_with_retry(
    for attempt in range(MAX_RETRIES):
                jitter = random.uniform(0, 0.1) * delay
                log_debug(
                time.sleep(sleep_time)
            response = requests.get(url, headers=headers, timeout=timeout)
            response.raise_for_status()
            content_hash = calculate_sha256(content)
            if isinstance(e, requests.HTTPError) and (
            delay = min(delay * 2, MAX_RETRY_DELAY)
                "Download failed (attempt {}/{}): {}", attempt + 1, MAX_RETRIES, str(e)
    if isinstance(last_error, requests.HTTPError):
def extract_config_from_zip(server: str) -> Path:
        secure_directory(CONFIG_DIR)
        cleanup_old_configs()
        log_debug("Extracting config file {} from {}", zip_path, CONFIG_ZIP)
            with zipfile.ZipFile(CONFIG_ZIP) as zip_ref:
                    zip_ref.getinfo(zip_path)
                    file_hash = calculate_sha256(zip_ref.read(zip_path))
                    zip_ref.extract(zip_path, CONFIG_DIR)
                    if not verify_file_integrity(extracted_path, file_hash):
                        raise VPNConfigError("Extracted file is corrupted")
                        for name in zip_ref.namelist()
                        if name.startswith("ovpn_tcp/") and name.endswith(".tcp.ovpn")
                    log_debug("Available TCP configs in ZIP: {}", len(tcp_configs))
                        log_debug("Sample configs: {}", tcp_configs[:5])
                        f"ZIP contains {len(tcp_configs)} TCP configs."
            with contextlib.suppress(Exception):
                CONFIG_ZIP.unlink()
            raise VPNConfigError(f"Corrupted ZIP file: {e}") from e
            extracted_path.rename(config_path)
            if not verify_file_integrity(config_path, file_hash):
                raise VPNConfigError("Config file corrupted during move")
            raise VPNConfigError(f"Failed to move config file: {e}") from e
        with contextlib.suppress(FileNotFoundError, OSError):
            (CONFIG_DIR / "ovpn_tcp").rmdir()
            config_path.chmod(0o600)
            log_debug("Set permissions on {}", config_path)
            raise VPNConfigError(f"Failed to set config file permissions: {e}") from e
        raise VPNConfigError(f"Failed to extract configuration: {e}")
def download_config_zip() -> None:
        secure_directory(CACHE_DIR)
        temp_zip = CACHE_DIR / f".ovpn.{os.getpid()}.zip.tmp"
            log_debug("Downloading OpenVPN configurations...")
            content, content_hash = download_with_retry(OVPN_CONFIG_URL, HEADERS)
                temp_zip.write_bytes(content)
                temp_zip.chmod(0o600)
                if not verify_file_integrity(temp_zip, content_hash):
                    raise VPNConfigError("Downloaded file corrupted during write")
                raise VPNConfigError(f"Failed to write temporary ZIP file: {e}") from e
                with zipfile.ZipFile(temp_zip) as zip_ref:
                    log_debug("ZIP contains {} TCP configs", len(tcp_configs))
                raise VPNConfigError("Downloaded file is not a valid ZIP") from e
                temp_zip.replace(CONFIG_ZIP)
                if not verify_file_integrity(CONFIG_ZIP, content_hash):
                    raise VPNConfigError("ZIP file corrupted during move")
                log_debug("OpenVPN configurations cached at {}", CONFIG_ZIP)
                raise VPNConfigError(f"Failed to save ZIP file: {e}") from e
                if temp_zip.exists():
                    temp_zip.unlink()
        raise VPNConfigError(f"Failed to download/cache configurations: {e}")
def get_config_path(server: str) -> Path:
    server = server.replace(".tcp", "")
    log_debug("Looking for config file at: {}", config_path)
    if is_zip_expired():
            log_debug("ZIP file is {} days old, downloading fresh copy...", age.days)
            log_debug("ZIP file is missing, downloading...")
        if CONFIG_ZIP.exists():
                log_debug("Failed to remove old ZIP file: {}", e)
        download_config_zip()
    if not config_path.exists():
        log_debug("Config file not found at: {}", config_path)
        config_path = extract_config_from_zip(server)
        log_debug("Successfully extracted config to: {}", config_path)
        stat_info = config_path.stat()
            log_debug("Fixed config file permissions for {}", config_path)
        raise VPNConfigError(f"Failed to verify config file permissions: {e}")

================
File: src/nyord_vpn/utils/utils.py
================
console = Console()
CACHE_DIR = Path(user_cache_dir(APP_NAME, APP_AUTHOR))
CONFIG_DIR = Path(user_config_dir(APP_NAME, APP_AUTHOR))
CACHE_DIR.mkdir(mode=0o700, parents=True, exist_ok=True)
CONFIG_DIR.mkdir(mode=0o700, parents=True, exist_ok=True)
PACKAGE_DIR = Path(__file__).parent
def check_root() -> bool:
    return os.geteuid() == 0
def ensure_root() -> None:
    if not check_root():
            if cmd[0].startswith("sudo"):
            env = os.environ.copy()
            if os.environ.get("VIRTUAL_ENV"):
                nyord_vpn_path = os.path.join(
                if os.path.exists(nyord_vpn_path):
            console.print(
            if logger.level("DEBUG").no <= logger.level("INFO").no:
                logger.debug(f"Running command: {' '.join(args)}")
            subprocess.run(args, env=env, check=True)
            sys.exit(0)
            console.print("[red]Error: Admin privileges required.[/red]")
            console.print("[yellow]Run the command again with sudo:[/yellow]")
            console.print(f"[blue]sudo -E {' '.join(sys.argv)}[/blue]")
                logger.debug(f"Command failed with error: {e}")
            sys.exit(1)
def is_process_running(process_id: int) -> bool | None:
        os.kill(process_id, 0)
def ensure_data_dir() -> None:
    DATA_DIR.mkdir(parents=True, exist_ok=True)
ensure_data_dir()
    with open(COUNTRY_IDS_FILE) as f:
        NORDVPN_COUNTRY_IDS: dict[str, str] = json.load(f)
def save_vpn_state(state: dict) -> None:
        if STATE_FILE.exists():
            with contextlib.suppress(json.JSONDecodeError):
                existing = json.loads(STATE_FILE.read_text())
        if not state.get("connected") and state.get("current_ip"):
        elif state.get("connected") and state.get("current_ip"):
            if not state.get("normal_ip") and existing.get("normal_ip"):
                state["normal_ip"] = existing.get("normal_ip")
        state["timestamp"] = time.time()
        temp_state = STATE_FILE.with_suffix(".tmp")
        temp_state.write_text(json.dumps(state, indent=2))
        temp_state.chmod(0o600)
        temp_state.replace(STATE_FILE)
            logger.debug(f"Saved state to {STATE_FILE}: {json.dumps(state, indent=2)}")
        logger.warning(f"Failed to save VPN state: {e}")
def load_vpn_state() -> dict:
                state = json.loads(STATE_FILE.read_text())
                    logger.debug(
                        f"Loaded state from {STATE_FILE}: {json.dumps(state, indent=2)}"
                if time.time() - state.get("timestamp", 0) < 300:
                    "normal_ip": state.get("normal_ip"),
                    "timestamp": time.time(),
                logger.warning(f"Failed to parse state file: {e}")
        logger.warning(f"Failed to load VPN state: {e}")

================
File: src/nyord_vpn/__init__.py
================


================
File: src/nyord_vpn/__main__.py
================
console = Console()
load_dotenv()
class CLI:
    def __init__(self, verbose: bool = False) -> None:
            username = os.getenv("NORD_USER") or os.getenv("NORDVPN_LOGIN")
            password = os.getenv("NORD_PASSWORD") or os.getenv("NORDVPN_PASSWORD")
                console.print("[red]Error: Missing credentials[/red]")
                console.print("Please set the following environment variables:")
                console.print("  NORD_USER or NORDVPN_LOGIN")
                console.print("  NORD_PASSWORD or NORDVPN_PASSWORD")
                sys.exit(1)
            self.client = Client(username, password, verbose=verbose)
            console.print(f"[red]Error:[/red] {e}")
    def go(self, country_code: str) -> None:
        check_root()
            self.client.go(country_code)
    def bye(self) -> None:
            self.client.bye()
    def info(self) -> None:
            self.client.info()
    def update(self) -> None:
            fetch_countries()
            console.print("[green]Successfully updated country information[/green]")
            console.print(f"[red]Error updating country information:[/red] {e}")
def main() -> None:
        fire.Fire(CLI)
    main()

================
File: src/nyord_vpn/exceptions.py
================
class NyordVPNError(Exception):
    def __init__(
        super().__init__(self._format_message())
    def _format_message(self) -> str:
class VPNError(NyordVPNError):
        super().__init__(message, details, cause)
class CredentialsError(NyordVPNError):
class ConnectionError(NyordVPNError):
class DisconnectionError(NyordVPNError):
class ServerNotFoundError(NyordVPNError):
class VPNConfigError(VPNError):
class VPNServerError(NyordVPNError):
class VPNAuthenticationError(VPNError):
class VPNTimeoutError(NyordVPNError):
class VPNProcessError(VPNError):
class VPNConnectionError(VPNError):
class VPNDisconnectionError(VPNError):

================
File: tests/integration/__init__.py
================


================
File: tests/integration/test_config_loading.py
================
async def test_file_loading(temp_dir) -> None:
        "password": TEST_PASSWORD.get_secret_value(),
    config_file.write_text(json.dumps(config_data))
    client = VPNClient.from_file(config_file)
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.config_dir == Path("custom/config/dir").resolve()
    config = VPNConfig.from_file(config_file)
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert config.config_dir == Path("custom/config/dir").resolve()
async def test_environment_loading_unprefixed(monkeypatch) -> None:
    monkeypatch.setenv("NORD_USER", TEST_USERNAME)
    monkeypatch.setenv("NORD_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Norway")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "4")
    client = VPNClient.from_env()
async def test_environment_loading_prefixed(monkeypatch) -> None:
    monkeypatch.setenv("NORDVPN_USERNAME", TEST_USERNAME)
    monkeypatch.setenv("NORDVPN_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Sweden")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "5")
async def test_environment_loading_precedence(monkeypatch) -> None:
    monkeypatch.setenv("NORD_USER", "unprefixed_user")
    monkeypatch.setenv("NORD_PASSWORD", "unprefixed_pass")
    monkeypatch.setenv("NORDVPN_USERNAME", "prefixed_user")
    monkeypatch.setenv("NORDVPN_PASSWORD", "prefixed_pass")
    assert client.config.password.get_secret_value() == "unprefixed_pass"
async def test_default_values() -> None:
    config = VPNConfig(username="test", password="test")
    assert config.password.get_secret_value() == "test"
    assert config.config_dir == Path.home() / ".cache" / "nyord-vpn"
    client = VPNClient(username="test", password="test")
    assert client.config.password.get_secret_value() == "test"
    assert client.config.config_dir == Path.home() / ".cache" / "nyord-vpn"
async def test_config_file_precedence(temp_dir, monkeypatch) -> None:
    monkeypatch.setenv("NORD_USER", "env_user")
    monkeypatch.setenv("NORD_PASSWORD", "env_pass")
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "45")
    client = VPNClient.from_file(
        password=TEST_PASSWORD.get_secret_value(),
        client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
        config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
async def test_config_validation(temp_dir) -> None:
    with pytest.raises(ValueError, match="ensure this value is greater than 0"):
        VPNConfig.from_file(config_file)
    with pytest.raises(ValueError, match="Failed to setup config directory"):
    with pytest.raises(ValueError, match="Field required"):
def test_load_from_file(tmp_path: Path) -> None:
    config_path.write_text(json.dumps(config_data))
    client = VPNClient(config_file=config_path)
    config = VPNConfig.from_file(config_path)
def test_load_from_env(monkeypatch) -> None:
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "30")
    client = VPNClient()  # Will load from env by default
    config = VPNConfig.from_env()
def test_direct_initialization() -> None:
    config = VPNConfig(
    client = VPNClient(
def test_invalid_config_file(tmp_path: Path) -> None:
    with pytest.raises(FileNotFoundError):
        VPNConfig.from_file(tmp_path / "nonexistent.json")
    invalid_path.write_text("invalid json content")
    with pytest.raises(json.JSONDecodeError):
        VPNConfig.from_file(invalid_path)
    empty_path.write_text("{}")
    with pytest.raises(ValueError):
        VPNConfig.from_file(empty_path)
def test_invalid_environment(monkeypatch) -> None:
        VPNConfig.from_env()
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "invalid")

================
File: tests/integration/test_connection.py
================
async def test_connection_success(
        await client.connect()
        status = await client.status()
    mock_client.primary_api.connect.side_effect = VPNError("Primary API failed")
async def test_connection_failure(
    mock_client.fallback_api.connect.side_effect = VPNError("Fallback API failed")
    with pytest.raises(VPNConnectionError, match="Both primary and fallback failed"):
    mock_aiohttp_session.get.side_effect = asyncio.TimeoutError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
    mock_subprocess.side_effect = Exception("Subprocess error")
async def test_country_selection(
        await client.connect("Test Country")
    mock_client.primary_api.connect.side_effect = VPNError("Invalid country")
    mock_client.fallback_api.connect.side_effect = VPNError("Invalid country")
    with pytest.raises(VPNConnectionError, match="Invalid country"):
            await client.connect("Invalid Country")

================
File: tests/integration/test_errors.py
================
async def test_network_errors(
    mock_aiohttp_session.get.side_effect = asyncio.TimeoutError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
            await client.connect()
    mock_aiohttp_session.get.side_effect = ConnectionRefusedError()
    mock_aiohttp_session.get.side_effect = Exception("DNS resolution failed")
    mock_aiohttp_session.get.side_effect = Exception("SSL verification failed")
async def test_subprocess_errors(
    mock_subprocess.side_effect = FileNotFoundError("openvpn not found")
    with pytest.raises(VPNConfigError):
    mock_subprocess.side_effect = subprocess.SubprocessError("OpenVPN error")
    with pytest.raises(VPNConnectionError):
async def test_configuration_errors(
    with pytest.raises(VPNConfigError, match="Field required"):
        VPNClient()
    config_file.write_text("invalid = toml [ content")
    with pytest.raises(VPNConfigError, match="Failed to load configuration"):
        VPNClient(config_file=config_file)
        VPNClient(config_file=temp_dir / "nonexistent.toml")
    config_file.write_text(
    with pytest.raises(VPNConfigError, match="Failed to setup config directory"):
async def test_api_errors(
        json.JSONDecodeError("Invalid JSON", "{", 0)
async def test_error_recovery(
        asyncio.TimeoutError(),  # First attempt fails
        MagicMock(  # Second attempt succeeds
            json=AsyncMock(
        result = await client.connect()
        status = await client.status()
        Exception("First attempt failed"),  # First attempt fails
            communicate=AsyncMock(return_value=(b"Success", b"")),
async def test_invalid_credentials() -> None:
    client = VPNClient(username="invalid", password=TEST_PASSWORD.get_secret_value())
async def test_network_errors() -> None:
    client = VPNClient(
        password=TEST_PASSWORD.get_secret_value(),
    with pytest.raises(VPNError):
        await client.status()
        await client.list_countries()
async def test_timeout_handling(tmp_path: Path) -> None:
        "password": TEST_PASSWORD.get_secret_value(),
    config_path.write_text(json.dumps(config_data))
    client = VPNClient(config_file=config_path)
async def test_retry_behavior(tmp_path: Path) -> None:
async def test_fallback_behavior() -> None:
    assert await client.connect() is True
    await client.disconnect()
async def test_invalid_country() -> None:
        await client.connect("Invalid Country")
        await client.connect("")
async def test_cleanup_after_error(
    mock_client.primary_api.connect.side_effect = VPNError("Connection failed")
    mock_client.fallback_api.connect.side_effect = VPNError("Connection failed")
    status = mock_client.status()

================
File: tests/integration/test_validation_integration.py
================
@pytest.fixture(autouse=True)
def clear_env():
    os.environ.pop("NORD_USER", None)
    os.environ.pop("NORD_PASSWORD", None)
def test_invalid_credentials_njord() -> None:
    with pytest.raises(VPNError, match="Missing credentials"):
        NjordVPNClient()
def test_invalid_credentials_legacy() -> None:
        LegacyVPNClient()
def test_invalid_country_njord() -> None:
    with pytest.raises(VPNError):
        client = NjordVPNClient()
        client.connect("Invalid Country")
def test_invalid_country_legacy() -> None:
        client = LegacyVPNClient()

================
File: tests/__init__.py
================


================
File: tests/conftest.py
================
def mock_env_credentials(monkeypatch) -> None:
    monkeypatch.setenv("NORD_USER", "test_user")
    monkeypatch.setenv("NORD_PASSWORD", "test_pass")
def mock_openvpn():
    with patch("subprocess.run") as mock_run:
def mock_requests():
    with patch("requests.get") as mock_get:
def mock_process():
    with patch("subprocess.Popen") as mock_popen:
def mock_client(mock_env_credentials, mock_openvpn, mock_requests, mock_process):
    with patch("nyord_vpn.api.legacy.LegacyVPNClient") as mock_legacy:
        client = VPNClient()
def temp_config_file(tmp_path):
    config_file.write_text(json.dumps(config))
def mock_ip_info():

================
File: tests/test_client.py
================
def test_client_connect(mock_client) -> None:
    result = mock_client.connect("Test Country")
    status = mock_client.status()
def test_client_disconnect(mock_client) -> None:
    mock_client.connect("Test Country")
    result = mock_client.disconnect()
def test_client_list_countries(mock_client) -> None:
    countries = mock_client.list_countries()
    assert isinstance(countries, list)
    assert len(countries) > 0
    assert all(isinstance(c, dict) for c in countries)
    assert all("name" in c and "code" in c for c in countries)
def test_client_error_handling(mock_client, mocker) -> None:
    mocker.patch.object(
        side_effect=VPNError("Test error"),
    with pytest.raises(VPNError, match="Test error"):
async def test_client_context_manager(mock_client) -> None:
        result = await client.connect("Test Country")
        status = await client.status()
    status = await mock_client.status()

================
File: tests/test_legacy_api.py
================
def test_init(mock_env_credentials, mock_openvpn) -> None:
    api = LegacyVPNClient()
    assert api.username == os.getenv("NORD_USER")
    assert isinstance(api.password, str)
    assert api.password == os.getenv("NORD_PASSWORD")
def test_connect_success(
    assert api.connect() is True
def test_connect_failure(
    mock_process.side_effect = requests.RequestException("Failed to connect")
    with pytest.raises(VPNError, match="Failed to connect"):
        api.connect()
def test_disconnect_success(mock_env_credentials, mock_openvpn, mock_process) -> None:
    assert api.disconnect() is True
def test_status_connected(mock_env_credentials, mock_openvpn, mock_ip_info) -> None:
    status = api.status()
def test_list_countries(mock_env_credentials, mock_openvpn, mock_requests) -> None:
    countries = api.list_countries()
    assert len(countries) == 2
    assert all(isinstance(c, dict) for c in countries)
    assert all("name" in c and "code" in c for c in countries)
def test_openvpn_not_found(mock_env_credentials) -> None:
    with pytest.raises(VPNError, match="OpenVPN not found"):
        LegacyVPNClient()
def test_server_not_found(mock_env_credentials, mock_openvpn, mock_requests) -> None:
    with pytest.raises(VPNError, match="No servers found"):
        api.connect("invalid_country")
def test_config_download_error(
    mock_requests.side_effect = requests.RequestException("Failed to download")
    with pytest.raises(VPNError, match="Failed to download"):
def test_process_error(
    mock_process.side_effect = subprocess.SubprocessError("Process failed")
def test_api_credentials() -> None:

================
File: tests/test_package.py
================
def test_version() -> None:

================
File: tests/test_server_manager.py
================
def mock_api_client():
    client = MagicMock(spec=NordVPNAPIClient)
    client.logger = MagicMock()
def server_manager(mock_api_client):
    return ServerManager(mock_api_client)
def test_openvpn_tcp_validation(server_manager) -> None:
    assert server_manager._is_valid_server(server) is True
    assert server_manager._is_valid_server(server) is False
def test_server_filtering(server_manager, mock_api_client) -> None:
    cache = server_manager.get_servers_cache()
    servers = cache.get("servers", [])
    assert len(servers) == 2
    assert any(s["hostname"] == "tcp1.nordvpn.com" for s in servers)
    assert any(s["hostname"] == "tcp2.nordvpn.com" for s in servers)
    mock_api_client.logger.debug.assert_any_call(

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: cleanup.py
================
LOG_FILE = Path("CLEANUP.txt")
os.chdir(Path(__file__).parent)
def new() -> None:
    if LOG_FILE.exists():
        LOG_FILE.unlink()
def prefix() -> None:
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)
def suffix() -> None:
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
def log_message(message: str) -> None:
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with LOG_FILE.open("a") as f:
        f.write(log_line)
def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
        result = subprocess.run(cmd, check=check, capture_output=True, text=True)
            log_message(result.stdout)
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        return subprocess.CompletedProcess(cmd, 1, "", str(e))
def check_command_exists(cmd: str) -> bool:
        subprocess.run(["which", cmd], check=True, capture_output=True)
class Cleanup:
    def __init__(self) -> None:
        self.workspace = Path.cwd()
    def _print_header(self, message: str) -> None:
        log_message(f"\n=== {message} ===")
    def _check_required_files(self) -> bool:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
    def _generate_tree(self) -> None:
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            tree_result = run_command(
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)
            log_message("\nProject structure:")
            log_message(tree_text)
            log_message(f"Failed to generate tree: {e}")
    def _git_status(self) -> bool:
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())
    def _venv(self) -> None:
        log_message("Setting up virtual environment")
            run_command(["uv", "venv"])
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                log_message("Virtual environment created and activated")
                log_message("Virtual environment created but activation failed")
            log_message(f"Failed to create virtual environment: {e}")
    def _install(self) -> None:
        log_message("Installing package with all extras")
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
            log_message(f"Failed to install package: {e}")
    def _run_checks(self) -> None:
            log_message(">>>\n>>> %s...\n>>> TODO: Check the errors!\n>>>" % "Running code fixes")
            run_command(
            log_message(">>>\n>>> %s...\n>>> TODO: Check the errors!\n>>>" % "Running type checks")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)
            log_message(">>>\n>>> %s...\n>>> TODO: Check the errors!\n>>>" % "Checking for _potentially_ unused code")
            run_command(["python", "-m", "vulture", "src"], check=False)
            log_message(">>>\n>>> %s...\n>>> TODO: Try to fix the problems, always think whether the test actually makes sense, then adjust the implementation or the test!\n>>>" % "Running tests")
            run_command(["python", "-m", "pytest", "tests"], check=False)
            log_message(">>>\n>>> %s...\n>>> TODO: Check the output!\n>>>" % "Running repomix analysis")
            run_command([
            log_message("All checks completed")
            log_message(f"Failed during checks: {e}")
    def status(self) -> None:
        prefix()  # Add README.md content at start
        self._print_header("Current Status")
        self._check_required_files()
        self._generate_tree()
        result = run_command(["git", "status"], check=False)
        self._print_header("Environment Status")
        self._install()
        self._run_checks()
        suffix()  # Add TODO.md content at end
    def venv(self) -> None:
        self._print_header("Virtual Environment Setup")
    def install(self) -> None:
        self._print_header("Package Installation")
    def update(self) -> None:
        self.status()
        if self._git_status():
            log_message("Changes detected in repository")
                run_command(["git", "add", "."])
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
                log_message(f"Failed to commit changes: {e}")
            log_message("No changes to commit")
    def push(self) -> None:
        self._print_header("Pushing Changes")
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
            log_message(f"Failed to push changes: {e}")
def print_usage() -> None:
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")
def main() -> NoReturn:
    new()  # Clear log file
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    cleanup = Cleanup()
            cleanup.status()
            cleanup.venv()
            cleanup.install()
            cleanup.update()
            cleanup.push()
        log_message(f"Error: {e}")
    print(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Explicitly exit to satisfy NoReturn type
    main()

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.toml
================
# Package configuration
[package]
include_cli = true        # Include CLI boilerplate
include_logging = true    # Include logging setup
use_pydantic = true      # Use Pydantic for data validation
use_rich = true          # Use Rich for terminal output

[features]
mkdocs = false           # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows

================
File: pyproject.toml
================
# this_file: pyproject.toml
[build-system]
requires = ["setuptools>=45", "setuptools-scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "nyord-vpn"
version = "0.1.0"
description = "NordVPN client with API fallback support"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT"}
keywords = ["vpn", "nordvpn", "security"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "njord>=0.0.1",
    "tenacity>=8.0.0",
    "backoff>=2.0.0",
    "rich>=13.4.2",
    "fire>=0.7.0",
    "pydantic>=2.10.6",
    "pydantic-settings>=2.8.0",
    "requests>=2.31.0",
    "keyring>=24.2.0",
    "pycountry>=24.6.1",
    "psutil>=5.9.5",
    "python-dotenv>=1.0.0",
    "aiohttp>=3.11.0",
    "cryptography>=42.0.0",
    "black>=23.7.0",
    "bleach>=6.0.0",
    "build>=0.10.0",
    "certifi>=2023.5.7",
    "charset-normalizer>=3.2.0",
    "click>=8.1.5",
    "docutils>=0.20.1",
    "idna>=3.4",
    "importlib-metadata>=6.8.0",
    "jaraco-classes>=3.3.0",
    "markdown-it-py>=3.0.0",
    "mdurl>=0.1.2",
    "more-itertools>=9.1.0",
    "mypy-extensions>=1.0.0",
    "packaging>=23.1",
    "pathspec>=0.11.1",
    "pkginfo>=1.9.6",
    "platformdirs>=3.9.1",
    "pygments>=2.15.1",
    "pyproject-hooks>=1.0.0",
    "readme-renderer>=40.0",
    "requests-toolbelt>=1.0.0",
    "rfc3986>=2.0.0",
    "six>=1.16.0",
    "tomli>=2.0.1",
    "twine>=4.0.2",
    "typing-extensions>=4.7.1",
    "urllib3>=2.0.3",
    "webencodings>=0.5.1",
    "zipp>=3.16.2",
    "loguru>=0.7.3",
    "vulture>=2.14",
]

[project.optional-dependencies]
dev = [
    "pre-commit>=3.6.0",
    "ruff>=0.9.7",
    "mypy>=1.0.0",
    "pyupgrade>=3.19.0",
    "autoflake>=2.0.0",
    "isort>=5.10.1",
    "vulture>=2.10",
]

test = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.25.0",
    "pytest-mock>=3.12.0",
    "pytest-timeout>=2.3.0",
    "pytest-xdist>=3.5.0",
]

[project.scripts]
nyord-vpn = "nyord_vpn.__main__:main"

[tool.setuptools]
package-dir = {"" = "src"}
packages = ["nyord_vpn"]
package-data = {"nyord_vpn" = ["data/*.json"]}

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/nyord-vpn#readme"
Issues = "https://github.com/twardoch/nyord-vpn/issues"
Source = "https://github.com/twardoch/nyord-vpn"

[tool.coverage.paths]
nyord_vpn = ["src/nyord_vpn", "*/nyord-vpn/src/nyord_vpn"]
tests = ["tests", "*/nyord-vpn/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
]

[tool.coverage.run]
source_pkgs = ["nyord_vpn", "tests"]
branch = true
parallel = true
omit = [
    "src/nyord_vpn/__about__.py",
]

[tool.hatch.build.hooks.vcs]
version-file = "src/nyord_vpn/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/nyord_vpn"]

[tool.hatch.envs.default]
dependencies = [
]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests {args:tests}"
type-check = "mypy src/nyord_vpn tests"
lint = ["ruff check src/nyord_vpn tests", "ruff format --respect-gitignore src/nyord_vpn tests"]
fix = ["ruff check  --fix --unsafe-fixes src/nyord_vpn tests", "ruff format --respect-gitignore src/nyord_vpn tests"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/nyord_vpn tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}", "vulture src"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}", "vulture src"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.25.0",
    "pytest-mock>=3.12.0",
    "pytest-timeout>=2.3.0",
    "pytest-xdist>=3.5.0",
]

[tool.hatch.envs.test.scripts]
test = "python -m pytest {args:tests}"
test-cov = "python -m pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests {args:tests}"
bench = "python -m pytest -v tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[tool.ruff]
target-version = "py310"
line-length = 88

[tool.ruff.lint]
select = [
    "A",
    "ANN",
    "ARG",
    "ASYNC",
    "B",
    "C",
    "C4",
    "C90",
    "COM",
    "D",
    "DOC",
    "DTZ",
    "E",
    "ERA",
    "EXE",
    "F",
    "FA",
    "FBT",
    "FIX",
    "FLY",
    "FURB",
    "I",
    "ICN",
    "INP",
    "ISC",
    "N",
    "NPY",
    "PD",
    "PERF",
    "PIE",
    "PL",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "PT",
    "PTH",
    "PYI",
    "Q",
    "RET",
    "RSE",
    "RUF",
    "S",
    "SIM",
    "SLF",
    "T",
    "TC",
    "TD",
    "TID",
    "TRY",
    "UP",
    "W",
    "YTT",
]
ignore = ["ARG001", "COM812", "D203", "D213", "E501", "I001", "RUF001", "PLR2004", "EXE003", "ISC001"]

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase --timeout=30 -n auto"
asyncio_mode = "strict"
asyncio_default_fixture_loop_scope = "function"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning",
    "ignore::pytest.PytestDeprecationWarning",
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "async_test: mark a test as an async test",
    "config: mark a test as a configuration test",
    "connection: mark a test as a connection test",
    "security: mark a test as a security test",
]
testpaths = ["tests"]
timeout = 30

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]

================
File: README.md
================
# nyord-vpn

nyord-vpn is a simple NordVPN client for macOS users. It provides an easy way to manage VPN connections. 

nyord-vpn is primarily designed for macOS, as it relies on OpenVPN, which is easily installable via Homebrew. However, with some modifications, it might be possible to use it on other platforms like Linux or Windows. Contributions to support additional platforms are welcome.

## Key Features

- **Simple and Reliable Connection Management:** Connect and disconnect from VPN with minimal hassle.
- **Support for Legacy OpenVPN and njord APIs:** Choose between different API versions for flexibility.
- **Country Selection:** Connect to servers in specific countries easily.
- **Status Monitoring:** Check the current status of your VPN connection.
- **Clear Error Messages:** Resolve issues quickly with informative error messages.
- **Minimal Dependencies:** Lightweight and easy to set up.

## Installation

To use nyord-vpn, you need to install some system requirements and the package itself.

### System Requirements

- macOS operating system
- OpenVPN installed

### Installing OpenVPN

Install OpenVPN using Homebrew:

```bash
brew install openvpn
```

### Installing nyord-vpn

Install the package using pip:

```bash
pip install nyord-vpn
```


## Configuration

Before using nyord-vpn, set your NordVPN credentials as environment variables:

```bash
export NORD_USER="your-username"
export NORD_PASSWORD="your-password"
```

Replace `"your-username"` and `"your-password"` with your actual NordVPN credentials.

## Usage

nyord-vpn can be used via the command line interface (CLI) or programmatically through its Python API.

### API Options

### CLI Commands

Here are the available CLI commands:

- **`nyord-vpn connect`**: Connects to a NordVPN server. Defaults to a server in the United States.
- **`nyord-vpn connect --country <country>`**: Connects to a server in the specified country. Replace `<country>` with the country name or code (e.g., `netherlands`).
- **`nyord-vpn --api njord connect`**: Uses the njord API to connect to the VPN.
- **`nyord-vpn --verbose connect`**: Connects to the VPN with verbose logging enabled for debugging.
- **`nyord-vpn status`**: Displays the current status of the VPN connection, including connection status, server, and IP address.
- **`nyord-vpn list-countries`**: Lists all available countries with NordVPN servers.
- **`nyord-vpn disconnect`**: Disconnects from the VPN.

**Note:** Some commands, such as connecting and disconnecting, may require sudo privileges. You might be prompted to enter your password.

### Python API

You can use nyord-vpn programmatically in Python:

```python
from nyord_vpn.core.factory import create_client

# Create a client (choose "legacy" or "njord")
client = create_client("legacy")

# Connect to VPN in a specific country
client.connect("netherlands")

# Check connection status
status = client.status()
print(f"Connected to {status['server']} ({status['ip']})")

# Disconnect from VPN
client.disconnect()
```

Ensure you have the necessary permissions to run OpenVPN when using the Python API.

## Development

To contribute to nyord-vpn or modify the code:

1. **Install dependencies:**

   ```bash
   pip install -r requirements.txt
   ```

2. **Install optional njord support:**

   ```bash
   pip install njord
   ```

3. **Run with debug logging:**

   ```bash
   NORD_USER="username" NORD_PASSWORD="password" nyord-vpn --verbose connect
   ```

For a full development setup, clone the repository, create a virtual environment, and install the package in editable mode:

```bash
git clone https://github.com/yourusername/nyord-vpn.git
cd nyord-vpn
python -m venv venv
source venv/bin/activate
pip install -e .
```

Replace `yourusername` with the actual repository owner.

## Error Handling and Troubleshooting

nyord-vpn provides clear error messages to help resolve issues. Common errors include:

- **`VPNCredentialsError`**: Missing or invalid credentials. Ensure `NORD_USER` and `NORD_PASSWORD` are set correctly.
- **`VPNConnectionError`**: Failed to connect or disconnect. Check your internet connection and try again.
- **`VPNConfigError`**: Configuration issues, such as missing OpenVPN. Install OpenVPN if not already installed.
- **`VPNServerError`**: Failed to get server information. Try again later or check your network connection.

### Troubleshooting Tips

- **"OpenVPN not found" error:** Install OpenVPN using `brew install openvpn`.
- **"Authentication failed" error:** Verify your NordVPN credentials in the environment variables.
- **"Failed to connect" error:** Check your internet connection or try a different country/server.
- **"No servers available" error:** Wait a few minutes and try again; this may be a temporary API issue.

### Security Considerations

- **Keep Credentials Secure:** Do not hardcode credentials; use environment variables or secure storage.
- **Update Regularly:** Keep nyord-vpn and dependencies up to date for security patches.
- **Monitor Connections:** Regularly check your connection status.
- **Use Strong Passwords:** Ensure your NordVPN account has a strong, unique password.

## Contributing

We welcome contributions to nyord-vpn! To contribute:

1. Fork the repository.
2. Create a feature branch for your changes.
3. Make your changes and commit them.
4. Submit a pull request with a clear description of your changes.

For issues or questions, open an issue on the [GitHub repository](https://github.com/yourusername/nyord-vpn).

## License

nyord-vpn is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

================
File: TODO.md
================
# TODO

Do it! Remember, keep it simple, effective, eyes on the goal!

### 0.1. Enhanced Server Selection

- [ ] Switch to v2/servers API for better efficiency:
  ```python
  def get_servers_cache() -> dict:
      """Fetch and cache full server list from v2/servers:
      1. Single API call to get all servers
      2. Cache for hour
      3. Local filtering by country/load/features
      """
  ```
- [ ] Implement fast server selection:
  ```python
  def select_fastest_server(country_code: str, servers: dict) -> str:
      """Select fastest server:
      1. Filter cached servers by country
      2. Take top 5 by load
      3. Parallel ping test
      4. Return fastest responding server
      """
  ```

### 0.2. Simplified Setup
- [ ] Create one-command initialization:
  ```bash
  nyord init  # Sets up everything needed
  ```
  - Validate OpenVPN installation
  - Create config directories
  - Set up credential storage
  - Test API connectivity
  - Generate initial config

### 0.3. API Usage Optimization
- [ ] Switch to https://api.nordvpn.com/v2/servers for server data fetching (the local "cached" file should be made compatible with the v2 format)
- [ ] Retire both https://api.nordvpn.com/v1/servers/countries and https://api.nordvpn.com/v1/servers/recommendations — the v2 API is better because we don't want a list of all countries in the world, just the ones that have servers :) 
  - Single API call instead of multiple v1 endpoints
  - Local filtering instead of multiple API requests
  - Simpler error handling (only one endpoint)

Keep it focused on these core improvements that directly enhance user experience.

### 0.4. Retry, switch gears

- [ ] Make sure that if the country is not specified, we choose the country randomly
- [ ] Implement a bool parameter "random" that chooses a random server (rather than "the fasterst") from the country 
- [ ] When we're connecting, we should retry connection once and if that's not successful, we should try another random server from the same country. See below for some ideas. 



### 0.5. ANALYSIS FOR "RETRY, SWITCH GEARS"

Out‐of‐the‐box, both re‑engage and tenacity are designed to re‑invoke your function with the same arguments on each attempt. They don’t automatically “step through” a list of alternative parameter values. 

That said, with tenacity you can customize the retry behavior by using callback hooks (such as the “after” hook) to modify the function’s keyword arguments between attempts. For example, you can write a small helper like this:

```python
from tenacity import retry, stop_after_attempt, RetryCallState

def update_B(new_value):
    def after_callback(retry_state: RetryCallState):
        # Update the value for the parameter "B" for the next attempt
        retry_state.kwargs['B'] = new_value
    return after_callback

# First, try with B=5 (the default).
# After two failures, update B to 7.
@retry(stop=stop_after_attempt(2), after=update_B(7))
def func(A, B=5):
    print(f"Attempt with B={B}")
    # Example failure condition
    if B < 11:
        raise Exception("Not high enough!")
    return f"Success with B={B}"

try:
    result = func("some_value")
except Exception as e:
    # You might even chain another retry that sets B to 11 after another round
    print("Initial retry block failed:", e)
    # You can re‑decorate or call a wrapper that uses the next parameter value.
    # For example, you could write a loop that tries B from a list [5,7,11]
    for new_B in [7, 11]:
        try:
            result = func("some_value", B=new_B)
            break
        except Exception:
            continue
    else:
        result = None

print("Result:", result)
```

In this example, the tenacity decorator’s “after” hook is used to modify the value of B for the next attempt. (A similar idea was discussed on Stack Overflow, where an answer demonstrated using an after‑callback to change a parameter dynamically.) citeturn0search0

If you need a more complex sequence (like “try with B=5, if that fails twice then use B=7, then 11”), you might either chain multiple decorators or, more simply, write a custom wrapper that iterates over your list of values and calls your function accordingly.

In summary, while neither library provides a one‑line decorator that automatically “steps” through alternative argument values, tenacity’s flexible callback hooks let you implement that behavior with a bit of extra code.

Both the **Re-Engage** and **Tenacity** libraries provide decorators for retrying functions until success or failure, but they do not natively support the specific use case of trying different arguments upon failure. However, you can implement this functionality using a combination of decorators and custom logic.

## 1. Overview of Libraries

### 1.1. Re-Engage
- **Re-Engage** is a fork of the original backoff library, designed for retrying function calls with decorators like `@backoff.on_exception` and `@backoff.on_predicate`. These decorators allow you to specify conditions under which to retry a function based on exceptions or return values[1].

### 1.2. Tenacity
- **Tenacity** is a general-purpose retrying library that simplifies adding retry behavior to functions. It allows for extensive customization through decorators like `@retry`, which can be configured with various parameters such as maximum attempts, delay between retries, and conditions for retrying[2].

## 2. Implementing Dynamic Argument Retrying

To achieve the desired behavior of trying different arguments after failures, you can create a custom decorator that wraps your function and manages the argument variations. Here’s an example implementation:

```python
from tenacity import retry, stop_after_attempt

def dynamic_retry(args_list):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for args in args_list:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"Failed with args {args}: {e}")
            raise Exception("All attempts failed.")
        return wrapper
    return decorator

@dynamic_retry([(5,), (7,), (11,)])  # List of argument tuples
def my_function(b):
    # Simulate a function that may fail
    if b != 11:  # Let's say it fails unless b is 11
        raise ValueError("Failed!")
    return "Success!"

# Usage
result = my_function(5)  # This will try 5, then 7, then 11.
print(result)  # Outputs: Success!
```

### 2.1. Explanation:
- The `dynamic_retry` decorator takes a list of argument tuples.
- The `wrapper` function iterates over these arguments, attempting to call the target function.
- If an exception occurs, it catches the error, logs it, and moves on to the next set of arguments.
- If all attempts fail, it raises an exception.

## 3. Conclusion

While neither Re-Engage nor Tenacity directly supports dynamically changing function arguments upon failure out-of-the-box, you can implement this functionality using custom decorators. This approach allows you to maintain flexibility in your retry logic while leveraging the robust features provided by existing libraries.

Based on the search results and your specific question about retrying with different arguments, I'll provide a comprehensive answer about implementing such functionality.

Let me break this down step by step:

### 3.1. Current State of Retry Libraries

The common retry libraries like `tenacity` and `re-engage` focus primarily on retrying with the same arguments. While they're powerful for basic retry scenarios, they don't directly support changing arguments between retries [0].

### 3.2. Custom Solution Implementation

Here's a custom decorator implementation that allows retrying with different arguments:

```python
from functools import wraps
from typing import List, Any, Callable
import time

def retry_with_different_args(arg_sequences: List[Any], delay: int = 1):
    """
    Retry decorator that attempts the function with different argument values.
    
    Args:
        arg_sequences: List of values to try for the decorated function's first argument
        delay: Delay between retries in seconds
    """
    def decorator(func: Callable):
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            
            # Replace the first argument with each value in the sequence
            for arg_value in arg_sequences:
                try:
                    new_args = (arg_value,) + args[1:]
                    return func(*new_args, **kwargs)
                except Exception as e:
                    last_exception = e
                    print(f"Attempt with value {arg_value} failed: {str(e)}")
                    time.sleep(delay)
            
            # If we get here, all attempts failed
            raise last_exception or Exception("All retry attempts failed")
            
        return wrapper
    return decorator
```

Example usage:

```python
# Example using the decorator
@retry_with_different_args([5, 7, 11])
def divide_number(divisor: int, number: int = 100):
    if divisor == 7:
        raise ValueError("Don't like 7")
    return number / divisor

# This will try with divisor=5, then 7, then 11
try:
    result = divide_number(5, number=100)
    print(f"Success: {result}")
except Exception as e:
    print(f"Final failure: {e}")
```

### 3.3. Key Points to Consider

1. **Flexibility**: This implementation allows you to specify a sequence of values to try for a specific argument [0].

2. **Error Handling**: Each attempt is wrapped in a try-except block, allowing you to catch and handle specific exceptions [0].

3. **Delay Control**: You can specify delays between attempts to prevent overwhelming systems [0].

### 3.4. Best Practices

1. **Specific Exceptions**: Always catch specific exceptions rather than using a broad Exception catch.

2. **Logging**: Include proper logging to track retry attempts and failures.

3. **Timeout Consideration**: Consider implementing an overall timeout mechanism.

4. **State Management**: Be careful with stateful operations when retrying with different arguments.

### 3.5. Alternative Approach Using Tenacity

While tenacity doesn't directly support changing arguments, you can achieve similar functionality by combining it with a custom retry strategy:

```python
from tenacity import retry, stop_after_attempt
from functools import partial

def retry_sequence(func, arg_sequences):
    for arg in arg_sequences:
        try:
            return func(arg)
        except Exception:
            continue
    raise Exception("All attempts failed")

# Usage example
@retry(stop=stop_after_attempt(1))
def wrapped_function(x):
    return retry_sequence(some_function, [5, 7, 11])
```

This solution provides a way to work with existing retry libraries while adding the functionality to try different arguments, though it's not as elegant as the custom decorator approach.



================================================================
End of Codebase
================================================================
