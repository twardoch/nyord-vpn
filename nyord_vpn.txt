This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: _private, .specstory, .venv
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    nyord-vpn.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  nyord_vpn/
    core/
      api.py
      base.py
      client.py
    data/
      countries.json
      country_ids.json
    network/
      country.py
      server.py
      vpn.py
    scripts/
      __init__.py
      update_countries.py
    storage/
      models.py
      state.py
    utils/
      connection.py
      templates.py
      utils.py
    __init__.py
    __main__.py
    exceptions.py
tests/
  integration/
    __init__.py
    test_config_loading.py
    test_connection.py
    test_errors.py
    test_validation_integration.py
  __init__.py
  conftest.py
  test_client.py
  test_legacy_api.py
  test_package.py
.gitignore
.pre-commit-config.yaml
LICENSE
package.toml
pyproject.toml
README.md
test_auth.txt
TODO.md

================================================================
Files
================================================================

================
File: .cursor/rules/nyord-vpn.mdc
================
---
description: nyord-vpn
globs: 
---
# nyord-vpn

A modern Python client for NordVPN with automatic API fallback support, providing both a CLI interface and a Python library.

```bash
# Install system requirements first
brew install openvpn  # macOS
sudo apt install openvpn  # Ubuntu/Debian
sudo dnf install openvpn  # Fedora/RHEL

# Then install and use the package
pip install nyord-vpn
export NORD_USER="username" NORD_PASSWORD="password"
nyord-vpn connect de  # Connect to a German VPN
nyord-vpn status  # Check status
nyord-vpn disconnect  # Disconnect
```

## DEVELOPMENT

After each set of changes, update @TODO.md with what you've done (`- [x] `). Upgrade priorities for NEXT TODO (`- [!]`), re-think the normal TODO (`- [ ] `)

Periodically do:

```
uv venv; source .venv/bin/activate; uv pip install -e .[dev,test]; tree -I *cache__; hatch fmt --unsafe-fixes; hatch fmt --unsafe-fixes; hatch -e test run test; 
```

and react to the results. Use `uv pip...` instead of `pip...` if needed.

================
File: .github/workflows/push.yml
================
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/nyord-vpn
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/nyord_vpn/core/api.py
================
"""NordVPN API client for basic data retrieval and API interactions."""

import time

from loguru import logger
from requests import get, RequestException

from src.nyord_vpn.network.country import get_cached_countries, cache_countries
from src.nyord_vpn.storage.models import City, Country, CountryCache
from src.nyord_vpn.utils.utils import API_HEADERS, CACHE_FILE


class NordVPNAPIClient:
    """Base client for NordVPN API interactions."""

    BASE_API_URL: str = "https://api.nordvpn.com"
    BASE_API_V1_URL: str = f"{BASE_API_URL}/v1"
    BASE_API_V2_URL: str = f"{BASE_API_URL}/v2"

    def __init__(self, username: str, password: str, verbose: bool = False):
        """
        Initialize the NordVPN API client.

        This constructor sets up the basic configuration for interacting with the NordVPN API,
        including authentication credentials and logging preferences.

        Args:
            username (str): The NordVPN account username for authentication.
            password (str): The NordVPN account password for authentication.
            verbose (bool, optional): Flag to enable verbose logging. Defaults to False.

        Attributes:
            username (str): Stores the provided NordVPN username.
            password (str): Stores the provided NordVPN password.
            verbose (bool): Indicates whether verbose logging is enabled.
            logger: Logger instance for output logging.
            cache_file: File path for caching API responses.

        Note:
            This method doesn't return any value but initializes the instance attributes.
        """
        self.username = username
        self.password = password
        self.verbose = verbose
        self.logger = logger
        self.cache_file = CACHE_FILE
    def list_countries(self, use_cache: bool = True) -> list[Country]:
        """
        Fetch a list of available server countries from the NordVPN API.
    
        This function attempts to retrieve a list of countries where NordVPN servers are available.
        If the API request fails, it falls back to cached data if available.
    
        Args:
            use_cache (bool, optional): Flag to determine whether to use cached data. Defaults to True.
    
        Returns:
            list[Country]: A list of Country objects containing information about available server countries.
                           Returns an empty list if both API request and cache retrieval fail.
    
        Raises:
            RequestException: If there's an error in making the API request.
    
        Note:
            - The function updates the cache with the latest data upon successful API request.
            - If the API request fails, it attempts to retrieve data from the cache.
        """
        try:
            url = f"{self.BASE_API_URL}/servers/countries"
            response = get(url, headers=API_HEADERS, timeout=10)
            response.raise_for_status()
            countries: list[Country] = response.json()
    
            cache_data: CountryCache = {
                "countries": countries,
                "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            }
            cache_countries(cache_data)
            return countries
    
        except RequestException as e:
            self.logger.warning(f"Failed to fetch countries: {e}")
            cached = get_cached_countries()
            if cached:
                return cached["countries"]
            return []

    def get_country_by_code(self, code: str) -> Country | None:
        """
        Retrieve country information based on the provided country code.

        This function searches for a country in the list of available countries
        using the specified country code. The search is case-insensitive.

        Args:
            code (str): The two-letter country code to search for.

        Returns:
            Country | None: A dictionary containing country information if found,
                            or None if no matching country is found.

        Note:
            The country code is converted to uppercase before searching.
        """
        code = code.upper()
        for country in self.list_countries():
            if country["code"] == code:
                return country
        return None

    def get_country_by_name(self, name: str) -> Country | None:
        """Get country info by name."""
        name = name.lower()
        for country in self.list_countries():
            if country["name"].lower() == name:
                return country
        return None

    def get_available_locations(self) -> list[str]:
        """Get formatted list of available locations."""
        locations = []
        for country in sorted(self.list_countries(), key=lambda x: x["name"]):
            total_servers = country["serverCount"]
            locations.append(
                f"{country['name']} ({country['code'].lower()}) - {total_servers} servers"
            )
            for city in sorted(country["cities"], key=lambda x: x["name"]):
                locations.append(f"  {city['name']} - {city['serverCount']} servers")
        return locations

    def get_best_city(self, country_code: str) -> City | None:
        """Get best city in country based on hub score."""
        country = self.get_country_by_code(country_code)
        if not country:
            return None
        sorted_cities = sorted(
            country["cities"],
            key=lambda x: (x["hub_score"], x["serverCount"]),
            reverse=True,
        )
        return sorted_cities[0] if sorted_cities else None

    def test_api_connectivity(self) -> bool:
        """
        Test the connection to the NordVPN API.
    
        This function attempts to make a GET request to the NordVPN API's servers endpoint
        to verify if the API is accessible and responding correctly.
    
        Returns:
            bool: True if the API is accessible and responds successfully, False otherwise.
    
        Note:
            If the verbose flag is set to True, any connection errors will be logged.
        """
        try:
            response = get(
                f"{self.BASE_API_V2_URL}/servers", headers=API_HEADERS, timeout=5
            )
            response.raise_for_status()
            return True
        except Exception as e:
            if self.verbose:
                self.logger.error(f"API connectivity test failed: {e}")
            return False

================
File: src/nyord_vpn/core/base.py
================
"""Base NordVPN client implementation.

This module contains the base NordVPN client class that handles:
- Country list management
- Cache handling
- Location lookup
- API interaction

This class is extended by the main Client class to add connection functionality.
"""

import json
import sys
import time

import requests
from loguru import logger

from src.nyord_vpn.network.country import get_cached_countries, cache_countries
from src.nyord_vpn.storage.models import City, Country, CountryCache
from src.nyord_vpn.utils.utils import CACHE_FILE, API_HEADERS

# Fallback data in case API is unreachable
FALLBACK_DATA: CountryCache = {
    "countries": [
        {
            "cities": [
                {
                    "dns_name": "new-york",
                    "hub_score": 0,
                    "id": 8971718,
                    "latitude": 40.7141667,
                    "longitude": -74.0063889,
                    "name": "New York",
                    "serverCount": 529,
                }
            ],
            "code": "US",
            "id": 228,
            "name": "United States",
            "serverCount": 529,
        },
        {
            "cities": [
                {
                    "dns_name": "london",
                    "hub_score": 0,
                    "id": 2989907,
                    "latitude": 51.514125,
                    "longitude": -0.093689,
                    "name": "London",
                    "serverCount": 785,
                }
            ],
            "code": "GB",
            "id": 227,
            "name": "United Kingdom",
            "serverCount": 785,
        },
        {
            "cities": [
                {
                    "dns_name": "frankfurt",
                    "hub_score": 0,
                    "id": 2215709,
                    "latitude": 50.116667,
                    "longitude": 8.683333,
                    "name": "Frankfurt",
                    "serverCount": 301,
                }
            ],
            "code": "DE",
            "id": 81,
            "name": "Germany",
            "serverCount": 301,
        },
    ],
    "last_updated": "2024-02-23T00:00:00Z",
}


class NordVPNClient:
    """Base NordVPN client for managing country data and API interactions."""

    BASE_API_URL: str = "https://api.nordvpn.com/v1"

    def __init__(self, username: str, password: str, verbose: bool = False):
        """Initialize NordVPN client.

        Args:
            username: NordVPN username
            password: NordVPN password
            verbose: Whether to enable verbose logging
        """
        self.username = username
        self.password = password
        self.verbose = verbose
        self.logger = logger
        self.cache_file = CACHE_FILE
        self.countries = self._load_countries()
        self.logger.add(sys.stdout, level="DEBUG" if self.verbose else "INFO")

    def _load_countries(self) -> list[Country]:
        """Load countries from cache or fallback data."""
        try:
            with open(self.cache_file) as f:
                cache_data: CountryCache = json.load(f)
                return cache_data["countries"]
        except (FileNotFoundError, json.JSONDecodeError) as e:
            self.logger.warning(f"Failed to load cache: {e}. Using fallback data.")
            return FALLBACK_DATA["countries"]

    def get_country_by_code(self, code: str) -> Country | None:
        """Get country by its code.

        Args:
            code: Two-letter country code (e.g. 'us', 'uk')
        """
        code = code.upper()
        for country in self.countries:
            if country["code"] == code:
                return country
        return None

    def get_country_by_name(self, name: str) -> Country | None:
        """Get country by its name.

        Args:
            name: Country name (case-insensitive)
        """
        name = name.lower()
        for country in self.countries:
            if country["name"].lower() == name:
                return country
        return None

    def get_available_locations(self) -> list[str]:
        """Get list of available locations with server counts."""
        locations = []
        for country in sorted(self.countries, key=lambda x: x["name"]):
            total_servers = country["serverCount"]
            locations.append(
                f"{country['name']} ({country['code'].lower()}) - {total_servers} servers"
            )
            for city in sorted(country["cities"], key=lambda x: x["name"]):
                locations.append(f"  {city['name']} - {city['serverCount']} servers")
        return locations

    def get_best_city(self, country_code: str) -> City | None:
        """Get the best city in a country based on hub score and server count.

        Args:
            country_code: Two-letter country code
        """
        country = self.get_country_by_code(country_code)
        if not country:
            return None

        # Sort cities by hub score (higher is better) and server count
        sorted_cities = sorted(
            country["cities"],
            key=lambda x: (x["hub_score"], x["serverCount"]),
            reverse=True,
        )
        return sorted_cities[0] if sorted_cities else None

    def list_countries(self, use_cache: bool = True) -> list[Country]:
        """Fetch a list of all available server countries from the NordVPN API.

        Args:
            use_cache: Whether to use cached country list (default: True)
                     If False, forces a fresh fetch from the API

        Returns:
            List of dictionaries containing country information
        """
        try:
            url = f"{self.BASE_API_URL}/servers/countries"
            response = requests.get(url, headers=API_HEADERS, timeout=10)
            response.raise_for_status()
            countries: list[Country] = response.json()

            # Cache the fresh data
            cache_data: CountryCache = {
                "countries": countries,
                "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            }
            cache_countries(cache_data)
            return countries

        except requests.RequestException as e:
            self.logger.warning(f"Failed to fetch countries: {e}")
            cached = get_cached_countries()
            if cached:
                return cached["countries"]

            # If no cache available, use fallback list
            return FALLBACK_DATA["countries"]

================
File: src/nyord_vpn/core/client.py
================
"""Main NordVPN client implementation.

This module contains the main Client class that coordinates:
- API interactions via NordVPNAPIClient
- VPN connections via VPNConnectionManager
- Server selection via ServerManager
"""

import os
import sys
import time
from pathlib import Path
from typing import TypedDict

import requests
from dotenv import load_dotenv
from loguru import logger
from rich.console import Console
from rich.logging import RichHandler


from src.nyord_vpn.storage.models import (
    ConnectionError,
    CredentialsError,
    VPNError,
)
from src.nyord_vpn.utils.utils import (
    API_HEADERS,
    CACHE_DIR,
    CONFIG_DIR,
    DATA_DIR,
    save_vpn_state,
)
from src.nyord_vpn.network.server import ServerManager
from src.nyord_vpn.core.api import NordVPNAPIClient
from src.nyord_vpn.network.vpn import VPNConnectionManager

load_dotenv()
logger.configure(
    handlers=[
        {
            "sink": RichHandler(),
            "format": "<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        }
    ]
)



# Constants
PACKAGE_DIR = Path(__file__).parent
CACHE_FILE = DATA_DIR / "countries.json"

# Rich console for pretty output
console = Console()


# Store cache in the package directory
COUNTRIES_CACHE = PACKAGE_DIR / "data" / "countries.json"


# Type definitions for country data
class City(TypedDict):
    """City information from NordVPN API."""

    dns_name: str
    hub_score: int
    id: int
    latitude: float
    longitude: float
    name: str
    serverCount: int


class Country(TypedDict):
    """Country information from NordVPN API."""

    cities: list[City]
    code: str
    id: int
    name: str
    serverCount: int


class CountryCache(TypedDict):
    """Cache file structure."""

    countries: list[Country]
    last_updated: str


# Fallback country list in case API is unreachable
FALLBACK_DATA: CountryCache = {
    "countries": [
        {
            "cities": [
                {
                    "dns_name": "new-york",
                    "hub_score": 0,
                    "id": 8971718,
                    "latitude": 40.7141667,
                    "longitude": -74.0063889,
                    "name": "New York",
                    "serverCount": 529,
                }
            ],
            "code": "US",
            "id": 228,
            "name": "United States",
            "serverCount": 529,
        },
        {
            "cities": [
                {
                    "dns_name": "london",
                    "hub_score": 0,
                    "id": 2989907,
                    "latitude": 51.514125,
                    "longitude": -0.093689,
                    "name": "London",
                    "serverCount": 785,
                }
            ],
            "code": "GB",
            "id": 227,
            "name": "United Kingdom",
            "serverCount": 785,
        },
        {
            "cities": [
                {
                    "dns_name": "frankfurt",
                    "hub_score": 0,
                    "id": 2215709,
                    "latitude": 50.116667,
                    "longitude": 8.683333,
                    "name": "Frankfurt",
                    "serverCount": 301,
                }
            ],
            "code": "DE",
            "id": 81,
            "name": "Germany",
            "serverCount": 301,
        },
    ],
    "last_updated": "2024-02-23T00:00:00Z",
}

# Cache expiry in seconds (24 hours)
CACHE_EXPIRY = 24 * 60 * 60


class Client:
    """Main NordVPN client that coordinates API, VPN, and server management."""

    def __init__(
        self,
        username: str | None = None,
        password: str | None = None,
        verbose: bool = False,
        auto_init: bool = True,
    ):
        """Initialize NordVPN client.

        Args:
            username: Optional username (defaults to NORD_USER env var)
            password: Optional password (defaults to NORD_PASSWORD env var)
            verbose: Enable verbose logging
            auto_init: Whether to automatically initialize the environment

        Environment variables:
            NORD_USER: NordVPN username (primary)
            NORD_PASSWORD: NordVPN password (primary)
            NORDVPN_LOGIN: NordVPN username (fallback)
            NORDVPN_PASSWORD: NordVPN password (fallback)
        """
        # Get credentials
        username_str = username or os.getenv("NORD_USER") or os.getenv("NORDVPN_LOGIN")
        password_str = (
            password or os.getenv("NORD_PASSWORD") or os.getenv("NORDVPN_PASSWORD")
        )
        if not username_str or not password_str:
            raise CredentialsError(
                "NORD_USER and NORD_PASSWORD environment variables must be set"
            )

        # Initialize components
        self.verbose = verbose
        self.api_client = NordVPNAPIClient(username_str, password_str, verbose)
        self.vpn_manager = VPNConnectionManager(verbose=verbose)
        self.server_manager = ServerManager(self.api_client)
        self._failed_servers = set()  # Track failed servers in this session

        # Set up logging
        self.logger = logger
        if verbose:
            self.logger.add(sys.stdout, level="DEBUG")

        # Initialize if requested
        if auto_init:
            try:
                self.init()
            except Exception as e:
                if verbose:
                    self.logger.warning(f"Failed to initialize environment: {e}")

    def init(self) -> None:
        """Initialize the client environment."""
        try:
            # Check OpenVPN installation
            openvpn_path = self.vpn_manager.check_openvpn_installation()
            if self.verbose:
                self.logger.info(f"Found OpenVPN at: {openvpn_path}")

            # Create necessary directories
            for directory in [CACHE_DIR, CONFIG_DIR, DATA_DIR]:
                directory.mkdir(parents=True, exist_ok=True)
                if self.verbose:
                    self.logger.info(f"Created directory: {directory}")

            # Test API connectivity
            if not self.api_client.test_api_connectivity():
                raise ConnectionError("Failed to connect to NordVPN API")
            if self.verbose:
                self.logger.info("Successfully connected to NordVPN API")

            # Get initial IP
            initial_ip = self.vpn_manager.get_current_ip()
            if not initial_ip:
                raise ConnectionError("Failed to get initial IP")
            if self.verbose:
                self.logger.info(f"Initial IP: {initial_ip}")

            if self.verbose:
                self.logger.info("Client environment initialized successfully")
            else:
                console.print(
                    "[green]Client environment initialized successfully[/green]"
                )

        except Exception as e:
            raise ConnectionError(f"Failed to initialize client environment: {e}")

    def status(self) -> dict[str, str | bool | None]:
        """Get current VPN connection status."""
        try:
            current_ip = self.vpn_manager.get_current_ip()
            if not current_ip:
                return {
                    "status": False,
                    "ip": "Unknown",
                    "country": "Unknown",
                    "city": "Unknown",
                    "server": None,
                }

            is_connected = self.vpn_manager.verify_connection()
            if not is_connected:
                return {
                    "status": False,
                    "ip": current_ip,
                    "country": "Unknown",
                    "city": "Unknown",
                    "server": None,
                }

            # Get location info from NordVPN API
            try:
                response = requests.get(
                    "https://nordvpn.com/wp-admin/admin-ajax.php?action=get_user_info_data",
                    headers=API_HEADERS,
                    timeout=5,
                )
                response.raise_for_status()
                nord_data = response.json()
                return {
                    "status": True,
                    "ip": current_ip,
                    "country": nord_data.get("country", "Unknown"),
                    "city": nord_data.get("city", "Unknown"),
                    "server": self.vpn_manager._server,
                }
            except Exception:
                return {
                    "status": True,
                    "ip": current_ip,
                    "country": self.vpn_manager._country_name or "Unknown",
                    "city": "Unknown",
                    "server": self.vpn_manager._server,
                }

        except Exception as e:
            raise ConnectionError(f"Failed to get status: {e}")

    def go(self, country_code: str) -> None:
        """Connect to VPN in specified country."""
        max_retries = 3
        retry_count = 0

        while retry_count < max_retries:
            try:
                # Get country info
                country = self.server_manager.get_country_info(country_code)
                if not country:
                    raise ValueError(f"Country code '{country_code}' not found")

                if self.verbose:
                    self.logger.info(f"Connecting to {country['name']}")

                # Get initial IP
                self._initial_ip = self.get_current_ip()
                if self.verbose:
                    self.logger.info(f"Initial IP: {self._initial_ip}")

                # Select fastest server
                server = self.server_manager.select_fastest_server(country_code)
                if not server:
                    raise VPNError("No server available")

                hostname = (
                    server.get("hostname") if isinstance(server, dict) else server
                )
                if not hostname:
                    raise VPNError("Invalid server data - missing hostname")

                if self.verbose:
                    self.logger.info(f"Selected server: {hostname}")
                else:
                    console.print(f"[cyan]Server:[/cyan] {hostname}")

                # Set up VPN configuration
                self.vpn_manager.setup_connection(
                    hostname, self.api_client.username, self.api_client.password
                )

                # Establish VPN connection
                if self.verbose:
                    self.logger.info("Establishing VPN connection...")
                self.vpn_manager.connect({"hostname": hostname})

                # Update connection info
                self._connected_ip = self.get_current_ip()
                self._server = hostname
                self._country_name = country["name"]

                if self.verbose:
                    self.logger.info(f"Connected to {hostname}")
                    self.logger.info(f"New IP: {self._connected_ip}")
                else:
                    console.print(f"[green]Connected to {hostname}[/green]")
                    console.print(f"[cyan]New IP:[/cyan] {self._connected_ip}")

                # Save state
                self._save_state()
                break

            except Exception as e:
                if self.verbose:
                    self.logger.warning(f"Connection failed: {e}")
                else:
                    console.print(f"[yellow]Connection failed: {e}[/yellow]")

                retry_count += 1
                if retry_count < max_retries:
                    if self.verbose:
                        self.logger.info("Retrying with different server...")
                    else:
                        console.print(
                            "[yellow]Retrying with different server...[/yellow]"
                        )
                    time.sleep(2)
                else:
                    raise VPNError(
                        f"Failed to connect after {max_retries} attempts: {e}"
                    )

    def disconnect(self, verbose: bool = True) -> None:
        """Disconnect from VPN."""
        try:
            self.vpn_manager.disconnect()
            if verbose:
                print("Disconnected from VPN")
        except Exception as e:
            raise ConnectionError(f"Failed to disconnect: {e}")

    def is_protected(self) -> bool:
        """Check if VPN is active."""
        status = self.status().get("status", False)
        return bool(status)

    def get_current_ip(self) -> str | None:
        """Get current IP address."""
        return self.vpn_manager.get_current_ip()

    def _save_state(self) -> None:
        """Save current connection state."""
        state = {
            "connected": self.is_protected(),
            "initial_ip": self._initial_ip,
            "connected_ip": self._connected_ip,
            "server": self._server,
            "country": self._country_name,
            "timestamp": time.time(),
        }
        save_vpn_state(state)

================
File: src/nyord_vpn/data/countries.json
================
{
  "servers": [
    {
      "hostname": "pl128.nordvpn.com",
      "load": 34,
      "country": {
        "code": "PL",
        "name": "Poland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "kjAOzXQRVGpmQdqE2zPsITH8QHmFK83AAPktqWed9wM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "194.99.105.99"
    },
    {
      "hostname": "be148.nordvpn.com",
      "load": 7,
      "country": {
        "code": "BE",
        "name": "Belgium"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "VSa6XYcD279ahd3IuEiUH6VpXn0+h+kWrD4OcN1ExUs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "82.102.19.137"
    },
    {
      "hostname": "hu48.nordvpn.com",
      "load": 7,
      "country": {
        "code": "HU",
        "name": "Hungary"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "3KWTCjpHlmXD3BroyAIFMN8ajr+ibShIl8OSUGgejXY="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.189.114.28"
    },
    {
      "hostname": "us5063.nordvpn.com",
      "load": 27,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.245.87.59"
    },
    {
      "hostname": "at86.nordvpn.com",
      "load": 12,
      "country": {
        "code": "AT",
        "name": "Austria"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "F6b2ac9H7hEvt03EonY1bS4FzNAabEmURDTB8wIIPXc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.216.34.100"
    },
    {
      "hostname": "ch217.nordvpn.com",
      "load": 10,
      "country": {
        "code": "CH",
        "name": "Switzerland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SqAWBSVdnUJ859Bz2Nyt82rlSebMwPgvwQxIb1DzyF8="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.156.175.132"
    },
    {
      "hostname": "dk152.nordvpn.com",
      "load": 9,
      "country": {
        "code": "DK",
        "name": "Denmark"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "EHL1zeXjZEJlqtFA8qaRVuvl0zR4skbC/AjiG66CLCc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "82.102.20.212"
    },
    {
      "hostname": "no151.nordvpn.com",
      "load": 4,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "82.102.22.92"
    },
    {
      "hostname": "ch218.nordvpn.com",
      "load": 13,
      "country": {
        "code": "CH",
        "name": "Switzerland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SqAWBSVdnUJ859Bz2Nyt82rlSebMwPgvwQxIb1DzyF8="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "84.39.112.20"
    },
    {
      "hostname": "uk1784.nordvpn.com",
      "load": 11,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "81.92.202.11"
    },
    {
      "hostname": "fr555.nordvpn.com",
      "load": 20,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "82.102.18.252"
    },
    {
      "hostname": "ch219.nordvpn.com",
      "load": 12,
      "country": {
        "code": "CH",
        "name": "Switzerland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SqAWBSVdnUJ859Bz2Nyt82rlSebMwPgvwQxIb1DzyF8="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.9.18.84"
    },
    {
      "hostname": "us5064.nordvpn.com",
      "load": 24,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.104.156"
    },
    {
      "hostname": "uk765.nordvpn.com",
      "load": 10,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.35.28.131"
    },
    {
      "hostname": "uk812.nordvpn.com",
      "load": 9,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "77.81.191.3"
    },
    {
      "hostname": "uk813.nordvpn.com",
      "load": 18,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.34.98.195"
    },
    {
      "hostname": "uk814.nordvpn.com",
      "load": 10,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.121.139.100"
    },
    {
      "hostname": "uk871.nordvpn.com",
      "load": 13,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.34.99.131"
    },
    {
      "hostname": "uk873.nordvpn.com",
      "load": 12,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.180.3"
    },
    {
      "hostname": "uk875.nordvpn.com",
      "load": 14,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.180.131"
    },
    {
      "hostname": "de507.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.130.184.115"
    },
    {
      "hostname": "de508.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.130.184.116"
    },
    {
      "hostname": "de509.nordvpn.com",
      "load": 3,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.130.184.117"
    },
    {
      "hostname": "de510.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.130.184.118"
    },
    {
      "hostname": "uk877.nordvpn.com",
      "load": 24,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "81.19.217.3"
    },
    {
      "hostname": "us2920.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "96.9.246.179"
    },
    {
      "hostname": "us2921.nordvpn.com",
      "load": 3,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "96.9.246.180"
    },
    {
      "hostname": "uk879.nordvpn.com",
      "load": 10,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "81.19.223.3"
    },
    {
      "hostname": "us2924.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "96.9.247.187"
    },
    {
      "hostname": "us2925.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "96.9.247.188"
    },
    {
      "hostname": "uk884.nordvpn.com",
      "load": 11,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "178.239.169.3"
    },
    {
      "hostname": "us2929.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "107.173.59.99"
    },
    {
      "hostname": "us2930.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "172.93.147.130"
    },
    {
      "hostname": "uk886.nordvpn.com",
      "load": 11,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.44.79.131"
    },
    {
      "hostname": "be149.nordvpn.com",
      "load": 7,
      "country": {
        "code": "BE",
        "name": "Belgium"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "VSa6XYcD279ahd3IuEiUH6VpXn0+h+kWrD4OcN1ExUs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "77.243.191.250"
    },
    {
      "hostname": "uk1806.nordvpn.com",
      "load": 14,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "193.9.113.134"
    },
    {
      "hostname": "uk888.nordvpn.com",
      "load": 8,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.16.205.3"
    },
    {
      "hostname": "uk890.nordvpn.com",
      "load": 7,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "185.16.205.131"
    },
    {
      "hostname": "us2939.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "172.93.237.99"
    },
    {
      "hostname": "us2940.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "172.93.237.100"
    },
    {
      "hostname": "de655.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "194.31.54.4"
    },
    {
      "hostname": "uk892.nordvpn.com",
      "load": 11,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.170.3"
    },
    {
      "hostname": "uk894.nordvpn.com",
      "load": 9,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "195.206.170.131"
    },
    {
      "hostname": "uk896.nordvpn.com",
      "load": 8,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "178.239.164.3"
    },
    {
      "hostname": "uk898.nordvpn.com",
      "load": 9,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "178.239.164.131"
    },
    {
      "hostname": "us2943.nordvpn.com",
      "load": 1,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.175.97"
    },
    {
      "hostname": "us2944.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.175.98"
    },
    {
      "hostname": "us2945.nordvpn.com",
      "load": 10,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.185.86"
    },
    {
      "hostname": "us2946.nordvpn.com",
      "load": 1,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.185.97"
    },
    {
      "hostname": "nl408.nordvpn.com",
      "load": 0,
      "country": {
        "code": "NL",
        "name": "Netherlands"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "5p4RkybdRU5uaDi90eu4KZPTFif0lKCg4Qp6t1c4F30="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.229.58.3"
    },
    {
      "hostname": "nl409.nordvpn.com",
      "load": 0,
      "country": {
        "code": "NL",
        "name": "Netherlands"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "5p4RkybdRU5uaDi90eu4KZPTFif0lKCg4Qp6t1c4F30="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.229.58.129"
    },
    {
      "hostname": "de676.nordvpn.com",
      "load": 0,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "37.120.223.116"
    },
    {
      "hostname": "us5055.nordvpn.com",
      "load": 13,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.187.175.2"
    },
    {
      "hostname": "us2949.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "64.44.32.75"
    },
    {
      "hostname": "us2950.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "dzMgdcXyF4Q95ayR8TEBYAL5Op+RuFEB/WGq2usxkFA="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "64.44.32.76"
    },
    {
      "hostname": "fr439.nordvpn.com",
      "load": 8,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.93.2.199"
    },
    {
      "hostname": "fr440.nordvpn.com",
      "load": 1,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "185.93.2.206"
    },
    {
      "hostname": "jp429.nordvpn.com",
      "load": 25,
      "country": {
        "code": "JP",
        "name": "Japan"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SAio0Z0suFlRfmydzPdcn6MamqS7Mq4pSOm2YmJkLSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.210.107"
    },
    {
      "hostname": "es114.nordvpn.com",
      "load": 7,
      "country": {
        "code": "ES",
        "name": "Spain"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "IF1FGVSzrUznFVZ+dymIz+6bdlCgsuiT/d6cyapN8lw="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.199.243"
    },
    {
      "hostname": "it132.nordvpn.com",
      "load": 15,
      "country": {
        "code": "IT",
        "name": "Italy"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FgxaycYZ4t1kp4x7LDv60sczNTAl0h/d4pyyUNHhgBc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.197.75"
    },
    {
      "hostname": "us4735.nordvpn.com",
      "load": 16,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.198.235"
    },
    {
      "hostname": "pl122.nordvpn.com",
      "load": 9,
      "country": {
        "code": "PL",
        "name": "Poland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "kjAOzXQRVGpmQdqE2zPsITH8QHmFK83AAPktqWed9wM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.211.171"
    },
    {
      "hostname": "cz93.nordvpn.com",
      "load": 5,
      "country": {
        "code": "CZ",
        "name": "Czech Republic"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "apEe1p4IQvCQxexoxoUTXsm2p582FtbDAboPwThFYEs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.199.27"
    },
    {
      "hostname": "at80.nordvpn.com",
      "load": 4,
      "country": {
        "code": "AT",
        "name": "Austria"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "F6b2ac9H7hEvt03EonY1bS4FzNAabEmURDTB8wIIPXc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "5.253.207.203"
    },
    {
      "hostname": "ro59.nordvpn.com",
      "load": 16,
      "country": {
        "code": "RO",
        "name": "Romania"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "o3Dj1qKYmzBBOBaD9JAhK9cg/8nfYxWg6GADL09DPHE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "86.106.137.187"
    },
    {
      "hostname": "ch198.nordvpn.com",
      "load": 18,
      "country": {
        "code": "CH",
        "name": "Switzerland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SqAWBSVdnUJ859Bz2Nyt82rlSebMwPgvwQxIb1DzyF8="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.213.131"
    },
    {
      "hostname": "bg38.nordvpn.com",
      "load": 12,
      "country": {
        "code": "BG",
        "name": "Bulgaria"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "xqa+kDsDeYLQAnVDUQaFun9Djfo3c1ESTMwfNArHw10="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.202.147"
    },
    {
      "hostname": "hu47.nordvpn.com",
      "load": 6,
      "country": {
        "code": "HU",
        "name": "Hungary"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "3KWTCjpHlmXD3BroyAIFMN8ajr+ibShIl8OSUGgejXY="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.192.99"
    },
    {
      "hostname": "fr452.nordvpn.com",
      "load": 10,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "45.152.181.219"
    },
    {
      "hostname": "jp454.nordvpn.com",
      "load": 28,
      "country": {
        "code": "JP",
        "name": "Japan"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "SAio0Z0suFlRfmydzPdcn6MamqS7Mq4pSOm2YmJkLSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "89.187.161.54"
    },
    {
      "hostname": "us4951.nordvpn.com",
      "load": 2,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "V1WC7wt34kcSDyqPuUhN56NJ0v+GlqY9TwZR5WlzzB4="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "84.17.44.122"
    },
    {
      "hostname": "dk150.nordvpn.com",
      "load": 10,
      "country": {
        "code": "DK",
        "name": "Denmark"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "EHL1zeXjZEJlqtFA8qaRVuvl0zR4skbC/AjiG66CLCc="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.194.3"
    },
    {
      "hostname": "de750.nordvpn.com",
      "load": 10,
      "country": {
        "code": "DE",
        "name": "Germany"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "m0tej5P6pYfBivkJc8yRV4KqQXmM81AChLlzlsOSjSs="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "5.180.62.120"
    },
    {
      "hostname": "us4953.nordvpn.com",
      "load": 1,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.175.53"
    },
    {
      "hostname": "us4954.nordvpn.com",
      "load": 0,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "8pRFH/FfMBs3eBJCM2ABFoOs/13n78LYQvoovZVLdgI="
            }
          ],
          "status": "online"
        },
        {
          "id": 42,
          "status": "online"
        },
        {
          "id": 45,
          "status": "online"
        }
      ],
      "station": "89.187.175.54"
    },
    {
      "hostname": "pl125.nordvpn.com",
      "load": 10,
      "country": {
        "code": "PL",
        "name": "Poland"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "kjAOzXQRVGpmQdqE2zPsITH8QHmFK83AAPktqWed9wM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.209.67"
    },
    {
      "hostname": "us5057.nordvpn.com",
      "load": 14,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.208.211"
    },
    {
      "hostname": "us5058.nordvpn.com",
      "load": 52,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.208.219"
    },
    {
      "hostname": "us5059.nordvpn.com",
      "load": 16,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.208.139"
    },
    {
      "hostname": "us5060.nordvpn.com",
      "load": 18,
      "country": {
        "code": "US",
        "name": "United States"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "0/x2PdBGfcIGr0ayFPFFjxcEEyhrlBRjR4kMcfwXJTU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.208.147"
    },
    {
      "hostname": "no141.nordvpn.com",
      "load": 21,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.163"
    },
    {
      "hostname": "no142.nordvpn.com",
      "load": 3,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.171"
    },
    {
      "hostname": "no143.nordvpn.com",
      "load": 3,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.179"
    },
    {
      "hostname": "no144.nordvpn.com",
      "load": 6,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.187"
    },
    {
      "hostname": "no145.nordvpn.com",
      "load": 6,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.195"
    },
    {
      "hostname": "no146.nordvpn.com",
      "load": 5,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.203"
    },
    {
      "hostname": "no147.nordvpn.com",
      "load": 5,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.211"
    },
    {
      "hostname": "no148.nordvpn.com",
      "load": 6,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "37.120.203.219"
    },
    {
      "hostname": "no149.nordvpn.com",
      "load": 4,
      "country": {
        "code": "NO",
        "name": "Norway"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "24IO9X6HN0Rx/KLpFpcZHjcI2bJ6Z6JWJ+ZShKjTZkU="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "95.174.66.27"
    },
    {
      "hostname": "uk1785.nordvpn.com",
      "load": 13,
      "country": {
        "code": "GB",
        "name": "United Kingdom"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "K53l2wOIHU3262sX5N/5kAvCvt4r55lNui30EbvaDlE="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "194.35.233.75"
    },
    {
      "hostname": "hu49.nordvpn.com",
      "load": 5,
      "country": {
        "code": "HU",
        "name": "Hungary"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "3KWTCjpHlmXD3BroyAIFMN8ajr+ibShIl8OSUGgejXY="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.192.83"
    },
    {
      "hostname": "fr536.nordvpn.com",
      "load": 11,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.139"
    },
    {
      "hostname": "fr537.nordvpn.com",
      "load": 20,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.147"
    },
    {
      "hostname": "fr538.nordvpn.com",
      "load": 8,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.155"
    },
    {
      "hostname": "fr539.nordvpn.com",
      "load": 13,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.163"
    },
    {
      "hostname": "fr540.nordvpn.com",
      "load": 8,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.195"
    },
    {
      "hostname": "fr541.nordvpn.com",
      "load": 8,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.203"
    },
    {
      "hostname": "fr542.nordvpn.com",
      "load": 12,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.171"
    },
    {
      "hostname": "fr543.nordvpn.com",
      "load": 9,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.179"
    },
    {
      "hostname": "fr544.nordvpn.com",
      "load": 11,
      "country": {
        "code": "FR",
        "name": "France"
      },
      "status": "online",
      "technologies": [
        {
          "id": 1,
          "status": "online"
        },
        {
          "id": 3,
          "status": "online"
        },
        {
          "id": 5,
          "status": "online"
        },
        {
          "id": 21,
          "status": "online"
        },
        {
          "id": 23,
          "status": "online"
        },
        {
          "id": 35,
          "metadata": [
            {
              "name": "public_key",
              "value": "FT46M53w4dhBep/2VScW1j/EoZbpBgzvk71FlLZLDBM="
            }
          ],
          "status": "online"
        },
        {
          "id": 51,
          "metadata": [
            {
              "name": "port",
              "value": "8443"
            }
          ],
          "status": "online"
        }
      ],
      "station": "217.138.207.187"
    }
  ],
  "last_updated": "2025-02-23T06:17:51Z",
  "expires_at": 1740377871.590903
}

================
File: src/nyord_vpn/data/country_ids.json
================
{
    "AL": "2",
    "AR": "10",
    "AU": "13",
    "AT": "14",
    "BE": "21",
    "BA": "27",
    "BR": "30",
    "BG": "33",
    "CA": "38",
    "CL": "43",
    "CR": "52",
    "HR": "54",
    "CY": "56",
    "CZ": "57",
    "DK": "58",
    "EE": "68",
    "FI": "73",
    "FR": "74",
    "GE": "80",
    "DE": "81",
    "GR": "84",
    "HK": "97",
    "HU": "98",
    "IS": "99",
    "IN": "100",
    "ID": "101",
    "IE": "104",
    "IL": "105",
    "IT": "106",
    "JP": "108",
    "LV": "119",
    "LU": "126",
    "MY": "131",
    "MX": "140",
    "MD": "142",
    "NL": "153",
    "NZ": "156",
    "MK": "128",
    "NO": "163",
    "PL": "174",
    "PT": "175",
    "RO": "179",
    "RS": "192",
    "SG": "195",
    "SK": "196",
    "SI": "197",
    "ZA": "200",
    "KR": "114",
    "ES": "202",
    "SE": "208",
    "CH": "209",
    "TW": "211",
    "TH": "214",
    "TR": "220",
    "UA": "225",
    "GB": "227",
    "US": "228",
    "VN": "234"
}

================
File: src/nyord_vpn/network/country.py
================
import json
import time

from src.nyord_vpn.storage.models import CountryCache
from src.nyord_vpn.utils.utils import COUNTRIES_CACHE, CACHE_EXPIRY


def get_cached_countries() -> CountryCache | None:
    """Get cached country list if available and not expired."""
    try:
        if not COUNTRIES_CACHE.exists():
            return None
        # Check if cache is expired
        if time.time() - COUNTRIES_CACHE.stat().st_mtime > CACHE_EXPIRY:
            return None
        return json.loads(COUNTRIES_CACHE.read_text())
    except (json.JSONDecodeError, OSError):
        return None


def cache_countries(data: CountryCache) -> None:
    """Cache the country list to disk.

    Args:
        data: Dictionary containing countries list and last_updated timestamp
    """
    try:
        COUNTRIES_CACHE.parent.mkdir(parents=True, exist_ok=True)
        COUNTRIES_CACHE.write_text(json.dumps(data, indent=2, sort_keys=True))
        COUNTRIES_CACHE.chmod(0o644)  # Make readable for all users
    except OSError:
        pass

================
File: src/nyord_vpn/network/server.py
================
import json
import random
import subprocess
import time
from typing import Any, TypedDict

import requests

from src.nyord_vpn.core.api import NordVPNAPIClient
from src.nyord_vpn.storage.models import ServerError
from src.nyord_vpn.utils.utils import API_HEADERS, CACHE_DIR, CACHE_EXPIRY


class ServerLocation(TypedDict):
    country: dict[str, str]


class ServerTechnology(TypedDict):
    id: int
    status: str


class ServerData(TypedDict):
    hostname: str
    load: int
    status: str
    location_ids: list[str]
    technologies: list[ServerTechnology]
    station: str | None


class APIResponse(TypedDict):
    servers: list[ServerData]
    locations: dict[str, ServerLocation]


class ServerManager:
    """Manages NordVPN server selection and caching."""

    def __init__(self, api_client: NordVPNAPIClient):
        """Initialize server manager.

        Args:
            api_client: NordVPN API client instance
        """
        self.api_client = api_client
        self.logger = api_client.logger
        self._servers_cache: list[dict[str, Any]] | None = None
        self._last_cache_update: float = 0
        self._failed_servers = set()  # Track failed servers in this session

    def fetch_server_info(
        self, country: str | None = None
    ) -> tuple[str, str] | None:
        """Fetch information about a recommended server that supports OpenVPN."""
        url = "https://api.nordvpn.com/v1/servers/recommendations"
        params = {
            "filters[servers_technologies][identifier]": "openvpn_tcp",
            "limit": "5",
        }
        if country:
            from src.nyord_vpn.utils.utils import NORDVPN_COUNTRY_IDS

            country_id = NORDVPN_COUNTRY_IDS.get(country.upper())
            if not country_id:
                # Try to get country ID from API
                country_info = self.get_country_info(country)
                if country_info:
                    country_id = str(country_info["id"])
                else:
                    raise ServerError(f"Country code '{country}' not found")
            params["filters[country_id]"] = country_id

        try:
            response = requests.get(url, params=params, headers=API_HEADERS, timeout=10)
            response.raise_for_status()
            data = response.json()
            if not isinstance(data, list) or not data:
                params.pop("filters[servers_technologies][identifier]", None)
                response = requests.get(
                    url, params=params, headers=API_HEADERS, timeout=10
                )
                response.raise_for_status()
                data = response.json()
            if not isinstance(data, list) or not data:
                raise ServerError(
                    f"No servers available{' in ' + country.upper() if country else ''}"
                )
            if self.api_client.verbose:
                self.logger.debug("Available servers retrieved.")
            server = min(data, key=lambda x: x.get("load", 100))
            hostname = server.get("hostname")
            if not isinstance(hostname, str) or not hostname:
                raise ServerError("Invalid server data received.")
            return hostname, server.get("station", "")
        except requests.RequestException as e:
            raise ServerError(f"Failed to fetch server info: {e}")

    def get_servers_cache(self) -> dict:
        """Get cached server list or fetch from API.

        Returns:
            dict: Server cache containing list of servers and metadata
        """
        cache_file = CACHE_DIR / "servers.json"
        if cache_file.exists():
            try:
                cache = json.loads(cache_file.read_text())
                if (
                    isinstance(cache, dict)
                    and isinstance(cache.get("servers", []), list)
                    and time.time() < cache.get("expires_at", 0)
                ):
                    # Validate cached servers
                    valid_servers = [
                        s for s in cache["servers"] if self._is_valid_server(s)
                    ]
                    if valid_servers:
                        if self.api_client.verbose:
                            self.logger.debug(
                                f"Using cached server list with {len(valid_servers)} valid servers"
                            )
                        cache["servers"] = valid_servers
                        return cache
                    elif self.api_client.verbose:
                        self.logger.warning(
                            "No valid servers in cache, fetching fresh data"
                        )
            except Exception as e:
                if self.api_client.verbose:
                    self.logger.warning(f"Failed to read cache: {e}")

        try:
            if self.api_client.verbose:
                self.logger.debug("Fetching server list from API...")

            # Use v2 API which has more detailed server info
            response = requests.get(
                "https://api.nordvpn.com/v1/servers",
                headers=API_HEADERS,
                timeout=10,
            )
            response.raise_for_status()
            data = response.json()

            if self.api_client.verbose:
                self.logger.debug("Successfully fetched server data from API")

            # Extract servers from response
            raw_servers: list[dict[str, Any]] = []
            locations_list: list[dict[str, Any]] = []

            if isinstance(data, list):
                raw_servers = [dict(s) for s in data]
                if self.api_client.verbose:
                    self.logger.debug(
                        f"Found {len(raw_servers)} servers in API response"
                    )
            else:
                raise ValueError(f"Unexpected API response format: {type(data)}")

            # Get countries info
            try:
                countries_response = requests.get(
                    "https://api.nordvpn.com/v1/servers/countries",
                    headers=API_HEADERS,
                    timeout=10,
                )
                countries_response.raise_for_status()
                countries_data = countries_response.json()

                # Create countries lookup
                countries = {}
                for country in countries_data:
                    if isinstance(country, dict):
                        country_id = str(country.get("id"))
                        if country_id:
                            countries[country_id] = {
                                "code": country.get("code", "").upper(),
                                "name": country.get("name", "Unknown"),
                            }
            except Exception as e:
                if self.api_client.verbose:
                    self.logger.warning(f"Failed to fetch countries: {e}")
                countries = {}

            # Filter and validate servers
            valid_servers = []
            invalid_count = 0
            for server in raw_servers:
                if not isinstance(server, dict):
                    invalid_count += 1
                    continue

                # Check if server is online and supports OpenVPN TCP
                if server.get("status") != "online":
                    if self.api_client.verbose:
                        self.logger.debug(
                            f"Skipping offline server: {server.get('hostname')}"
                        )
                    continue

                has_openvpn_tcp = False
                for tech in server.get("technologies", []):
                    if (
                        isinstance(tech, dict)
                        and tech.get("id") == 5
                        and tech.get("status") == "online"
                    ):
                        has_openvpn_tcp = True
                        break
                if not has_openvpn_tcp:
                    if self.api_client.verbose:
                        self.logger.debug(
                            f"Skipping server without OpenVPN TCP: {server.get('hostname')}"
                        )
                    continue

                # Get hostname and validate
                hostname = server.get("hostname")
                if not isinstance(hostname, str) or not hostname:
                    invalid_count += 1
                    continue

                # Get country info from location_ids
                country_info = None
                location_ids = server.get("location_ids", [])
                if isinstance(location_ids, list):
                    for location_id in location_ids:
                        if not isinstance(location_id, (str, int)):
                            continue
                        country_id = str(location_id)
                        country = countries.get(country_id)
                        if country and isinstance(country, dict):
                            country_info = country
                            break

                # If no country info from locations, try direct country field
                if not country_info:
                    country = server.get("country", {})
                    if isinstance(country, dict):
                        country_info = {
                            "code": country.get("code", "").upper(),
                            "name": country.get("name", "Unknown"),
                        }

                if not country_info:
                    if self.api_client.verbose:
                        self.logger.debug(
                            f"Skipping server without country info: {hostname}"
                        )
                    continue

                # Create normalized server entry
                valid_server = {
                    "hostname": hostname,
                    "load": int(server.get("load", 100)),
                    "country": country_info,
                    "status": server.get("status"),
                    "technologies": server.get("technologies", []),
                    "station": server.get("station"),
                }

                # Final validation
                if self._is_valid_server(valid_server):
                    valid_servers.append(valid_server)
                else:
                    invalid_count += 1

            if not valid_servers:
                raise ValueError(
                    f"No valid servers found in API response. "
                    f"Total servers: {len(raw_servers)}, Invalid: {invalid_count}"
                )

            if self.api_client.verbose:
                country_counts = {}
                for server in valid_servers:
                    code = server["country"]["code"]
                    country_counts[code] = country_counts.get(code, 0) + 1
                self.logger.debug(
                    f"Found {len(valid_servers)} valid servers. "
                    f"Country distribution: "
                    + ", ".join(f"{k}: {v}" for k, v in sorted(country_counts.items()))
                )

            cache = {
                "servers": valid_servers,
                "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                "expires_at": time.time() + CACHE_EXPIRY,
            }

            CACHE_DIR.mkdir(parents=True, exist_ok=True)
            cache_file.write_text(json.dumps(cache, indent=2))
            return cache

        except Exception as e:
            self.logger.error(f"Failed to fetch servers: {e}")
            if cache_file.exists():
                try:
                    cache = json.loads(cache_file.read_text())
                    if isinstance(cache, dict) and isinstance(
                        cache.get("servers", []), list
                    ):
                        # Validate cached servers even in fallback
                        valid_servers = [
                            s for s in cache["servers"] if self._is_valid_server(s)
                        ]
                        if valid_servers:
                            if self.api_client.verbose:
                                self.logger.info(
                                    f"Using fallback cache with {len(valid_servers)} valid servers"
                                )
                            cache["servers"] = valid_servers
                            return cache
                except Exception:
                    pass
            return {"servers": [], "last_updated": "", "expires_at": 0}

    def _ping_server(self, hostname: str) -> float:
        """Ping a server and return response time in ms.

        Args:
            hostname: Server hostname to ping

        Returns:
            float: Ping time in milliseconds, or float('inf') if ping failed
        """
        try:
            # Platform-specific ping command
            import platform

            system = platform.system().lower()

            if system == "windows":
                cmd = ["ping", "-n", "2", "-w", "1000", hostname]
            elif system == "darwin":  # macOS
                cmd = ["ping", "-c", "2", "-W", "1", "-t", "1", hostname]
            else:  # Linux and others
                cmd = ["ping", "-c", "2", "-W", "1", hostname]

            if self.api_client.verbose:
                self.logger.debug(f"Running ping command: {' '.join(cmd)}")

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=3, check=False,  # Overall timeout
            )

            if result.returncode == 0:
                # Extract time from ping output more robustly
                min_time = float("inf")
                for line in result.stdout.splitlines():
                    if self.api_client.verbose:
                        self.logger.debug(f"Ping output line: {line}")

                    # Look for min/avg/max line
                    if "min/avg/max" in line:
                        try:
                            # Format: round-trip min/avg/max/stddev = 18.894/18.894/18.894/0.000 ms
                            stats = line.split("=")[1].strip().split("/")
                            min_time = float(stats[0])
                            if self.api_client.verbose:
                                self.logger.debug(
                                    f"Parsed min time from stats: {min_time}ms"
                                )
                            return min_time
                        except (IndexError, ValueError) as e:
                            if self.api_client.verbose:
                                self.logger.debug(
                                    f"Failed to parse min/avg/max line '{line}': {e}"
                                )
                            continue
                    # Look for individual ping responses
                    elif "time=" in line:
                        try:
                            time_str = line.split("time=")[1].split()[0].rstrip("ms")
                            ping_time = float(time_str)
                            min_time = min(min_time, ping_time)
                            if self.api_client.verbose:
                                self.logger.debug(
                                    f"Parsed time from response: {ping_time}ms"
                                )
                        except (IndexError, ValueError) as e:
                            if self.api_client.verbose:
                                self.logger.debug(
                                    f"Failed to parse time from line '{line}': {e}"
                                )
                            continue

                if min_time < float("inf"):
                    if self.api_client.verbose:
                        self.logger.debug(
                            f"Server {hostname} responded in {min_time}ms"
                        )
                    return min_time

                # If we couldn't parse any times but ping succeeded
                if self.api_client.verbose:
                    self.logger.debug(
                        f"Server {hostname} responded but couldn't parse time from output:\n{result.stdout}"
                    )
                return float("inf")
            else:
                if self.api_client.verbose:
                    self.logger.debug(
                        f"Server {hostname} ping failed with code {result.returncode}:\n"
                        f"stdout: {result.stdout}\n"
                        f"stderr: {result.stderr}"
                    )
                return float("inf")

        except subprocess.TimeoutExpired:
            if self.api_client.verbose:
                self.logger.debug(f"Server {hostname} ping timed out")
            return float("inf")
        except Exception as e:
            if self.api_client.verbose:
                self.logger.debug(f"Server {hostname} ping error: {e}")
                import traceback

                self.logger.debug(f"Traceback: {traceback.format_exc()}")
            return float("inf")

    def _is_valid_server(self, server: Any) -> bool:
        """Validate server data structure.

        Args:
            server: Server data to validate

        Returns:
            bool: True if server data is valid
        """
        if not isinstance(server, dict):
            return False

        # Check required fields
        hostname = server.get("hostname")
        if not isinstance(hostname, str) or not hostname:
            return False

        # Basic hostname validation
        if not hostname.endswith(".nordvpn.com"):
            return False

        # Check country info
        country = server.get("country")
        if not isinstance(country, dict):
            return False

        country_code = country.get("code")
        if not isinstance(country_code, str) or len(country_code) != 2:
            return False

        # Check server status
        status = server.get("status")
        if status != "online":
            return False

        # Check load value
        load = server.get("load")
        if not isinstance(load, (int, float)) or load < 0 or load > 100:
            return False

        return True

    def select_fastest_server(
        self,
        country_code: str | None = None,
        random_select: bool = False,
        _retry_count: int = 0,
    ) -> dict[str, Any] | str | None:
        """Select fastest server from list.

        Args:
            country_code: Optional country code to filter by
            random_select: Whether to select a random server instead of fastest
            _retry_count: Internal retry counter to prevent infinite recursion

        Returns:
            Server hostname or dict with server info
        """
        if _retry_count >= 3:
            self.logger.error("Maximum retry count reached, clearing failed servers")
            self._failed_servers.clear()
            return None

        try:
            cache = self.get_servers_cache()
            servers = cache.get("servers", [])
            if self.api_client.verbose:
                self.logger.debug(f"Got {len(servers)} servers from cache")
            if not servers:
                return None

            # Filter by country if specified
            if country_code:
                if self.api_client.verbose:
                    self.logger.debug(f"Filtering servers for country: {country_code}")
                servers = [
                    s
                    for s in servers
                    if s.get("country", {}).get("code", "").upper()
                    == country_code.upper()
                ]
                if self.api_client.verbose:
                    self.logger.debug(
                        f"Found {len(servers)} servers for {country_code}"
                    )
                if not servers:
                    return None

            # Skip servers that have failed
            original_count = len(servers)
            servers = [
                s for s in servers if s.get("hostname") not in self._failed_servers
            ]
            if self.api_client.verbose:
                skipped = original_count - len(servers)
                if skipped > 0:
                    self.logger.debug(f"Skipped {skipped} previously failed servers")

            if not servers:
                self.logger.warning(
                    "All servers have failed, clearing failed servers list"
                )
                self._failed_servers.clear()
                return self.select_fastest_server(
                    country_code, random_select, _retry_count + 1
                )

            # Select random server if requested
            if random_select:
                server = random.choice(servers)
                if self.api_client.verbose:
                    self.logger.debug(
                        f"Randomly selected server: {server.get('hostname')} "
                        f"({server.get('load', '?')}% load)"
                    )
                return server

            # Sort by load and take top servers
            servers.sort(key=lambda x: x.get("load", 100))
            servers = servers[:5]  # Test top 5 servers
            if self.api_client.verbose:
                self.logger.debug(
                    "Top 5 servers by load: "
                    + ", ".join(
                        f"{s.get('hostname')}({s.get('load', '?')}%)" for s in servers
                    )
                )

            # Test response times
            server_times = []
            for server in servers:
                hostname = server.get("hostname")
                if not hostname:
                    if self.api_client.verbose:
                        self.logger.warning(f"Server missing hostname: {server}")
                    continue

                if self.api_client.verbose:
                    self.logger.debug(f"Testing server {hostname}...")

                response_time = self._ping_server(hostname)
                if response_time is not None and response_time < float("inf"):
                    server_times.append((server, response_time))
                    if self.api_client.verbose:
                        self.logger.debug(
                            f"Server {hostname} responded in {response_time}ms"
                        )
                elif self.api_client.verbose:
                    self.logger.warning(f"Server {hostname} failed ping test")

            if not server_times:
                if self.api_client.verbose:
                    self.logger.warning(
                        "No servers responded to ping test, falling back to load-based selection"
                    )
                # If no servers respond to ping, just use the one with lowest load
                return servers[0]

            # Select fastest server
            fastest_server = min(server_times, key=lambda x: x[1])[0]
            if self.api_client.verbose:
                self.logger.info(
                    f"Selected fastest server: {fastest_server.get('hostname')} "
                    f"({fastest_server.get('load', '?')}% load, "
                    f"{min(t for _, t in server_times)}ms)"
                )

            return fastest_server

        except Exception as e:
            self.logger.error(f"Error selecting fastest server: {e}")
            if self.api_client.verbose:
                import traceback

                self.logger.debug(f"Traceback: {traceback.format_exc()}")
            return None

    def get_random_country(self) -> str:
        try:
            cache = self.get_servers_cache()
            countries = {
                s.get("country", {}).get("code")
                for s in cache.get("servers", [])
                if s.get("country", {}).get("code")
            }
            if not countries:
                raise ServerError("No countries found in server list")
            return random.choice(list(countries))
        except Exception as e:
            self.logger.error(f"Failed to get random country: {e}")
            return "US"

    def get_country_info(self, country_code: str) -> dict[str, Any] | None:
        """Get country information from NordVPN API.

        Args:
            country_code: Two-letter country code

        Returns:
            Dictionary with country information or None if not found
        """
        try:
            # Use v1 API endpoint
            response = requests.get(
                "https://api.nordvpn.com/v1/servers/countries",
                headers=API_HEADERS,
                timeout=10,
            )
            response.raise_for_status()
            countries = response.json()

            # Find country by code
            for country in countries:
                if (
                    isinstance(country, dict)
                    and country.get("code", "").upper() == country_code.upper()
                ):
                    return {
                        "code": country["code"],
                        "name": country["name"],
                        "id": country["id"],
                    }

            return None

        except Exception as e:
            self.logger.error(f"Failed to get country info: {e}")
            return None

================
File: src/nyord_vpn/network/vpn.py
================
"""VPN connection manager for NordVPN."""

import os
import subprocess
import time
from pathlib import Path
from typing import Any

import requests
from loguru import logger
from rich.progress import Progress, SpinnerColumn, TextColumn

from src.nyord_vpn.storage.models import VPNError
from src.nyord_vpn.utils.utils import API_HEADERS, OPENVPN_AUTH


class VPNConnectionManager:
    """Manages VPN connections using OpenVPN."""

    def __init__(
        self, openvpn_path: str = "/usr/local/sbin/openvpn", verbose: bool = False
    ):
        """Initialize VPN connection manager.

        Args:
            openvpn_path: Path to OpenVPN executable
            verbose: Whether to enable verbose logging
        """
        self.openvpn_path = openvpn_path
        self.logger = logger
        self.verbose = verbose
        self.process: subprocess.Popen | None = None
        self.config_dir = Path(os.path.expanduser("~/.config/nyord-vpn/configs"))
        self.config_dir.mkdir(parents=True, exist_ok=True)

        # Connection state
        self._initial_ip: str | None = None
        self._connected_ip: str | None = None
        self._server: str | None = None
        self._country_name: str | None = None

    def get_current_ip(self) -> str | None:
        """Get current IP address."""
        try:
            response = requests.get("https://api.ipify.org?format=json", timeout=5)
            response.raise_for_status()
            return response.json().get("ip")
        except Exception:
            return None

    def check_openvpn_installation(self) -> str:
        """Verify OpenVPN is installed and return its path."""
        try:
            result = subprocess.run(
                ["which", "openvpn"], capture_output=True, text=True, check=True
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError:
            raise VPNError(
                "OpenVPN not found. Please install OpenVPN first:\n"
                "  macOS: brew install openvpn\n"
                "  Linux: sudo apt install openvpn\n"
                "  Windows: Download from https://openvpn.net/community-downloads/"
            )

    def connect(self, server: dict[str, Any]) -> None:
        """Connect to a VPN server.

        Args:
            server: Server info dictionary

        Raises:
            VPNError: If connection fails
        """
        try:
            hostname = server.get("hostname")
            if not hostname:
                raise VPNError("Invalid server info - missing hostname")

            if self.verbose:
                self.logger.debug(f"Connecting to {hostname}")

            # Store initial IP
            self._initial_ip = self.get_current_ip()

            # Generate OpenVPN config
            config_path = self._generate_config(hostname)

            # Verify auth file exists and has correct format
            if not OPENVPN_AUTH.exists():
                raise VPNError(
                    "Authentication file not found. Please create ~/.cache/nyord-vpn/openvpn.auth with your NordVPN credentials:\n"
                    "  1. Set your credentials as environment variables:\n"
                    "     export NORD_USER='your_nordvpn_username'\n"
                    "     export NORD_PASSWORD='your_nordvpn_password'\n"
                    "  2. Create the auth file:\n"
                    '     echo "$NORD_USER" > ~/.cache/nyord-vpn/openvpn.auth\n'
                    '     echo "$NORD_PASSWORD" >> ~/.cache/nyord-vpn/openvpn.auth\n'
                    "\nThe file should contain your username on the first line and password on the second line."
                )

            try:
                auth_lines = OPENVPN_AUTH.read_text().strip().splitlines()
                if len(auth_lines) != 2 or not all(line.strip() for line in auth_lines):
                    raise VPNError(
                        "Invalid auth file format. The file should contain exactly two non-empty lines:\n"
                        "  Line 1: Your NordVPN username\n"
                        "  Line 2: Your NordVPN password"
                    )
            except Exception as e:
                if isinstance(e, VPNError):
                    raise
                raise VPNError(f"Failed to read auth file: {e}")

            # Start OpenVPN process
            cmd = [
                "sudo",
                "openvpn",
                "--config",
                str(config_path),
                "--auth-user-pass",
                str(OPENVPN_AUTH),
                "--verb",
                "5",  # Increased verbosity for more detailed logs
            ]

            if self.verbose:
                self.logger.debug(f"Running OpenVPN command: {' '.join(cmd)}")

            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                transient=True,
            ) as progress:
                progress.add_task(description="Connecting...", total=None)
                self.process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,  # Line buffered
                )

            # Wait for initial connection and capture output
            time.sleep(5)
            if self.process.poll() is not None:
                stdout, stderr = self.process.communicate()
                if self.verbose:
                    self.logger.debug(f"OpenVPN stdout:\n{stdout}")
                    self.logger.debug(f"OpenVPN stderr:\n{stderr}")
                if "AUTH_FAILED" in stderr:
                    raise VPNError(f"Authentication failed. Full error:\n{stderr}")
                raise VPNError(f"OpenVPN process failed:\n{stderr}\nOutput:\n{stdout}")

            # Verify connection
            if not self.verify_connection():
                raise VPNError("Failed to establish VPN connection")

            # Update connection info
            self._server = hostname
            self._connected_ip = self.get_current_ip()

            if self.verbose:
                self.logger.info(f"Connected to {hostname}")

        except Exception as e:
            raise VPNError(f"Failed to connect to VPN: {e}")

    def disconnect(self) -> None:
        """Disconnect from VPN."""
        if self.process:
            try:
                # Try graceful shutdown first
                self.process.terminate()
                try:
                    self.process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    # Force kill if graceful shutdown fails
                    self.process.kill()
                    self.process.wait()
            except Exception as e:
                if self.verbose:
                    self.logger.warning(f"Error during VPN disconnect: {e}")
            finally:
                self.process = None

        # Clean up any lingering OpenVPN processes
        try:
            subprocess.run(
                ["sudo", "pkill", "-f", "openvpn"],
                check=False,
                capture_output=True,
            )
        except Exception as e:
            if self.verbose:
                self.logger.warning(f"Error cleaning up OpenVPN processes: {e}")

        # Reset connection state
        self._initial_ip = None
        self._connected_ip = None
        self._server = None
        self._country_name = None

    def verify_connection(self) -> bool:
        """Verify VPN connection is active."""
        try:
            # Check if process is running
            if not self.is_connected():
                return False

            # Get current IP
            current_ip = self.get_current_ip()
            if not current_ip:
                return False

            # Check if IP has changed from initial
            if current_ip == self._initial_ip:
                return False

            # Check NordVPN API for connection status
            try:
                response = requests.get(
                    "https://nordvpn.com/wp-admin/admin-ajax.php?action=get_user_info_data",
                    headers=API_HEADERS,
                    timeout=5,
                )
                response.raise_for_status()
                nord_data = response.json()
                if not nord_data.get("status", False):
                    return False
            except Exception:
                # If API check fails, just verify IP change
                pass

            return True

        except Exception:
            return False

    def _generate_config(self, hostname: str) -> Path:
        """Generate OpenVPN config file for server.

        Args:
            hostname: Server hostname

        Returns:
            Path: Path to generated config file
        """
        config_path = self.config_dir / f"{hostname}.ovpn"

        # Basic OpenVPN config
        config = f"""client
dev tun
proto tcp
remote {hostname} 443
resolv-retry infinite
nobind
persist-key
persist-tun
remote-cert-tls server
cipher AES-256-CBC
auth SHA512
verify-x509-name CN={hostname}
auth-nocache
pull
tls-client
key-direction 1
verb 3

<ca>
-----BEGIN CERTIFICATE-----
MIIFCjCCAvKgAwIBAgIBATANBgkqhkiG9w0BAQ0FADA5MQswCQYDVQQGEwJQQTEQ
MA4GA1UEChMHTm9yZFZQTjEYMBYGA1UEAxMPTm9yZFZQTiBSb290IENBMB4XDTE2
MDEwMTAwMDAwMFoXDTM1MTIzMTIzNTk1OVowOTELMAkGA1UEBhMCUEExEDAOBgNV
BAoTB05vcmRWUE4xGDAWBgNVBAMTD05vcmRWUE4gUm9vdCBDQTCCAiIwDQYJKoZ
IhvcNAQEBBQADggIPADCCAgoCggIBAMkr/BYhyo0F2upsIMXwC6QvkZps3NN2/eQF
kfQIS1gql0aejsKsEnmY0Kaon8uZCTXPsRH1gQNgg5D2gixdd1mJUvV3dE3y9FJr
XMoDkXdCGBodvKJyU6lcfEVF6/UxHcbBguZK9UtRHS9eJYm3rpL/5huQMCppX7kU
eQ8dpCwd3iKITqwd1ZudDqsWaU0vqzC2H55IyaZ/5/TnCk31Q1UP6BksbbuRcwOV
skEDsm6YoWDnn/IIzGOYnFJRzQH5jTz3j1QBvRIuQuBuvUkfhx1FEwhwZigrcxXu
MP+QgM54kezgziJUaZcOM2zF3lvrwMvXDMfNeIoJABv9ljw969xQ8czQCU5lMVmA
37ltv5Ec9U5hZuwk/9QO1Z+d/r6Jx0mlurS8gnCAKJgwa3kyZw6e4FZ8mYL4vpRR
hPdvRTWCMJkeB4yBHyhxUmTRgJHm6YR3D6hcFAc9cQcTEl/I60tMdz33G6m0O42s
Qt/+AR3YCY/RusWVBJB/qNS94EtNtj8iaebCQW1jHAhvGmFILVR9lzD0EzWKHkvy
WEjmUVRgCDd6Ne3eFRNS73gdv/C3l5boYySeu4exkEYVxVRn8DhCxs0MnkMHWFK6
MyzXCCn+JnWFDYPfDKHvpff/kLDobtPBf+Lbch5wQy9quY27xaj0XwLyjOltpiST
LWae/Q4vAgMBAAGjHTAbMAwGA1UdEwQFMAMBAf8wCwYDVR0PBAQDAgEGMA0GCSqG
SIb3DQEBDQUAA4ICAQC9fUL2sZPxIN2mD32VeNySTgZlCEdVmlq471o/bDMP4B8g
nQesFRtXY2ZCjs50Jm73B2LViL9qlREmI6vE5IC8IsRBJSV4ce1WYxyXro5rmVg/
k6a10rlsbK/eg//GHoJxDdXDOokLUSnxt7gk3QKpX6eCdh67p0PuWm/7WUJQxH2S
DxsT9vB/iZriTIEe/ILoOQF0Aqp7AgNCcLcLAmbxXQkXYCCSB35Vp06u+eTWjG0/
pyS5V14stGtw+fA0DJp5ZJV4eqJ5LqxMlYvEZ/qKTEdoCeaXv2QEmN6dVqjDoTAo
k0t5u4YRXzEVCfXAC3ocplNdtCA72wjFJcSbfif4BSC8bDACTXtnPC7nD0VndZLp
+RiNLeiENhk0oTC+UVdSc+n2nJOzkCK0vYu0Ads4JGIB7g8IB3z2t9ICmsWrgnhd
NdcOe15BincrGA8avQ1cWXsfIKEjbrnEuEk9b5jel6NfHtPKoHc9mDpRdNPISeVa
wDBM1mJChneHt59Nh8Gah74+TM1jBsw4fhJPvoc7Atcg740JErb904mZfkIEmojC
VPhBHVQ9LHBAdM8qFI2kRK0IynOmAZhexlP/aT/kpEsEPyaZQlnBn3An1CRz8h0S
PApL8PytggYKeQmRhl499+6jLxcZ2IegLfqq41dzIjwHwTMplg+1pKIOVojpWA==
-----END CERTIFICATE-----
</ca>

<tls-auth>
#
# 2048 bit OpenVPN static key
#
-----BEGIN OpenVPN Static key V1-----
e685bdaf659a25a200e2b9e39e51ff03
0fc72cf1ce07232bd8b2be5e6c670143
f51e937e670eee09d4f2ea5a6e4e6996
5db852c275351b86fc4ca892d78ae002
d6f70d029bd79c4d1c26cf14e9588033
cf639f8a74809f29f72b9d58f9b8f5fe
fc7938eade40e9fed6cb92184abb2cc1
0eb1a296df243b251df0643d53724cdb
5a92a1d6cb817804c4a9319b57d53be5
80815bcfcb2df55018cc83fc43bc7ff8
2d51f9b88364776ee9d12fc85cc7ea5b
9741c4f598c485316db066d52db4540e
212e1518a9bd4828219e24b20d88f598
a196c9de96012090e333519ae18d3509
9427e7b372d348d352dc4c85e18cd4b9
3f8a56ddb2e64eb67adfc9b337157ff4
-----END OpenVPN Static key V1-----
</tls-auth>
"""

        config_path.write_text(config)
        return config_path

    def is_connected(self) -> bool:
        """Check if VPN is currently connected.

        Returns:
            bool: True if connected
        """
        return self.process is not None and self.process.poll() is None

    def update_connection_info(self, server_hostname: str, country_name: str) -> None:
        """Update connection information."""
        self._server = server_hostname
        self._country_name = country_name
        self._connected_ip = self.get_current_ip()

    def setup_connection(
        self, server_hostname: str, username: str, password: str
    ) -> None:
        """Set up OpenVPN configuration files.

        Args:
            server_hostname: Server hostname
            username: NordVPN username
            password: NordVPN password
        """
        # Generate OpenVPN config
        config_path = self._generate_config(server_hostname)

        # Create auth file
        OPENVPN_AUTH.write_text(f"{username}\n{password}")

        if self.verbose:
            self.logger.debug(f"Created auth file at {OPENVPN_AUTH}")

================
File: src/nyord_vpn/scripts/__init__.py
================
"""Utility scripts for nyord-vpn."""

================
File: src/nyord_vpn/scripts/update_countries.py
================
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["requests", "rich"]
# ///

"""Script to fetch and update the country list from NordVPN API."""

import json
import sys
import time
from pathlib import Path
from typing import Dict, List, TypedDict, Union

import requests
from rich import print as rprint
from rich.progress import Progress, SpinnerColumn, TextColumn


class City(TypedDict):
    """City information from NordVPN API."""

    dns_name: str
    hub_score: int
    id: int
    latitude: float
    longitude: float
    name: str
    serverCount: int


class Country(TypedDict):
    """Country information from NordVPN API."""

    cities: List[City]
    code: str
    id: int
    name: str
    serverCount: int


class CountryCache(TypedDict):
    """Cache file structure."""

    countries: List[Country]
    last_updated: str


def fetch_countries() -> List[Country]:
    """Fetch countries from NordVPN API."""
    url = "https://api.nordvpn.com/v1/servers/countries"

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task(
            description="Fetching country list from NordVPN API...", total=None
        )
        response = requests.get(url, timeout=10)
        response.raise_for_status()

    # The API already returns the exact structure we want
    countries: List[Country] = response.json()
    return sorted(countries, key=lambda x: x["name"])


def main() -> None:
    """Update the country list cache file."""
    try:
        # Get package data directory
        package_dir = Path(__file__).parent.parent
        data_dir = package_dir / "data"
        cache_file = data_dir / "countries.json"

        # Ensure data directory exists
        data_dir.mkdir(parents=True, exist_ok=True)

        # Fetch fresh data
        countries = fetch_countries()

        # Calculate total servers across all countries
        total_servers = sum(country["serverCount"] for country in countries)
        total_cities = sum(len(country["cities"]) for country in countries)

        # Prepare cache data
        cache_data: CountryCache = {
            "countries": countries,
            "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        }

        # Save to file
        with cache_file.open("w") as f:
            json.dump(cache_data, f, indent=2, sort_keys=True)
        cache_file.chmod(0o644)

        rprint(f"[green] Updated country list cache with:[/green]")
        rprint(f"   [cyan]{len(countries)}[/cyan] countries")
        rprint(f"   [cyan]{total_cities}[/cyan] cities")
        rprint(f"   [cyan]{total_servers}[/cyan] servers")
        rprint(f"[blue]Cache file: {cache_file}[/blue]")

    except requests.RequestException as e:
        rprint(f"[red] Failed to fetch country list: {e}[/red]")
        sys.exit(1)
    except (OSError, json.JSONDecodeError) as e:
        rprint(f"[red] Failed to update cache file: {e}[/red]")
        sys.exit(1)


if __name__ == "__main__":
    main()

================
File: src/nyord_vpn/storage/models.py
================
"""Data models and exceptions for the NordVPN client.

This module contains:
- Type definitions for API responses (City, Country)
- Cache data structures
- Custom exceptions for error handling
"""

from typing import List, TypedDict


class City(TypedDict):
    """City information from NordVPN API."""

    dns_name: str
    hub_score: int
    id: int
    latitude: float
    longitude: float
    name: str
    serverCount: int


class Country(TypedDict):
    """Country information from NordVPN API."""

    cities: List[City]
    code: str
    id: int
    name: str
    serverCount: int


class CountryCache(TypedDict):
    """Cache file structure."""

    countries: List[Country]
    last_updated: str


# Base exceptions
class VPNError(Exception):
    """Base exception for VPN-related errors."""

    def __init__(self, message: str | None = None):
        super().__init__(message or "An unknown VPN error occurred")


class ServerError(VPNError):
    """Raised when server selection fails."""

    def __init__(self, message: str | None = None):
        super().__init__(
            message
            or "Failed to select a server. Please try again or choose a different country."
        )


class ConnectionError(VPNError):
    """Raised when connection fails."""

    def __init__(self, message: str | None = None):
        super().__init__(
            message
            or "Failed to establish VPN connection. Please check your internet connection and try again."
        )


class DisconnectionError(VPNError):
    """Raised when disconnection fails."""

    def __init__(self, message: str | None = None):
        super().__init__(
            message
            or "Failed to disconnect from VPN. You may need to manually kill the OpenVPN process."
        )


class AuthenticationError(VPNError):
    """Raised when authentication fails."""

    def __init__(self, message: str | None = None):
        super().__init__(
            message or "Authentication failed. Please check your NordVPN credentials."
        )


class CredentialsError(VPNError):
    """Raised when credentials are missing or invalid."""

    def __init__(self, message: str | None = None):
        super().__init__(
            message
            or (
                "NordVPN credentials not found. Please set environment variables:\n"
                "  export NORD_USER='your-username'\n"
                "  export NORD_PASSWORD='your-password'\n"
                "\nOr provide them directly when running the command:\n"
                "  NORD_USER='your-username' NORD_PASSWORD='your-password' nyord-vpn <command>"
            )
        )


class StateError(VPNError):
    """Raised when state operations fail."""

    def __init__(self, message: str | None = None):
        super().__init__(
            message
            or "Failed to manage VPN state. Please try disconnecting and reconnecting."
        )


class CacheError(VPNError):
    """Raised when cache operations fail."""

    def __init__(self, message: str | None = None):
        super().__init__(
            message
            or "Failed to manage cache. Try running 'nyord-vpn update' to refresh the cache."
        )

================
File: src/nyord_vpn/storage/state.py
================
import json
import time

from src.nyord_vpn.utils.utils import STATE_FILE, logger


def save_vpn_state(state: dict) -> None:
    """Save VPN connection state to file.

    Args:
        state: Dictionary with VPN state information.
    """
    try:
        STATE_FILE.write_text(json.dumps(state, indent=2))
    except Exception as e:
        logger.warning(f"Failed to save VPN state: {e}")


def load_vpn_state() -> dict:
    """Load VPN connection state from file.

    Returns:
        Dictionary with VPN state; defaults if state is missing or expired.
    """
    try:
        if STATE_FILE.exists():
            state = json.loads(STATE_FILE.read_text())
            # Consider state valid for 5 minutes
            if time.time() - state.get("timestamp", 0) < 300:
                return state
    except Exception as e:
        logger.warning(f"Failed to load VPN state: {e}")
    return {
        "connected": False,
        "initial_ip": None,
        "connected_ip": None,
        "server": None,
        "country": None,
        "timestamp": time.time(),
    }

================
File: src/nyord_vpn/utils/connection.py
================
from typing import Optional
import psutil


def is_openvpn_running() -> bool:
    """Check if any OpenVPN process is running."""
    for proc in psutil.process_iter(["name"]):
        if proc.info.get("name") == "openvpn":
            return True
    return False


def compute_connection_status(
    current_ip: str,
    initial_ip: Optional[str],
    connected_ip: Optional[str],
    openvpn_running: bool,
    nord_status: Optional[bool] = None,
) -> bool:
    """
    Compute if the VPN connection is active.

    Args:
        current_ip: Current IP address.
        initial_ip: The initial IP before VPN activation.
        connected_ip: The recorded VPN IP.
        openvpn_running: Whether an OpenVPN process is running.
        nord_status: Optional flag from NordVPN API indicating VPN status.

    Returns:
        True if VPN is active, False otherwise.
    """
    if nord_status is not None:
        is_connected = (
            openvpn_running
            and (current_ip == connected_ip or nord_status)
            and (initial_ip is None or current_ip != initial_ip)
        )
    else:
        is_connected = (
            openvpn_running
            and (current_ip == connected_ip)
            and (initial_ip is None or current_ip != initial_ip)
        )
    if not is_connected and openvpn_running and current_ip == connected_ip:
        is_connected = True
    return is_connected

================
File: src/nyord_vpn/utils/templates.py
================
OPENVPN_TEMPLATE = """client
dev tun
proto tcp
remote {server} 443
resolv-retry infinite
remote-random
nobind
tun-mtu 1500
tun-mtu-extra 32
mssfix 1450
persist-key
persist-tun
ping 10
ping-restart 60
ping-timer-rem
reneg-sec 0
comp-lzo no
verify-x509-name CN={server}

remote-cert-tls server

auth-user-pass
verb 3
pull
fast-io
data-ciphers AES-256-GCM:AES-128-GCM:CHACHA20-POLY1305
data-ciphers-fallback AES-256-GCM
auth SHA512
connect-retry 2
connect-timeout 10
resolv-retry infinite

<ca>
-----BEGIN CERTIFICATE-----
MIIFCjCCAvKgAwIBAgIBATANBgkqhkiG9w0BAQ0FADA5MQswCQYDVQQGEwJQQTEQ
MA4GA1UEChMHTm9yZFZQTjEYMBYGA1UEAxMPTm9yZFZQTiBSb290IENBMB4XDTE2
MDEwMTAwMDAwMFoXDTM1MTIzMTIzNTk1OVowOTELMAkGA1UEBhMCUEExEDAOBgNV
BAoTB05vcmRWUE4xGDAWBgNVBAMTD05vcmRWUE4gUm9vdCBDQTCCAiIwDQYJKoZI
hvcNAQEBBQADggIPADCCAgoCggIBAMkr/BYhyo0F2upsIMXwC6QvkZps3NN2/eQF
kfQIS1gql0aejsKsEnmY0Kaon8uZCTXPsRH1gQNgg5D2gixdd1mJUvV3dE3y9FJr
XMoDkXdCGBodvKJyU6lcfEVF6/UxHcbBguZK9UtRHS9eJYm3rpL/5huQMCppX7kU
eQ8dpCwd3iKITqwd1ZudDqsWaU0vqzC2H55IyaZ/5/TnCk31Q1UP6BksbbuRcwOV
skEDsm6YoWDnn/IIzGOYnFJRzQH5jTz3j1QBvRIuQuBuvUkfhx1FEwhwZigrcxXu
MP+QgM54kezgziJUaZcOM2zF3lvrwMvXDMfNeIoJABv9ljw969xQ8czQCU5lMVmA
37ltv5Ec9U5hZuwk/9QO1Z+d/r6Jx0mlurS8gnCAKJgwa3kyZw6e4FZ8mYL4vpRR
hPdvRTWCMJkeB4yBHyhxUmTRgJHm6YR3D6hcFAc9cQcTEl/I60tMdz33G6m0O42s
Qt/+AR3YCY/RusWVBJB/qNS94EtNtj8iaebCQW1jHAhvGmFILVR9lzD0EzWKHkvy
WEjmUVRgCDd6Ne3eFRNS73gdv/C3l5boYySeu4exkEYVxVRn8DhCxs0MnkMHWFK6
MyzXCCn+JnWFDYPfDKHvpff/kLDobtPBf+Lbch5wQy9quY27xaj0XwLyjOltpiST
LWae/Q4vAgMBAAGjHTAbMAwGA1UdEwQFMAMBAf8wCwYDVR0PBAQDAgEGMA0GCSqG
SIb3DQEBDQUAA4ICAQC9fUL2sZPxIN2mD32VeNySTgZlCEdVmlq471o/bDMP4B8g
nQesFRtXY2ZCjs50Jm73B2LViL9qlREmI6vE5IC8IsRBJSV4ce1WYxyXro5rmVg/
k6a10rlsbK/eg//GHoJxDdXDOokLUSnxt7gk3QKpX6eCdh67p0PuWm/7WUJQxH2S
DxsT9vB/iZriTIEe/ILoOQF0Aqp7AgNCcLcLAmbxXQkXYCCSB35Vp06u+eTWjG0/
pyS5V14stGtw+fA0DJp5ZJV4eqJ5LqxMlYvEZ/qKTEdoCeaXv2QEmN6dVqjDoTAo
k0t5u4YRXzEVCfXAC3ocplNdtCA72wjFJcSbfif4BSC8bDACTXtnPC7nD0VndZLp
+RiNLeiENhk0oTC+UVdSc+n2nJOzkCK0vYu0Ads4JGIB7g8IB3z2t9ICmsWrgnhd
NdcOe15BincrGA8avQ1cWXsfIKEjbrnEuEk9b5jel6NfHtPKoHc9mDpRdNPISeVa
wDBM1mJChneHt59Nh8Gah74+TM1jBsw4fhJPvoc7Atcg740JErb904mZfkIEmojC
VPhBHVQ9LHBAdM8qFI2kRK0IynOmAZhexlP/aT/kpEsEPyaZQlnBn3An1CRz8h0S
PApL8PytggYKeQmRhl499+6jLxcZ2IegLfqq41dzIjwHwTMplg+1pKIOVojpWA==
-----END CERTIFICATE-----
</ca>
key-direction 1
<tls-auth>
#
# 2048 bit OpenVPN static key
#
-----BEGIN OpenVPN Static key V1-----
e685bdaf659a25a200e2b9e39e51ff03
0fc72cf1ce07232bd8b2be5e6c670143
f51e937e670eee09d4f2ea5a6e4e6996
5db852c275351b86fc4ca892d78ae002
d6f70d029bd79c4d1c26cf14e9588033
cf639f8a74809f29f72b9d58f9b8f5fe
fc7938eade40e9fed6cb92184abb2cc1
0eb1a296df243b251df0643d53724cdb
5a92a1d6cb817804c4a9319b57d53be5
80815bcfcb2df55018cc83fc43bc7ff8
2d51f9b88364776ee9d12fc85cc7ea5b
9741c4f598c485316db066d52db4540e
212e1518a9bd4828219e24b20d88f598
a196c9de96012090e333519ae18d3509
9427e7b372d348d352dc4c85e18cd4b9
3f8a56ddb2e64eb67adfc9b337157ff4
-----END OpenVPN Static key V1-----
</tls-auth>
redirect-gateway def1
dhcp-option DNS 103.86.96.100
dhcp-option DNS 103.86.99.100
script-security 2"""

================
File: src/nyord_vpn/utils/utils.py
================
"""Utility functions and constants for the NordVPN client.

This module contains:
- Logger configuration
- Path constants
- Country ID mapping
- API request headers
- Cache settings
"""

import json
import os

import time
from pathlib import Path

from loguru import logger
from platformdirs import user_cache_dir, user_config_dir

# Application directories
APP_NAME = "nyord-vpn"
APP_AUTHOR = "twardoch"
CACHE_DIR = Path(user_cache_dir(APP_NAME, APP_AUTHOR))
CONFIG_DIR = Path(user_config_dir(APP_NAME, APP_AUTHOR))

# Ensure directories exist
CACHE_DIR.mkdir(parents=True, exist_ok=True)
CONFIG_DIR.mkdir(parents=True, exist_ok=True)

# File paths
PACKAGE_DIR = Path(__file__).parent
DATA_DIR = PACKAGE_DIR / "data"
CACHE_FILE = DATA_DIR / "countries.json"
COUNTRIES_CACHE = CACHE_DIR / "countries.json"
COUNTRY_IDS_FILE = DATA_DIR / "country_ids.json"
STATE_FILE = CACHE_DIR / "vpn_state.json"
OPENVPN_CONFIG = CACHE_DIR / "openvpn.ovpn"
OPENVPN_AUTH = CACHE_DIR / "openvpn.auth"
OPENVPN_LOG = CACHE_DIR / "openvpn.log"

# Cache expiry in seconds (24 hours)
CACHE_EXPIRY = 24 * 60 * 60  # 24 hours in seconds



def is_process_running(process_id):
    try:
        # os.kill(process_id, 0)
        os.system("sudo kill -0 " + str(process_id))
        return True
    except Exception:
        return False

def ensure_data_dir() -> None:
    """Ensure the data directory exists."""
    DATA_DIR.mkdir(parents=True, exist_ok=True)


# Create data directory if it doesn't exist
ensure_data_dir()


# Load country IDs from JSON file
try:
    with open(COUNTRY_IDS_FILE) as f:
        NORDVPN_COUNTRY_IDS: dict[str, str] = json.load(f)
except (FileNotFoundError, json.JSONDecodeError):
    # Fallback data if file doesn't exist or is invalid
    NORDVPN_COUNTRY_IDS = {
        "US": "228",  # United States
        "GB": "227",  # United Kingdom
        "DE": "81",  # Germany
    }

# Browser-like headers for API requests
API_HEADERS = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
    "Accept": "application/json",
    "Accept-Language": "en-US,en;q=0.9",
    "Referer": "https://nordvpn.com/",
    "Origin": "https://nordvpn.com",
}


def save_vpn_state(state: dict) -> None:
    """Save VPN connection state to file.

    The state includes:
    - connected: bool - current connection status
    - initial_ip: str - the original IP before VPN connection
    - connected_ip: str - the IP address when connected to VPN
    - server: str - current VPN server hostname
    - country: str - current VPN server country
    - timestamp: float - when the state was last updated
    """
    try:
        STATE_FILE.write_text(json.dumps(state, indent=2))
    except Exception as e:
        logger.warning(f"Failed to save VPN state: {e}")


def load_vpn_state() -> dict:
    """Load VPN connection state from file."""
    try:
        if STATE_FILE.exists():
            state = json.loads(STATE_FILE.read_text())
            # State is valid for 5 minutes
            if time.time() - state.get("timestamp", 0) < 300:
                return state
    except Exception as e:
        logger.warning(f"Failed to load VPN state: {e}")

    return {
        "connected": False,
        "initial_ip": None,  # Original IP before VPN connection
        "connected_ip": None,  # IP address when connected to VPN
        "server": None,
        "country": None,
        "timestamp": time.time(),
    }

================
File: src/nyord_vpn/__init__.py
================
"""NordVPN client for Python."""

from src.nyord_vpn.core.client import Client
from src.nyord_vpn.storage.models import ConnectionError, CredentialsError, ServerError, DisconnectionError, VPNError

__all__ = [
    "Client",
    "ConnectionError",
    "CredentialsError",
    "DisconnectionError",
    "ServerError",
    "VPNError",
]

================
File: src/nyord_vpn/__main__.py
================
"""Command line interface for nyord-vpn."""

import os
import sys
import json
import subprocess
import time

import fire
from rich.console import Console
from rich.table import Table

from src.nyord_vpn.core.client import Client, VPNError
from src.nyord_vpn.scripts.update_countries import fetch_countries

console = Console()


def _check_root() -> None:
    """Request root privileges using sudo."""
    if os.geteuid() != 0:
        try:
            # Re-run the script with sudo
            args = ["sudo", sys.executable] + sys.argv
            console.print(
                "[yellow]This command requires administrator privileges.[/yellow]"
            )
            console.print("[cyan]Please enter your password when prompted.[/cyan]")
            subprocess.run(args, check=True)
            sys.exit(0)
        except subprocess.CalledProcessError:
            console.print("[red]Error: Administrator privileges required.[/red]")
            console.print("[yellow]Please run the command again with sudo:[/yellow]")
            console.print(f"[blue]sudo {' '.join(sys.argv)}[/blue]")
            sys.exit(1)


class CLI:
    """NordVPN CLI interface."""

    def __init__(self, verbose: bool = False):
        """Initialize CLI."""
        try:
            self.client = Client(verbose=verbose)
        except VPNError as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)

    def go(self, country_code: str) -> None:
        """Connect to VPN in specified country.

        Args:
            country_code: Two-letter country code (e.g. 'us', 'uk')
        """
        _check_root()
        try:
            # First check if we're already connected
            status = self.client.status()
            if status and status.get("status", False):
                self.client.disconnect()

            # Connect to VPN
            self.client.go(country_code)
        except VPNError as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)

    def bye(self) -> None:
        """Disconnect from VPN."""
        _check_root()
        try:
            # First check if we're actually connected
            status = self.client.status()
            if not status or not status.get("status", False):
                console.print("[yellow]Not connected to VPN[/yellow]")
                console.print(f"Normal IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
                return

            # Store the private IP for display
            private_ip = status.get("ip", "Unknown")

            # Disconnect
            self.client.disconnect()

            # Get new status for normal IP
            status = self.client.status()
            console.print("[green]Successfully disconnected from VPN[/green]")
            console.print(f"Normal IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
            console.print(f"Previous Private IP: [yellow]{private_ip}[/yellow]")
        except VPNError as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)

    def info(self) -> None:
        """Show current connection info."""
        try:
            status = self.client.status()
            if status:
                connected = status.get("status", False)
                ip = status.get("ip", "Unknown")
                country = status.get("country", "Unknown")
                server = status.get("server", "Unknown")

                if connected:
                    console.print("[green]VPN Status: Connected[/green]")
                    console.print(f"Private IP: [cyan]{ip}[/cyan]")
                    console.print(f"Country: [cyan]{country}[/cyan]")
                    console.print(f"Server: [cyan]{server}[/cyan]")
                else:
                    console.print("[yellow]VPN Status: Not Connected[/yellow]")
                    console.print(f"Normal IP: [cyan]{ip}[/cyan]")
            else:
                console.print("[yellow]VPN Status: Not Connected[/yellow]")
                console.print(f"Normal IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
        except VPNError as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)

    def where(self, live: bool = False) -> None:
        """List available countries.

        Args:
            live: If True, fetch fresh data from API instead of using cache
        """
        try:
            if live:
                countries = fetch_countries()
            else:
                countries = self.client.countries

            table = Table(title="Available Countries")
            table.add_column("Country", style="cyan")
            table.add_column("Code", style="yellow")
            table.add_column("Servers", justify="right", style="green")
            table.add_column("Cities", justify="right", style="blue")

            for country in sorted(countries, key=lambda x: x["name"]):
                table.add_row(
                    country["name"],
                    country["code"].lower(),
                    str(country["serverCount"]),
                    str(len(country["cities"])),
                )

            console.print(table)
            total_servers = sum(country["serverCount"] for country in countries)
            total_cities = sum(len(country["cities"]) for country in countries)
            console.print(
                f"\nTotal: [cyan]{len(countries)}[/cyan] countries, "
                f"[blue]{total_cities}[/blue] cities, "
                f"[green]{total_servers}[/green] servers"
            )

        except VPNError as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)

    def update(self) -> None:
        """Update country list from NordVPN API."""
        try:
            countries = fetch_countries()
            total_servers = sum(country["serverCount"] for country in countries)
            total_cities = sum(len(country["cities"]) for country in countries)

            with open(self.client.cache_file, "w") as f:
                json.dump(
                    {
                        "countries": countries,
                        "last_updated": time.strftime(
                            "%Y-%m-%dT%H:%M:%SZ", time.gmtime()
                        ),
                    },
                    f,
                    indent=2,
                )

            console.print("[green] Updated country list cache with:[/green]")
            console.print(f"   [cyan]{len(countries)}[/cyan] countries")
            console.print(f"   [blue]{total_cities}[/blue] cities")
            console.print(f"   [green]{total_servers}[/green] servers")
            console.print(f"[blue]Cache file: {self.client.cache_file}[/blue]")

        except Exception as e:
            console.print(f"[red]Error:[/red] {e}")
            sys.exit(1)


def main() -> None:
    """Main entry point."""
    try:
        fire.Fire(CLI)
    except Exception as e:
        console.print(f"[red]Error:[/red] {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()

================
File: src/nyord_vpn/exceptions.py
================
"""Custom exceptions for NordVPN client."""


class VPNError(Exception):
    """Base exception for VPN-related errors."""

    pass

================
File: tests/integration/__init__.py
================
"""Integration tests for nyord_vpn."""

================
File: tests/integration/test_config_loading.py
================
"""Integration tests for configuration loading."""

import pytest
from pathlib import Path
import json

from nyord_vpn.core.client import VPNClient
from nyord_vpn.core.config import VPNConfig
from tests.conftest import TEST_PASSWORD, TEST_USERNAME


@pytest.mark.integration
async def test_file_loading(temp_dir):
    """Test configuration loading from file."""
    # Create config file with all options
    config_file = temp_dir / "config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "default_country": "Sweden",
        "retry_attempts": 5,
        "use_legacy_fallback": False,
        "config_dir": "custom/config/dir",
        "api_timeout": 60,
    }
    config_file.write_text(json.dumps(config_data))

    # Test loading with VPNClient
    client = VPNClient.from_file(config_file)
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.default_country == "Sweden"
    assert client.config.retry_attempts == 5
    assert client.config.use_legacy_fallback is False
    assert client.config.config_dir == Path("custom/config/dir").resolve()
    assert client.config.api_timeout == 60

    # Test loading with VPNConfig
    config = VPNConfig.from_file(config_file)
    assert config.username == TEST_USERNAME
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert config.default_country == "Sweden"
    assert config.retry_attempts == 5
    assert config.use_legacy_fallback is False
    assert config.config_dir == Path("custom/config/dir").resolve()
    assert config.api_timeout == 60


@pytest.mark.integration
async def test_environment_loading_unprefixed(monkeypatch):
    """Test configuration loading from unprefixed environment variables."""
    # Set environment variables
    monkeypatch.setenv("NORD_USER", TEST_USERNAME)
    monkeypatch.setenv("NORD_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Norway")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "4")

    # Test loading with VPNClient
    client = VPNClient.from_env()
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.default_country == "Norway"
    assert client.config.retry_attempts == 4


@pytest.mark.integration
async def test_environment_loading_prefixed(monkeypatch):
    """Test configuration loading from prefixed environment variables."""
    # Set environment variables
    monkeypatch.setenv("NORDVPN_USERNAME", TEST_USERNAME)
    monkeypatch.setenv("NORDVPN_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Sweden")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "5")

    # Test loading with VPNClient
    client = VPNClient.from_env()
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.default_country == "Sweden"
    assert client.config.retry_attempts == 5


@pytest.mark.integration
async def test_environment_loading_precedence(monkeypatch):
    """Test precedence between prefixed and unprefixed environment variables."""
    # Set both prefixed and unprefixed variables
    monkeypatch.setenv("NORD_USER", "unprefixed_user")
    monkeypatch.setenv("NORD_PASSWORD", "unprefixed_pass")
    monkeypatch.setenv("NORDVPN_USERNAME", "prefixed_user")
    monkeypatch.setenv("NORDVPN_PASSWORD", "prefixed_pass")

    # Unprefixed should take precedence
    client = VPNClient.from_env()
    assert client.config.username == "unprefixed_user"
    assert client.config.password.get_secret_value() == "unprefixed_pass"


@pytest.mark.integration
async def test_default_values():
    """Test configuration default values."""
    # Test with minimal configuration
    config = VPNConfig(username="test", password="test")
    assert config.username == "test"
    assert config.password.get_secret_value() == "test"
    assert config.default_country == "United States"
    assert config.retry_attempts == 3
    assert config.use_legacy_fallback is True
    assert config.config_dir == Path.home() / ".config" / "nyord-vpn"
    assert config.api_timeout == 30

    # Test with VPNClient
    client = VPNClient(username="test", password="test")
    assert client.config.username == "test"
    assert client.config.password.get_secret_value() == "test"
    assert client.config.default_country == "United States"
    assert client.config.retry_attempts == 3
    assert client.config.use_legacy_fallback is True
    assert client.config.config_dir == Path.home() / ".config" / "nyord-vpn"
    assert client.config.api_timeout == 30


@pytest.mark.integration
async def test_config_file_precedence(temp_dir, monkeypatch):
    """Test configuration loading precedence between file and environment."""
    # Create config file
    config_file = temp_dir / "config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "default_country": "Sweden",
        "retry_attempts": 5,
    }
    config_file.write_text(json.dumps(config_data))

    # Set environment variables
    monkeypatch.setenv("NORD_USER", "env_user")
    monkeypatch.setenv("NORD_PASSWORD", "env_pass")
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Norway")
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "45")

    # Test with VPNClient - explicit args > file > env > defaults
    client = VPNClient.from_file(
        config_file,
        username="arg_user",
        password=TEST_PASSWORD.get_secret_value(),
    )
    assert client.config.username == "arg_user"  # From arg
    assert (
        client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    )  # From arg
    assert client.config.default_country == "Sweden"  # From file
    assert client.config.retry_attempts == 5  # From file
    assert client.config.api_timeout == 45  # From env
    assert client.config.use_legacy_fallback is True  # Default

    # Test with VPNConfig - file > env > defaults
    config = VPNConfig.from_file(config_file)
    assert config.username == TEST_USERNAME  # From file
    assert (
        config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    )  # From file
    assert config.default_country == "Sweden"  # From file
    assert config.retry_attempts == 5  # From file
    assert config.api_timeout == 45  # From env
    assert config.use_legacy_fallback is True  # Default


@pytest.mark.integration
async def test_config_validation(temp_dir):
    """Test configuration validation."""
    # Test invalid retry attempts
    config_file = temp_dir / "invalid_retry.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "retry_attempts": 0,
    }
    config_file.write_text(json.dumps(config_data))
    with pytest.raises(ValueError, match="ensure this value is greater than 0"):
        VPNConfig.from_file(config_file)

    # Test invalid timeout
    config_file = temp_dir / "invalid_timeout.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "api_timeout": -1,
    }
    config_file.write_text(json.dumps(config_data))
    with pytest.raises(ValueError, match="ensure this value is greater than 0"):
        VPNConfig.from_file(config_file)

    # Test invalid config directory
    config_file = temp_dir / "invalid_dir.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "config_dir": "/nonexistent/dir",
    }
    config_file.write_text(json.dumps(config_data))
    with pytest.raises(ValueError, match="Failed to setup config directory"):
        VPNConfig.from_file(config_file)

    # Test missing required fields
    config_file = temp_dir / "missing_fields.json"
    config_data = {
        "default_country": "Sweden",
        "retry_attempts": 5,
    }
    config_file.write_text(json.dumps(config_data))
    with pytest.raises(ValueError, match="Field required"):
        VPNConfig.from_file(config_file)


def test_load_from_file(tmp_path: Path):
    """Test loading configuration from file."""
    # Create config file
    config_path = tmp_path / "config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "api_timeout": 30,
        "retry_attempts": 5,
    }
    config_path.write_text(json.dumps(config_data))

    # Test client initialization from file
    client = VPNClient(config_file=config_path)
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.api_timeout == 30
    assert client.config.retry_attempts == 5

    # Test direct config loading
    config = VPNConfig.from_file(config_path)
    assert config.username == TEST_USERNAME
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert config.api_timeout == 30
    assert config.retry_attempts == 5


def test_load_from_env(monkeypatch):
    """Test loading configuration from environment variables."""
    # Set environment variables
    monkeypatch.setenv("NORDVPN_USERNAME", TEST_USERNAME)
    monkeypatch.setenv("NORDVPN_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "30")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "5")

    # Test client initialization from env
    client = VPNClient()  # Will load from env by default
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.api_timeout == 30
    assert client.config.retry_attempts == 5

    # Test direct config loading
    config = VPNConfig.from_env()
    assert config.username == TEST_USERNAME
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert config.api_timeout == 30
    assert config.retry_attempts == 5


def test_direct_initialization():
    """Test direct initialization with parameters."""
    # Test config initialization
    config = VPNConfig(
        username=TEST_USERNAME, password=TEST_PASSWORD.get_secret_value()
    )
    assert config.username == TEST_USERNAME
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()

    # Test client initialization
    client = VPNClient(
        username=TEST_USERNAME, password=TEST_PASSWORD.get_secret_value()
    )
    assert client.config.username == TEST_USERNAME
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()


def test_invalid_config_file(tmp_path: Path):
    """Test handling of invalid configuration files."""
    # Test non-existent file
    with pytest.raises(FileNotFoundError):
        VPNConfig.from_file(tmp_path / "nonexistent.json")

    # Test invalid JSON
    invalid_path = tmp_path / "invalid.json"
    invalid_path.write_text("invalid json content")
    with pytest.raises(json.JSONDecodeError):
        VPNConfig.from_file(invalid_path)

    # Test missing required fields
    empty_path = tmp_path / "empty.json"
    empty_path.write_text("{}")
    with pytest.raises(ValueError):
        VPNConfig.from_file(empty_path)


def test_invalid_environment(monkeypatch):
    """Test handling of invalid environment variables."""
    # Test missing required variables
    with pytest.raises(ValueError):
        VPNConfig.from_env()

    # Test invalid values
    monkeypatch.setenv("NORDVPN_USERNAME", TEST_USERNAME)
    monkeypatch.setenv("NORDVPN_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "invalid")
    with pytest.raises(ValueError):
        VPNConfig.from_env()

================
File: tests/integration/test_connection.py
================
"""Integration tests for VPN connection."""

import asyncio
import pytest

from nyord_vpn.core.exceptions import VPNError, VPNConnectionError


@pytest.mark.integration
@pytest.mark.asyncio
async def test_connection_success(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
):
    """Test successful VPN connection."""
    # Test primary API
    async with mock_client as client:
        await client.connect()
        status = await client.status()
        assert status["connected"] is True
        assert status["country"] == "Test Country"
        assert status["ip"] == "1.2.3.4"
        assert status["server"] == "test.server.com"

    # Test fallback API
    mock_client.primary_api.connect.side_effect = VPNError("Primary API failed")
    async with mock_client as client:
        await client.connect()
        status = await client.status()
        assert status["connected"] is True
        assert status["country"] == "Test Country"
        assert status["ip"] == "1.2.3.4"
        assert status["server"] == "test.server.com"


@pytest.mark.integration
@pytest.mark.asyncio
async def test_connection_failure(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
):
    """Test VPN connection failure handling."""
    # Test primary API failure
    mock_client.primary_api.connect.side_effect = VPNError("Primary API failed")
    mock_client.fallback_api.connect.side_effect = VPNError("Fallback API failed")

    with pytest.raises(VPNConnectionError, match="Both primary and fallback failed"):
        async with mock_client as client:
            await client.connect()

    # Test network error
    mock_aiohttp_session.get.side_effect = asyncio.TimeoutError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()

    # Test subprocess error
    mock_subprocess.side_effect = Exception("Subprocess error")
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_country_selection(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
):
    """Test VPN country selection."""
    # Test valid country
    async with mock_client as client:
        await client.connect("Test Country")
        status = await client.status()
        assert status["country"] == "Test Country"

    # Test invalid country
    mock_client.primary_api.connect.side_effect = VPNError("Invalid country")
    mock_client.fallback_api.connect.side_effect = VPNError("Invalid country")
    with pytest.raises(VPNConnectionError, match="Invalid country"):
        async with mock_client as client:
            await client.connect("Invalid Country")

================
File: tests/integration/test_errors.py
================
"""Integration tests for error handling."""

import asyncio
import pytest
from unittest.mock import AsyncMock, MagicMock
import json
from pathlib import Path
import subprocess

from nyord_vpn.core.client import VPNClient
from nyord_vpn.core.exceptions import VPNError, VPNConnectionError, VPNConfigError
from tests.conftest import TEST_PASSWORD, TEST_USERNAME


@pytest.mark.integration
@pytest.mark.asyncio
async def test_network_errors(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
):
    """Test handling of network-related errors."""
    # Test connection timeout
    mock_aiohttp_session.get.side_effect = asyncio.TimeoutError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()

    # Test connection refused
    mock_aiohttp_session.get.side_effect = ConnectionRefusedError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()

    # Test DNS resolution error
    mock_aiohttp_session.get.side_effect = Exception("DNS resolution failed")
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()

    # Test SSL error
    mock_aiohttp_session.get.side_effect = Exception("SSL verification failed")
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
        async with mock_client as client:
            await client.connect()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_subprocess_errors(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
):
    """Test handling of subprocess-related errors."""
    # Test OpenVPN not found
    mock_subprocess.side_effect = FileNotFoundError("openvpn not found")
    with pytest.raises(VPNConfigError):
        async with mock_client as client:
            await client.connect()

    # Test OpenVPN error
    mock_subprocess.side_effect = subprocess.SubprocessError("OpenVPN error")
    with pytest.raises(VPNConnectionError):
        async with mock_client as client:
            await client.connect()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_configuration_errors(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    temp_dir,
):
    """Test handling of configuration-related errors."""
    # Test missing credentials
    with pytest.raises(VPNConfigError, match="Field required"):
        VPNClient()

    # Test invalid config file
    config_file = temp_dir / "invalid.toml"
    config_file.write_text("invalid = toml [ content")
    with pytest.raises(VPNConfigError, match="Failed to load configuration"):
        VPNClient(config_file=config_file)

    # Test non-existent config file
    with pytest.raises(VPNConfigError, match="Failed to load configuration"):
        VPNClient(config_file=temp_dir / "nonexistent.toml")

    # Test invalid config directory
    config_file = temp_dir / "config.toml"
    config_file.write_text(
        """
        username = "test_user"
        password = "test_pass"
        config_dir = "/nonexistent/dir"
        """
    )
    with pytest.raises(VPNConfigError, match="Failed to setup config directory"):
        VPNClient(config_file=config_file)


@pytest.mark.integration
@pytest.mark.asyncio
async def test_api_errors(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
):
    """Test handling of API-related errors."""
    # Test API error response
    mock_aiohttp_session.get.return_value.__aenter__.return_value.json.return_value = {
        "error": "API error"
    }
    with pytest.raises(VPNConnectionError):
        async with mock_client as client:
            await client.connect()

    # Test invalid API response
    mock_aiohttp_session.get.return_value.__aenter__.return_value.json.side_effect = (
        json.JSONDecodeError("Invalid JSON", "{", 0)
    )
    with pytest.raises(VPNConnectionError):
        async with mock_client as client:
            await client.connect()


@pytest.mark.integration
@pytest.mark.asyncio
async def test_error_recovery(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
):
    """Test error recovery behavior."""
    # Test recovery after network error
    mock_aiohttp_session.get.side_effect = [
        asyncio.TimeoutError(),  # First attempt fails
        MagicMock(  # Second attempt succeeds
            status=200,
            json=AsyncMock(
                return_value={
                    "ip": "1.2.3.4",
                    "country": "Test Country",
                    "hostname": "test.server.com",
                }
            ),
        ),
    ]

    async with mock_client as client:
        result = await client.connect()
        assert result is True

        # Verify status
        status = await client.status()
        assert status["connected"] is True

    # Test recovery after subprocess error
    mock_subprocess.side_effect = [
        Exception("First attempt failed"),  # First attempt fails
        MagicMock(  # Second attempt succeeds
            returncode=0,
            communicate=AsyncMock(return_value=(b"Success", b"")),
        ),
    ]

    async with mock_client as client:
        result = await client.connect()
        assert result is True

        # Verify status
        status = await client.status()
        assert status["connected"] is True


@pytest.mark.asyncio
async def test_invalid_credentials():
    """Test handling of invalid credentials."""
    client = VPNClient(username="invalid", password=TEST_PASSWORD.get_secret_value())
    with pytest.raises(VPNConnectionError):
        await client.connect()


@pytest.mark.asyncio
async def test_network_errors():
    """Test handling of network errors."""
    client = VPNClient(
        username=TEST_USERNAME, password=TEST_PASSWORD.get_secret_value()
    )

    # Test connection with network error
    with pytest.raises(VPNConnectionError):
        await client.connect()

    # Test status check with network error
    with pytest.raises(VPNError):
        await client.status()

    # Test country listing with network error
    with pytest.raises(VPNError):
        await client.list_countries()


@pytest.mark.asyncio
async def test_timeout_handling(tmp_path: Path):
    """Test handling of timeouts."""
    # Create config with short timeout
    config_path = tmp_path / "timeout_config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "api_timeout": 1,
    }
    config_path.write_text(json.dumps(config_data))

    client = VPNClient(config_file=config_path)

    # Test connection timeout
    with pytest.raises(VPNConnectionError):
        await client.connect()

    # Test status check timeout
    with pytest.raises(VPNError):
        await client.status()


@pytest.mark.asyncio
async def test_retry_behavior(tmp_path: Path):
    """Test retry behavior on failures."""
    # Create config with retry settings
    config_path = tmp_path / "retry_config.json"
    config_data = {
        "username": TEST_USERNAME,
        "password": TEST_PASSWORD.get_secret_value(),
        "retry_attempts": 2,
    }
    config_path.write_text(json.dumps(config_data))

    client = VPNClient(config_file=config_path)

    # Test connection retries
    with pytest.raises(VPNConnectionError):
        await client.connect()

    # Test status check retries
    with pytest.raises(VPNError):
        await client.status()


@pytest.mark.asyncio
async def test_fallback_behavior():
    """Test fallback to legacy API."""
    client = VPNClient(
        username=TEST_USERNAME,
        password=TEST_PASSWORD.get_secret_value(),
        use_legacy_fallback=True,
    )

    # Test connection with fallback
    assert await client.connect() is True
    status = await client.status()
    assert status["connected"] is True

    # Cleanup
    await client.disconnect()


@pytest.mark.asyncio
async def test_invalid_country():
    """Test handling of invalid country names."""
    client = VPNClient(
        username=TEST_USERNAME, password=TEST_PASSWORD.get_secret_value()
    )

    # Test connection with invalid country
    with pytest.raises(VPNConnectionError):
        await client.connect("Invalid Country")

    # Test connection with empty country
    with pytest.raises(VPNConnectionError):
        await client.connect("")


@pytest.mark.integration
@pytest.mark.asyncio
async def test_cleanup_after_error(
    mock_client,
    mock_aiohttp_session,
    mock_subprocess,
    mock_pycountry,
    mock_env_credentials,
):
    """Test cleanup after errors."""
    # Test cleanup after connection error
    mock_client.primary_api.connect.side_effect = VPNError("Connection failed")
    mock_client.fallback_api.connect.side_effect = VPNError("Connection failed")

    try:
        async with mock_client as client:
            await client.connect()
    except VPNConnectionError:
        pass

    # Verify cleanup
    status = mock_client.status()
    assert status["connected"] is False
    assert status["server"] == ""

================
File: tests/integration/test_validation_integration.py
================
"""Integration tests for validation."""

import os
import pytest

from nyord_vpn.core.exceptions import VPNError
from nyord_vpn.api.njord import NjordVPNClient
from nyord_vpn.api.legacy import LegacyVPNClient


@pytest.fixture(autouse=True)
def clear_env():
    """Clear environment variables before each test."""
    os.environ.pop("NORD_USER", None)
    os.environ.pop("NORD_PASSWORD", None)
    yield
    os.environ.pop("NORD_USER", None)
    os.environ.pop("NORD_PASSWORD", None)


def test_invalid_credentials_njord():
    """Test invalid credentials with Njord API."""
    with pytest.raises(VPNError, match="Missing credentials"):
        NjordVPNClient()


def test_invalid_credentials_legacy():
    """Test invalid credentials with Legacy API."""
    with pytest.raises(VPNError, match="Missing credentials"):
        LegacyVPNClient()


def test_invalid_country_njord():
    """Test invalid country with Njord API."""
    os.environ["NORD_USER"] = "test_user"
    os.environ["NORD_PASSWORD"] = "test_pass"
    with pytest.raises(VPNError):
        client = NjordVPNClient()
        client.connect("Invalid Country")


def test_invalid_country_legacy():
    """Test invalid country with Legacy API."""
    os.environ["NORD_USER"] = "test_user"
    os.environ["NORD_PASSWORD"] = "test_pass"
    with pytest.raises(VPNError):
        client = LegacyVPNClient()
        client.connect("Invalid Country")

================
File: tests/__init__.py
================
"""Test suite for nyord-vpn package."""

================
File: tests/conftest.py
================
"""Test fixtures and configuration."""

from unittest.mock import patch
import json

import pytest

from nyord_vpn.core.client import VPNClient


@pytest.fixture
def mock_env_credentials(monkeypatch):
    """Mock environment variables for testing."""
    monkeypatch.setenv("NORD_USER", "test_user")
    monkeypatch.setenv("NORD_PASSWORD", "test_pass")


@pytest.fixture
def mock_openvpn():
    """Mock OpenVPN command."""
    with patch("subprocess.run") as mock_run:
        mock_run.return_value.stdout = b"OpenVPN 2.5.0\n"
        yield mock_run


@pytest.fixture
def mock_requests():
    """Mock requests for API calls."""
    with patch("requests.get") as mock_get:
        # Mock server recommendations
        mock_get.return_value.json.return_value = [
            {"hostname": "test.server.com", "load": 10, "status": "online"}
        ]
        mock_get.return_value.status_code = 200
        yield mock_get


@pytest.fixture
def mock_process():
    """Mock subprocess for OpenVPN."""
    with patch("subprocess.Popen") as mock_popen:
        mock_popen.return_value.pid = 12345
        mock_popen.return_value.returncode = 0
        yield mock_popen


@pytest.fixture
def mock_client(mock_env_credentials, mock_openvpn, mock_requests, mock_process):
    """Create a mock VPN client."""
    with patch("nyord_vpn.api.legacy.LegacyVPNClient") as mock_legacy:
        # Setup mock APIs
        mock_legacy.return_value.connect.return_value = True
        mock_legacy.return_value.disconnect.return_value = True
        mock_legacy.return_value.status.return_value = {
            "connected": True,
            "country": "Test Country",
            "ip": "1.2.3.4",
            "server": "test.server.com",
        }
        mock_legacy.return_value.list_countries.return_value = [
            {"name": "Country 1", "code": "1"},
            {"name": "Country 2", "code": "2"},
        ]

        # Create client
        client = VPNClient()
        yield client


@pytest.fixture
def temp_config_file(tmp_path):
    """Create a temporary config file."""
    config = {
        "username": "test_user",
        "password": "test_pass",
        "default_country": "us",
        "use_legacy_fallback": True,
    }

    config_file = tmp_path / "config.json"
    config_file.write_text(json.dumps(config))
    return config_file


@pytest.fixture
def mock_ip_info():
    """Mock IP info response."""
    with patch("requests.get") as mock_get:
        mock_get.return_value.json.return_value = {
            "ip": "1.2.3.4",
            "country": "US",
            "org": "NordVPN",
        }
        mock_get.return_value.status_code = 200
        yield mock_get

================
File: tests/test_client.py
================
"""Tests for VPN client."""

import pytest

from nyord_vpn.core.exceptions import VPNError


def test_client_connect(mock_client):
    """Test VPN client connect."""
    # Test successful connection
    result = mock_client.connect("Test Country")
    assert result is True

    # Test connection status
    status = mock_client.status()
    assert status["connected"] is True
    assert status["country"] == "Test Country"
    assert status["ip"] == "1.2.3.4"
    assert status["server"] == "test.server.com"


def test_client_disconnect(mock_client):
    """Test VPN client disconnect."""
    # Connect first
    mock_client.connect("Test Country")

    # Test disconnection
    result = mock_client.disconnect()
    assert result is True

    # Test status after disconnect
    status = mock_client.status()
    assert status["connected"] is False


def test_client_list_countries(mock_client):
    """Test VPN client country listing."""
    countries = mock_client.list_countries()
    assert isinstance(countries, list)
    assert len(countries) > 0
    assert all(isinstance(c, dict) for c in countries)
    assert all("name" in c and "code" in c for c in countries)


def test_client_error_handling(mock_client, mocker):
    """Test VPN client error handling."""
    # Mock API to raise error
    mocker.patch.object(
        mock_client._connect,
        "__call__",
        side_effect=VPNError("Test error"),
    )

    # Test error handling
    with pytest.raises(VPNError, match="Test error"):
        mock_client.connect("Test Country")


@pytest.mark.asyncio
async def test_client_context_manager(mock_client):
    """Test VPN client context manager."""
    async with mock_client as client:
        # Test connection inside context
        result = await client.connect("Test Country")
        assert result is True

        # Test status
        status = await client.status()
        assert status["connected"] is True

    # Test auto-disconnect after context
    status = await mock_client.status()
    assert status["connected"] is False

================
File: tests/test_legacy_api.py
================
"""Tests for LegacyVPNClient implementation."""

import pytest
import requests
import os
import subprocess

from nyord_vpn.core.exceptions import VPNError
from nyord_vpn.api.legacy import LegacyVPNClient


def test_init(mock_env_credentials, mock_openvpn):
    """Test LegacyVPNClient initialization."""
    api = LegacyVPNClient()
    assert api.username == os.getenv("NORD_USER")
    assert isinstance(api.password, str)
    assert api.password == os.getenv("NORD_PASSWORD")


def test_connect_success(
    mock_env_credentials, mock_openvpn, mock_requests, mock_process, mock_ip_info
):
    """Test successful connection."""
    api = LegacyVPNClient()
    assert api.connect() is True


def test_connect_failure(
    mock_env_credentials, mock_openvpn, mock_requests, mock_process
):
    """Test connection failure."""
    mock_process.side_effect = requests.RequestException("Failed to connect")
    api = LegacyVPNClient()
    with pytest.raises(VPNError, match="Failed to connect"):
        api.connect()


def test_disconnect_success(mock_env_credentials, mock_openvpn, mock_process):
    """Test successful disconnection."""
    api = LegacyVPNClient()
    assert api.disconnect() is True


def test_status_connected(mock_env_credentials, mock_openvpn, mock_ip_info):
    """Test status when connected."""
    api = LegacyVPNClient()
    status = api.status()
    assert status["connected"] is True
    assert status["country"] == "US"
    assert status["ip"] == "1.2.3.4"
    assert status["server"] == ""


def test_list_countries(mock_env_credentials, mock_openvpn, mock_requests):
    """Test listing available countries."""
    mock_requests.return_value.json.return_value = [
        {"name": "United States", "id": 228},
        {"name": "United Kingdom", "id": 227},
    ]
    api = LegacyVPNClient()
    countries = api.list_countries()
    assert len(countries) == 2
    assert all(isinstance(c, dict) for c in countries)
    assert all("name" in c and "code" in c for c in countries)
    assert countries[0]["name"] == "United Kingdom"
    assert countries[1]["name"] == "United States"


def test_openvpn_not_found(mock_env_credentials):
    """Test OpenVPN not found error."""
    with pytest.raises(VPNError, match="OpenVPN not found"):
        LegacyVPNClient()


def test_server_not_found(mock_env_credentials, mock_openvpn, mock_requests):
    """Test server not found error."""
    mock_requests.return_value.json.return_value = []
    api = LegacyVPNClient()
    with pytest.raises(VPNError, match="No servers found"):
        api.connect("invalid_country")


def test_config_download_error(mock_env_credentials, mock_openvpn, mock_requests):
    """Test config download error."""
    mock_requests.side_effect = requests.RequestException("Failed to download")
    api = LegacyVPNClient()
    with pytest.raises(VPNError, match="Failed to download"):
        api.connect()


def test_process_error(mock_env_credentials, mock_openvpn, mock_requests, mock_process):
    """Test process error handling."""
    mock_process.side_effect = subprocess.SubprocessError("Process failed")
    api = LegacyVPNClient()
    with pytest.raises(VPNError, match="Failed to connect"):
        api.connect()


def test_api_credentials():
    """Test API credentials are set correctly."""
    api = LegacyVPNClient()
    assert api.username == os.getenv("NORD_USER")
    assert api.password == os.getenv("NORD_PASSWORD")

================
File: tests/test_package.py
================
"""Test suite for nyord_vpn."""

def test_version():
    """Verify package exposes version."""
    import nyord_vpn
    assert nyord_vpn.__version__

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.toml
================
# Package configuration
[package]
include_cli = true        # Include CLI boilerplate
include_logging = true    # Include logging setup
use_pydantic = true      # Use Pydantic for data validation
use_rich = true          # Use Rich for terminal output

[features]
mkdocs = false           # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows

================
File: pyproject.toml
================
# this_file: pyproject.toml
[build-system]
requires = ["setuptools>=45", "setuptools-scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "nyord-vpn"
version = "0.1.0"
description = "NordVPN client with API fallback support"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT"}
keywords = ["vpn", "nordvpn", "security"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "njord>=0.0.1",
    "tenacity>=8.0.0",
    "backoff>=2.0.0",
    "rich>=13.4.2",
    "fire>=0.7.0",
    "pydantic>=2.10.6",
    "pydantic-settings>=2.8.0",
    "requests>=2.31.0",
    "keyring>=24.2.0",
    "pycountry>=24.6.1",
    "psutil>=5.9.5",
    "python-dotenv>=1.0.0",
    "aiohttp>=3.11.0",
    "cryptography>=42.0.0",
    "black>=23.7.0",
    "bleach>=6.0.0",
    "build>=0.10.0",
    "certifi>=2023.5.7",
    "charset-normalizer>=3.2.0",
    "click>=8.1.5",
    "docutils>=0.20.1",
    "idna>=3.4",
    "importlib-metadata>=6.8.0",
    "jaraco-classes>=3.3.0",
    "markdown-it-py>=3.0.0",
    "mdurl>=0.1.2",
    "more-itertools>=9.1.0",
    "mypy-extensions>=1.0.0",
    "packaging>=23.1",
    "pathspec>=0.11.1",
    "pkginfo>=1.9.6",
    "platformdirs>=3.9.1",
    "pygments>=2.15.1",
    "pyproject-hooks>=1.0.0",
    "readme-renderer>=40.0",
    "requests-toolbelt>=1.0.0",
    "rfc3986>=2.0.0",
    "six>=1.16.0",
    "tomli>=2.0.1",
    "twine>=4.0.2",
    "typing-extensions>=4.7.1",
    "urllib3>=2.0.3",
    "webencodings>=0.5.1",
    "zipp>=3.16.2",
    "loguru>=0.7.3",
]

[project.optional-dependencies]
dev = [
    "pre-commit>=3.6.0",
    "ruff>=0.1.0",
    "mypy>=1.0.0",
    "pyupgrade>=3.19.0",
]

test = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.25.0",
    "pytest-mock>=3.12.0",
    "pytest-timeout>=2.3.0",
    "pytest-xdist>=3.5.0",
]

[project.scripts]
nyord-vpn = "nyord_vpn.__main__:main"

[tool.setuptools]
package-dir = {"" = "src"}
packages = ["nyord_vpn"]
package-data = {"nyord_vpn" = ["data/*.json"]}

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/nyord-vpn#readme"
Issues = "https://github.com/twardoch/nyord-vpn/issues"
Source = "https://github.com/twardoch/nyord-vpn"

[tool.coverage.paths]
nyord_vpn = ["src/nyord_vpn", "*/nyord-vpn/src/nyord_vpn"]
tests = ["tests", "*/nyord-vpn/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
]

[tool.coverage.run]
source_pkgs = ["nyord_vpn", "tests"]
branch = true
parallel = true
omit = [
    "src/nyord_vpn/__about__.py",
]

[tool.hatch.build.hooks.vcs]
version-file = "src/nyord_vpn/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/nyord_vpn"]

[tool.hatch.envs.default]
dependencies = [
]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests {args:tests}"
type-check = "mypy src/nyord_vpn tests"
lint = ["ruff check src/nyord_vpn tests", "ruff format --respect-gitignore src/nyord_vpn tests"]
fix = ["ruff check  --fix --unsafe-fixes src/nyord_vpn tests", "ruff format --respect-gitignore src/nyord_vpn tests"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/nyord_vpn tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.25.0",
    "pytest-mock>=3.12.0",
    "pytest-timeout>=2.3.0",
    "pytest-xdist>=3.5.0",
]

[tool.hatch.envs.test.scripts]
test = "python -m pytest {args:tests}"
test-cov = "python -m pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests {args:tests}"
bench = "python -m pytest -v tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[tool.ruff]
target-version = "py310"
line-length = 88

[tool.ruff.lint]
extend-select = [
    "A",
    "ARG",
    "B",
    "C",
    "DTZ",
    "E",
    "EM",
    "F",
    "FBT",
    "I",
    "ICN",
    "ISC",
    "N",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "Q",
    "RUF",
    "S",
    "T",
    "TID",
    "UP",
    "W",
    "YTT",
]
ignore = ["ARG001", "E501", "I001", "RUF001", "PLR2004", "EXE003", "ISC001"]

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase --timeout=30 -n auto"
asyncio_mode = "strict"
asyncio_default_fixture_loop_scope = "function"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning",
    "ignore::pytest.PytestDeprecationWarning",
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "async_test: mark a test as an async test",
    "config: mark a test as a configuration test",
    "connection: mark a test as a connection test",
    "security: mark a test as a security test",
]
testpaths = ["tests"]
timeout = 30

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]

================
File: README.md
================
# nyord-vpn

A simple and reliable NordVPN client for macOS with support for both legacy OpenVPN and njord APIs.

## Features

- Simple and reliable VPN connection management
- Support for both legacy OpenVPN and njord APIs
- Country selection
- Basic status monitoring
- Clear error messages
- Minimal dependencies

## Installation

```bash
# Install system requirements
brew install openvpn

# Install package
pip install nyord-vpn

# Optional: Install njord support
pip install nyord-vpn[njord]
```

## Usage

### Environment Variables

Set your NordVPN credentials:

```bash
export NORD_USER="your-username"
export NORD_PASSWORD="your-password"
```

### CLI Commands

```bash
# Connect to VPN (defaults to US)
nyord-vpn connect

# Connect to specific country
nyord-vpn connect --country netherlands

# Use njord API
nyord-vpn --api njord connect

# Enable debug logging
nyord-vpn --verbose connect

# Check status
nyord-vpn status

# List available countries
nyord-vpn list-countries

# Disconnect
nyord-vpn disconnect
```

### Python API

```python
from nyord_vpn.core.factory import create_client

# Create client (legacy or njord)
client = create_client("legacy")

# Connect to VPN
client.connect("netherlands")

# Check status
status = client.status()
print(f"Connected to {status['server']} ({status['ip']})")

# Disconnect
client.disconnect()
```

## Development

```bash
# Install dependencies
pip install -r requirements.txt

# Install optional njord support
pip install njord

# Run with debug logging
NORD_USER="username" NORD_PASSWORD="password" nyord-vpn --verbose connect
```

## Error Handling

The client uses simple retry logic for API calls and provides clear error messages. Common errors:

- `VPNCredentialsError`: Missing or invalid credentials
- `VPNConnectionError`: Failed to connect/disconnect
- `VPNConfigError`: Configuration issues (e.g., missing OpenVPN)
- `VPNServerError`: Failed to get server information

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Submit a pull request

## License

MIT

================
File: test_auth.txt
================
your_nordvpn_username
your_nordvpn_password

================
File: TODO.md
================
# TODO

Do it! Remember, keep it simple, effective, eyes on the goal!

### 0.1. Enhanced Server Selection

- [ ] Switch to v2/servers API for better efficiency:
  ```python
  def get_servers_cache() -> dict:
      """Fetch and cache full server list from v2/servers:
      1. Single API call to get all servers
      2. Cache for hour
      3. Local filtering by country/load/features
      """
  ```
- [ ] Implement fast server selection:
  ```python
  def select_fastest_server(country_code: str, servers: dict) -> str:
      """Select fastest server:
      1. Filter cached servers by country
      2. Take top 5 by load
      3. Parallel ping test
      4. Return fastest responding server
      """
  ```

### 0.2. Simplified Setup
- [ ] Create one-command initialization:
  ```bash
  nyord init  # Sets up everything needed
  ```
  - Validate OpenVPN installation
  - Create config directories
  - Set up credential storage
  - Test API connectivity
  - Generate initial config

### 0.3. API Usage Optimization
- [ ] Switch to https://api.nordvpn.com/v2/servers for server data fetching (the local "cached" file should be made compatible with the v2 format)
- [ ] Retire both https://api.nordvpn.com/v1/servers/countries and https://api.nordvpn.com/v1/servers/recommendations  the v2 API is better because we don't want a list of all countries in the world, just the ones that have servers :) 
  - Single API call instead of multiple v1 endpoints
  - Local filtering instead of multiple API requests
  - Simpler error handling (only one endpoint)

Keep it focused on these core improvements that directly enhance user experience.

### 0.4. Retry, switch gears

- [ ] Make sure that if the country is not specified, we choose the country randomly
- [ ] Implement a bool parameter "random" that chooses a random server (rather than "the fasterst") from the country 
- [ ] When we're connecting, we should retry connection once and if that's not successful, we should try another random server from the same country. See below for some ideas. 



### 0.5. ANALYSIS FOR "RETRY, SWITCH GEARS"

Outofthebox, both reengage and tenacity are designed to reinvoke your function with the same arguments on each attempt. They dont automatically step through a list of alternative parameter values. 

That said, with tenacity you can customize the retry behavior by using callback hooks (such as the after hook) to modify the functions keyword arguments between attempts. For example, you can write a small helper like this:

```python
from tenacity import retry, stop_after_attempt, RetryCallState

def update_B(new_value):
    def after_callback(retry_state: RetryCallState):
        # Update the value for the parameter "B" for the next attempt
        retry_state.kwargs['B'] = new_value
    return after_callback

# First, try with B=5 (the default).
# After two failures, update B to 7.
@retry(stop=stop_after_attempt(2), after=update_B(7))
def func(A, B=5):
    print(f"Attempt with B={B}")
    # Example failure condition
    if B < 11:
        raise Exception("Not high enough!")
    return f"Success with B={B}"

try:
    result = func("some_value")
except Exception as e:
    # You might even chain another retry that sets B to 11 after another round
    print("Initial retry block failed:", e)
    # You can redecorate or call a wrapper that uses the next parameter value.
    # For example, you could write a loop that tries B from a list [5,7,11]
    for new_B in [7, 11]:
        try:
            result = func("some_value", B=new_B)
            break
        except Exception:
            continue
    else:
        result = None

print("Result:", result)
```

In this example, the tenacity decorators after hook is used to modify the value of B for the next attempt. (A similar idea was discussed on Stack Overflow, where an answer demonstrated using an aftercallback to change a parameter dynamically.) citeturn0search0

If you need a more complex sequence (like try with B=5, if that fails twice then use B=7, then 11), you might either chain multiple decorators or, more simply, write a custom wrapper that iterates over your list of values and calls your function accordingly.

In summary, while neither library provides a oneline decorator that automatically steps through alternative argument values, tenacitys flexible callback hooks let you implement that behavior with a bit of extra code.

Both the **Re-Engage** and **Tenacity** libraries provide decorators for retrying functions until success or failure, but they do not natively support the specific use case of trying different arguments upon failure. However, you can implement this functionality using a combination of decorators and custom logic.

## 1. Overview of Libraries

### 1.1. Re-Engage
- **Re-Engage** is a fork of the original backoff library, designed for retrying function calls with decorators like `@backoff.on_exception` and `@backoff.on_predicate`. These decorators allow you to specify conditions under which to retry a function based on exceptions or return values[1].

### 1.2. Tenacity
- **Tenacity** is a general-purpose retrying library that simplifies adding retry behavior to functions. It allows for extensive customization through decorators like `@retry`, which can be configured with various parameters such as maximum attempts, delay between retries, and conditions for retrying[2].

## 2. Implementing Dynamic Argument Retrying

To achieve the desired behavior of trying different arguments after failures, you can create a custom decorator that wraps your function and manages the argument variations. Heres an example implementation:

```python
from tenacity import retry, stop_after_attempt

def dynamic_retry(args_list):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for args in args_list:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"Failed with args {args}: {e}")
            raise Exception("All attempts failed.")
        return wrapper
    return decorator

@dynamic_retry([(5,), (7,), (11,)])  # List of argument tuples
def my_function(b):
    # Simulate a function that may fail
    if b != 11:  # Let's say it fails unless b is 11
        raise ValueError("Failed!")
    return "Success!"

# Usage
result = my_function(5)  # This will try 5, then 7, then 11.
print(result)  # Outputs: Success!
```

### 2.1. Explanation:
- The `dynamic_retry` decorator takes a list of argument tuples.
- The `wrapper` function iterates over these arguments, attempting to call the target function.
- If an exception occurs, it catches the error, logs it, and moves on to the next set of arguments.
- If all attempts fail, it raises an exception.

## 3. Conclusion

While neither Re-Engage nor Tenacity directly supports dynamically changing function arguments upon failure out-of-the-box, you can implement this functionality using custom decorators. This approach allows you to maintain flexibility in your retry logic while leveraging the robust features provided by existing libraries.

Based on the search results and your specific question about retrying with different arguments, I'll provide a comprehensive answer about implementing such functionality.

Let me break this down step by step:

### 3.1. Current State of Retry Libraries

The common retry libraries like `tenacity` and `re-engage` focus primarily on retrying with the same arguments. While they're powerful for basic retry scenarios, they don't directly support changing arguments between retries [0].

### 3.2. Custom Solution Implementation

Here's a custom decorator implementation that allows retrying with different arguments:

```python
from functools import wraps
from typing import List, Any, Callable
import time

def retry_with_different_args(arg_sequences: List[Any], delay: int = 1):
    """
    Retry decorator that attempts the function with different argument values.
    
    Args:
        arg_sequences: List of values to try for the decorated function's first argument
        delay: Delay between retries in seconds
    """
    def decorator(func: Callable):
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            
            # Replace the first argument with each value in the sequence
            for arg_value in arg_sequences:
                try:
                    new_args = (arg_value,) + args[1:]
                    return func(*new_args, **kwargs)
                except Exception as e:
                    last_exception = e
                    print(f"Attempt with value {arg_value} failed: {str(e)}")
                    time.sleep(delay)
            
            # If we get here, all attempts failed
            raise last_exception or Exception("All retry attempts failed")
            
        return wrapper
    return decorator
```

Example usage:

```python
# Example using the decorator
@retry_with_different_args([5, 7, 11])
def divide_number(divisor: int, number: int = 100):
    if divisor == 7:
        raise ValueError("Don't like 7")
    return number / divisor

# This will try with divisor=5, then 7, then 11
try:
    result = divide_number(5, number=100)
    print(f"Success: {result}")
except Exception as e:
    print(f"Final failure: {e}")
```

### 3.3. Key Points to Consider

1. **Flexibility**: This implementation allows you to specify a sequence of values to try for a specific argument [0].

2. **Error Handling**: Each attempt is wrapped in a try-except block, allowing you to catch and handle specific exceptions [0].

3. **Delay Control**: You can specify delays between attempts to prevent overwhelming systems [0].

### 3.4. Best Practices

1. **Specific Exceptions**: Always catch specific exceptions rather than using a broad Exception catch.

2. **Logging**: Include proper logging to track retry attempts and failures.

3. **Timeout Consideration**: Consider implementing an overall timeout mechanism.

4. **State Management**: Be careful with stateful operations when retrying with different arguments.

### 3.5. Alternative Approach Using Tenacity

While tenacity doesn't directly support changing arguments, you can achieve similar functionality by combining it with a custom retry strategy:

```python
from tenacity import retry, stop_after_attempt
from functools import partial

def retry_sequence(func, arg_sequences):
    for arg in arg_sequences:
        try:
            return func(arg)
        except Exception:
            continue
    raise Exception("All attempts failed")

# Usage example
@retry(stop=stop_after_attempt(1))
def wrapped_function(x):
    return retry_sequence(some_function, [5, 7, 11])
```

This solution provides a way to work with existing retry libraries while adding the functionality to try different arguments, though it's not as elegant as the custom decorator approach.



================================================================
End of Codebase
================================================================
