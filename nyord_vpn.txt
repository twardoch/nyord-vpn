This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/**/*.md, .venv/**, _private/**, CLEANUP.txt, **/*.json, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    filetree.mdc
    nyord-vpn.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  nyord_vpn/
    api/
      __init__.py
      api.py
      v1_countries.py
      v1_groups.py
      v1_recommendations.py
      v1_technologies.py
      v2_servers.py
    core/
      __init__.py
      api.py
      base.py
      client.py
    data/
      .specstory/
        history/
          .what-is-this.md
    network/
      __init__.py
      country.py
      server.py
      vpn_commands.py
      vpn.py
    scripts/
      __init__.py
      update_countries.py
    storage/
      __init__.py
      models.py
      state.py
    utils/
      __init__.py
      connection.py
      templates.py
      utils.py
    __init__.py
    __main__.py
    exceptions.py
tests/
  integration/
    __init__.py
    test_config_loading.py
    test_connection.py
    test_errors.py
    test_validation_integration.py
  __init__.py
  conftest.py
  test_api.py
  test_client.py
  test_legacy_api.py
  test_package.py
  test_server_manager.py
  test_v1_countries.py
  test_v1_groups.py
  test_v1_recommendations.py
  test_v1_technologies.py
  test_v2_servers.py
.gitignore
.pre-commit-config.yaml
cleanup.py
LICENSE
package.toml
PROGRESS.md
pyproject.toml
README.md
TODO.md

================================================================
Files
================================================================

================
File: .cursor/rules/filetree.mdc
================
---
description: File tree of the project
globs: 
---
[ 896]  .
├── [  96]  .cursor
│   └── [ 128]  rules
│       ├── [9.5K]  filetree.mdc
│       └── [4.0K]  nyord-vpn.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 532]  .pre-commit-config.yaml
├── [ 128]  .specstory
│   └── [2.1K]  history
│       ├── [2.0K]  .what-is-this.md
│       ├── [452K]  2025-02-22_19-00-comparison-of-njord-and-nyord-vpn-implementations.md
│       ├── [ 913]  2025-02-22_19-00-fixing-logging-format-error-in-python.md
│       ├── [167K]  2025-02-22_20-24-managing-todos-and-development-tasks.md
│       ├── [8.3K]  2025-02-22_21-08-final-decision-and-todo-update.md
│       ├── [203K]  2025-02-22_21-21-git-management-and-todo-updates.md
│       ├── [ 39K]  2025-02-22_21-59-git-management-and-todo-updates.md
│       ├── [363K]  2025-02-22_22-27-git-management-and-todo-updates.md
│       ├── [ 52K]  2025-02-22_23-26-nordvpn-client-implementation-discussion.md
│       ├── [137K]  2025-02-22_23-35-task-management-and-project-update.md
│       ├── [ 58K]  2025-02-22_23-55-updating-todo-md-and-project-management.md
│       ├── [ 61K]  2025-02-23_00-02-task-management-and-collaboration-strategy.md
│       ├── [165K]  2025-02-23_00-09-updating-todo-md-and-task-prioritization.md
│       ├── [217K]  2025-02-23_01-01-codebase-analysis-and-optimization-discussion.md
│       ├── [101K]  2025-02-23_01-43-importerror-in-nyord-vpn-module.md
│       ├── [ 53K]  2025-02-23_01-55-understanding-vpn-cli-commands-and-issues.md
│       ├── [216K]  2025-02-23_02-15-python-virtual-environment-setup-and-testing.md
│       ├── [ 26K]  2025-02-23_02-34-vpn-connection-troubleshooting-with-python.md
│       ├── [189K]  2025-02-23_04-09-executing-python-vpn-connection-command.md
│       ├── [156K]  2025-02-23_04-56-vpn-connection-troubleshooting.md
│       ├── [ 44K]  2025-02-23_05-42-vpn-connection-status-troubleshooting.md
│       ├── [2.9K]  2025-02-23_05-54-comparing-vpn-management-tools-openpyn-vs-nyord.md
│       ├── [ 16K]  2025-02-23_06-04-untitled.md
│       ├── [ 16K]  2025-02-23_06-09-improving-nyord-vpn-server-selection-and-setup.md
│       ├── [ 76K]  2025-02-23_06-46-implementing-todo-items-in-project.md
│       ├── [156K]  2025-02-23_06-52-code-optimization-and-refactoring-discussion.md
│       ├── [227K]  2025-02-23_07-19-vpn-connection-troubleshooting-log.md
│       ├── [673K]  2025-02-23_07-30-vpn-connection-issues-and-server-selection-errors.md
│       ├── [432K]  2025-02-23_07-55-vpn-client-initialization-and-connection-logs.md
│       ├── [359K]  2025-02-23_08-03-nordvpn-client-initialization-logs.md
│       ├── [410K]  2025-02-23_08-18-vpn-client-frustrations-and-logs.md
│       ├── [6.0K]  2025-02-23_23-48-hierarchical-representation-of-codebase-structure.md
│       ├── [7.9K]  2025-02-23_23-48-nordvpn-client-codebase-organization.md
│       ├── [ 93K]  2025-02-24_00-09-code-analysis-and-docstring-enhancement.md
│       ├── [2.8K]  2025-02-24_01-16-vpn-configuration-file-retrieval-and-security.md
│       ├── [ 70K]  2025-02-24_01-29-improving-nyord-vpn-configuration-method.md
│       ├── [ 42K]  2025-02-24_01-47-openvpn-configuration-and-debugging.md
│       ├── [ 95K]  2025-02-24_02-10-vpn-connection-error-troubleshooting.md
│       ├── [ 58K]  2025-02-24_02-47-vpn-connection-troubleshooting-openvpn-auth-failure.md
│       ├── [ 12K]  2025-02-24_03-15-questioning-openvpn-command-location-in-code.md
│       ├── [ 20K]  2025-02-24_03-31-untitled.md
│       ├── [184K]  2025-02-24_03-36-zip-extraction-to-cache-directory.md
│       ├── [224K]  2025-02-24_04-13-vpn-connection-management-and-ip-tracking-issues.md
│       ├── [1.8M]  2025-02-24_04-43-vpn-connection-debugging-and-ip-verification.md
│       ├── [168K]  2025-02-24_05-02-optimizing-vpn-config-extraction-process.md
│       ├── [579K]  2025-02-24_05-33-vpn-connection-troubleshooting-and-debugging.md
│       ├── [287K]  2025-02-24_06-17-vpn-connection-management-with-nyord-vpn.md
│       ├── [210K]  2025-02-24_06-58-vpn-connection-troubleshooting.md
│       ├── [105K]  2025-02-24_07-15-vpn-connection-troubleshooting-and-improvements.md
│       ├── [6.2K]  2025-02-24_07-20-fixing-import-error-in-vpn-module.md
│       ├── [1006K]  2025-02-24_07-36-fixing-importerror-in-nyord-vpn-code.md
│       ├── [618K]  2025-02-24_07-57-vpn-server-connection-debugging.md
│       ├── [403K]  2025-02-24_08-01-vpn-server-selection-errors-and-debugging.md
│       ├── [245K]  2025-02-24_08-10-vpn-server-availability-issues.md
│       ├── [244K]  2025-02-24_17-19-vpn-country-resolution-issue.md
│       ├── [164K]  2025-02-24_17-43-vpn-connection-issue-no-servers-in-germany.md
│       ├── [ 20K]  2025-02-24_18-03-refining-api-documentation-and-structure.md
│       ├── [ 25K]  2025-02-24_18-41-script-modification-for-repomix-command.md
│       ├── [148K]  2025-02-24_19-08-tracking-todo-and-progress-updates.md
│       ├── [ 39K]  2025-02-24_19-49-review-and-update-project-documentation.md
│       ├── [ 59K]  2025-02-24_20-10-task-management-for-nyord-vpn-project.md
│       ├── [ 47K]  2025-02-24_20-54-placeholder-message.md
│       ├── [ 64K]  2025-02-24_21-51-codebase-review-and-task-prioritization.md
│       ├── [ 54K]  2025-02-24_22-08-reviewing-progress-and-todo-for-codebase-tasks.md
│       ├── [271K]  2025-02-24_23-18-updating-todo-and-progress-for-codebase.md
│       └── [108K]  2025-02-25_00-29-codebase-todo-and-progress-update.md
├── [ 160]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [9.9K]  PROGRESS.md
├── [5.5K]  README.md
├── [ 13K]  TODO.md
├── [ 13K]  cleanup.py
├── [  96]  dist
│   └── [   1]  .gitkeep
├── [174K]  nyord_vpn.txt
├── [ 426]  package.toml
├── [6.9K]  pyproject.toml
├── [ 192]  src
│   ├── [   0]  __init__.py
│   └── [ 448]  nyord_vpn
│       ├── [2.4K]  __init__.py
│       ├── [2.5K]  __main__.py
│       ├── [ 512]  api
│       │   ├── [ 327]  __init__.py
│       │   ├── [ 17K]  api.py
│       │   ├── [ 27K]  v1_countries.json
│       │   ├── [5.4K]  v1_countries.py
│       │   ├── [5.2K]  v1_groups.json
│       │   ├── [5.0K]  v1_groups.py
│       │   ├── [ 67K]  v1_recommendations.json
│       │   ├── [7.0K]  v1_recommendations.py
│       │   ├── [4.2K]  v1_technologies.json
│       │   ├── [3.9K]  v1_technologies.py
│       │   ├── [ 97K]  v2_servers.json
│       │   └── [ 11K]  v2_servers.py
│       ├── [ 256]  core
│       │   ├── [ 178]  __init__.py
│       │   ├── [ 12K]  api.py
│       │   ├── [8.2K]  base.py
│       │   └── [ 14K]  client.py
│       ├── [ 192]  data
│       │   ├── [  96]  .specstory
│       │   │   └── [  96]  history
│       │   │       └── [2.0K]  .what-is-this.md
│       │   ├── [ 93K]  countries.json
│       │   └── [ 963]  country_ids.json
│       ├── [6.8K]  exceptions.py
│       ├── [ 288]  network
│       │   ├── [ 204]  __init__.py
│       │   ├── [1.0K]  country.py
│       │   ├── [ 39K]  server.py
│       │   ├── [ 47K]  vpn.py
│       │   └── [ 14K]  vpn_commands.py
│       ├── [ 192]  scripts
│       │   ├── [  37]  __init__.py
│       │   └── [3.0K]  update_countries.py
│       ├── [ 224]  storage
│       │   ├── [ 212]  __init__.py
│       │   ├── [8.0K]  models.py
│       │   └── [4.0K]  state.py
│       └── [ 288]  utils
│           ├── [ 194]  __init__.py
│           ├── [3.8K]  connection.py
│           ├── [  64]  data
│           ├── [ 12K]  templates.py
│           └── [9.4K]  utils.py
├── [ 544]  tests
│   ├── [  40]  __init__.py
│   ├── [2.6K]  conftest.py
│   ├── [ 288]  integration
│   │   ├── [  39]  __init__.py
│   │   ├── [ 12K]  test_config_loading.py
│   │   ├── [2.9K]  test_connection.py
│   │   ├── [9.3K]  test_errors.py
│   │   └── [1.4K]  test_validation_integration.py
│   ├── [6.5K]  test_api.py
│   ├── [2.0K]  test_client.py
│   ├── [3.5K]  test_legacy_api.py
│   ├── [ 159]  test_package.py
│   ├── [6.4K]  test_server_manager.py
│   ├── [4.2K]  test_v1_countries.py
│   ├── [4.7K]  test_v1_groups.py
│   ├── [5.7K]  test_v1_recommendations.py
│   ├── [3.2K]  test_v1_technologies.py
│   └── [8.6K]  test_v2_servers.py
└── [264K]  uv.lock

22 directories, 137 files

================
File: .cursor/rules/nyord-vpn.mdc
================
---
description: nyord-vpn
globs: *.py
---
# nyord-vpn

A modern Python client for NordVPN with automatic API fallback support, providing both a CLI interface and a Python library.

```bash
# Install system requirements first
brew install openvpn  # macOS
sudo apt install openvpn  # Ubuntu/Debian
sudo dnf install openvpn  # Fedora/RHEL

# Then install and use the package
pip install nyord-vpn
export NORD_USER="username" NORD_PASSWORD="password"
nyord-vpn connect de  # Connect to a German VPN
nyord-vpn status  # Check status
nyord-vpn disconnect  # Disconnect
```

## DEVELOPMENT

After each set of changes, update @PROGRESS.md with what you've done (`- [x] `). Upgrade priorities for NEXT TODO (`- [!]`), re-think the normal TODO (`- [ ] `)

Periodically do:

```
uv venv; source .venv/bin/activate; uv pip install -e .[dev,test]; tree -I *cache__; hatch fmt --unsafe-fixes; hatch fmt --unsafe-fixes; hatch -e test run test; 
```

and react to the results. Use `uv pip...` instead of `pip...` if needed. 

## Working modality

You'll lead two experts: "Ideot" for creative, unorthodox ideas and "Critin" to critique flawed thinking and moderate for balanced discussions. The three of you shall illuminate knowledge with concise, beautiful responses, process methodically for clear answers, collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

Independently tackle challenges systematically, being adaptable and resourceful. Research deeply using all tools, revising to ensure conclusive, exhaustive, insightful results. When you’re finished, print "Wait, but" to go back, think & reflect, revise & improvement what you’ve done (but don’t invent functionality freely). Repeat this. Focus on minimal viable next versions of the code. Ship often and early. 

## General coding principles

Verify info. No assumptions. No apologies. No major invented changes. No unneeded confirmations or checks. Keep existing code and structures unless they need to change. No unnecessary updates or current implementation discussion. Avoid magic numbers, handle edge cases, use assertions to validate assumptions and catch potential errors early.

Every code can fail. Write code that fails gracefully and is UX friendly: uses retries (within reason), does not make stupid assumptions, tests successes, uses fallbacks and backoffs, and then, if the code needs to message the user, be clear and suggest to the user the next steps. Don't prompt the user to do something that the computer can obviously do. The code should ask the user only if there is a real decision to be made. And you should ask me only if a real decision is needed.  

## Keep track of paths

In every source file you create or edit, always maintain the up-to-date `this_file` record that shows the path of the current file relative to the root of the project. Place the `this_file` record near the top of the file, as a comment after the shebangs, or in the YAML Markdown frontmatter. Use these records for orientation. 

## Follow this style for Python

Follow PEP 8. Write clear names. Keep it simple (PEP 20). Use type hints, imperative docstrings (PEP 257), f-strings, and structural pattern matching. Extract repeated logic. Handle errors. Keep functions small. Prefer flat structures. Use pathlib, pydantic as needed. Write maintainable code. 

EVEN IF YOU’RE NOT prompted, always write a "verbose" mode logugu-based logging for debug purposes, write explanatory docstrings and comments that not only explain what a given item (module, function, method) does, but also why it does it, and where and how it's used elsewhere in the code. 

ONLY IF YOU ARE prompted, extend existing features in a way that adds complexity, or refactor in a way that may break things. Remember: minimal viable next version is always our goal. IF NOT PROMPTED, do NOT make such changes. 

For CLI Python scripts, use fire & rich, and start the script with 

```
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

================
File: .github/workflows/push.yml
================
name: Build & Test
on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:
permissions:
  contents: write
  id-token: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"
      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"
  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}
      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"
      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests tests/
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml
  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release
on:
  push:
    tags: ["v*"]
permissions:
  contents: write
  id-token: write
jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/nyord-vpn
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/nyord_vpn/api/__init__.py
================


================
File: src/nyord_vpn/api/api.py
================
T = TypeVar("T")
class NordVPNAPI:
    def __init__(self, timeout: int = 10) -> None:
        self.recommendations = v1_recommendations.NordVPNRecommendationsV1(
        self.technologies = v1_technologies.NordVPNTechnologiesV1(timeout=timeout)
        self.groups = v1_groups.NordVPNGroupsV1(timeout=timeout)
        self.countries = v1_countries.NordVPNCountriesV1(timeout=timeout)
        self.servers = v2_servers.NordVPNServersV2(timeout=timeout)
    def get_recommended_servers(
        warnings.warn(
                self._recommended_servers = self.recommendations.fetch_recommendations()
                logger.error(f"Failed to fetch recommended servers: {e}")
                    raise VPNAPIError(
    def get_technologies(
                self._technologies = self.technologies.fetch_technologies()
                logger.error(f"Failed to fetch technologies: {e}")
                    raise VPNAPIError(f"Failed to fetch technologies: {e}") from e
    def get_groups(self, *, refresh: bool = False) -> list[v1_groups.Group]:
                self._groups = self.groups.fetch_groups()
                logger.error(f"Failed to fetch groups: {e}")
                    raise VPNAPIError(f"Failed to fetch groups: {e}") from e
    def get_countries(self, *, refresh: bool = False) -> list[v1_countries.Country]:
                self._countries = self.countries.fetch_countries()
                logger.error(f"Failed to fetch countries: {e}")
                    raise VPNAPIError(f"Failed to fetch countries: {e}") from e
    def get_servers(self, *, refresh: bool = False) -> ServerTuple:
                result = self.servers.fetch_all()
                self._servers = cast(ServerTuple, result)
                logger.error(f"Failed to fetch servers: {e}")
                    raise VPNAPIError(f"Failed to fetch servers: {e}") from e
    def find_best_server(
                servers = self.get_servers()[0]  # First element is servers
                        and any(
                            location.country.code.upper() == country_code.upper()
                        if any(
                    return min(filtered_servers, key=lambda s: s.load)
                logger.warning(
                logger.warning(f"Failed to use v2 API, falling back to v1: {e}")
            servers = self.get_recommended_servers()
                    and server.locations[0].country.code.upper() == country_code.upper()
                raise ValueError(
    def get_server_stats(self) -> dict[str, Any]:
            servers, groups, _, locations, _ = self.get_servers()
                servers_by_group[group.identifier] = len(
                        if any(g.identifier == group.identifier for g in server.groups)
                "total_countries": len(countries_by_code),
                "total_servers": len(servers),
                "total_groups": len(groups),
                "servers_by_country": dict(
                    sorted(servers_by_country.items(), key=lambda x: x[1], reverse=True)
            logger.warning(f"Failed to generate stats from v2 API, trying v1: {e}")
                countries = self.get_countries()
                v1_groups = self.get_groups()
                    "total_countries": len(countries),
                    "total_servers": sum(country.server_count for country in countries),
                    "total_groups": len(v1_groups),
                        for country in sorted(

================
File: src/nyord_vpn/api/v1_countries.py
================
warnings.warn(
class City(BaseModel):
class Country(BaseModel):
class NordVPNCountriesV1:
    def __init__(self, *, timeout: int = DEFAULT_TIMEOUT) -> None:
    def fetch_countries(self) -> list[Country]:
            response = requests.get(COUNTRIES_V1_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
            return [Country.model_validate(country) for country in data]
            logger.error(f"Failed to fetch NordVPN countries: {e}")
            raise VPNAPIError(
                details=str(e),
            logger.error(f"Failed to parse NordVPN countries: {e}")
def get_country_by_code(countries: list[Country], country_code: str) -> Country:
        if country.code.upper() == country_code.upper():
    raise ValueError(f"No country found with code: {country_code}")
def get_countries_by_min_servers(
def get_city_by_name(country: Country, city_name: str) -> City:
        if city.name.lower() == city_name.lower():
    raise ValueError(f"No city found with name '{city_name}' in {country.name}")

================
File: src/nyord_vpn/api/v1_groups.py
================
warnings.warn(
class GroupType(BaseModel):
    class Config:
class Group(BaseModel):
class NordVPNGroupsV1:
    def __init__(self, *, timeout: int = DEFAULT_TIMEOUT) -> None:
    def fetch_groups(self) -> list[Group]:
            response = requests.get(GROUPS_V1_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
            return [Group.model_validate(group) for group in data]
            logger.error(f"Failed to fetch NordVPN server groups: {e}")
            raise VPNAPIError(
                details=str(e),
            logger.error(f"Failed to parse NordVPN server groups: {e}")
def get_groups_by_type(groups: list[Group], type_identifier: str) -> list[Group]:
def get_group_by_identifier(groups: list[Group], identifier: str) -> Group:
    raise ValueError(f"No group found with identifier: {identifier}")

================
File: src/nyord_vpn/api/v1_recommendations.py
================
warnings.warn(
class City(BaseModel):
class Country(BaseModel):
class Location(BaseModel):
class Service(BaseModel):
class TechnologyMetadata(BaseModel):
class TechnologyPivot(BaseModel):
class Technology(BaseModel):
class GroupType(BaseModel):
class Group(BaseModel):
class SpecificationValue(BaseModel):
class Specification(BaseModel):
class IP(BaseModel):
class ServerIP(BaseModel):
class RecommendedServer(BaseModel):
class NordVPNRecommendationsV1:
    def __init__(self, *, timeout: int = DEFAULT_TIMEOUT) -> None:
    def fetch_recommendations(self) -> list[RecommendedServer]:
            response = requests.get(RECOMMENDATIONS_V1_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
            return [RecommendedServer.model_validate(server) for server in data]
            logger.error(f"Failed to fetch NordVPN server recommendations: {e}")
            raise VPNAPIError(
                details=str(e),
            logger.error(f"Failed to parse NordVPN server recommendations: {e}")
def get_recommendations_by_country(
        and server.locations[0].country.code.upper() == country_code.upper()
def get_recommendations_by_group(
        if any(group.identifier == group_identifier for group in server.groups)

================
File: src/nyord_vpn/api/v1_technologies.py
================
warnings.warn(
class Technology(BaseModel):
class NordVPNTechnologiesV1:
    def __init__(self, *, timeout: int = DEFAULT_TIMEOUT) -> None:
    def fetch_technologies(self) -> list[Technology]:
            response = requests.get(TECHNOLOGIES_V1_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
            return [Technology.model_validate(tech) for tech in data]
            logger.error(f"Failed to fetch NordVPN technologies: {e}")
            raise VPNAPIError(
                details=str(e),
            logger.error(f"Failed to parse NordVPN technologies: {e}")
def get_technology_by_identifier(
    raise ValueError(f"No technology found with identifier: {identifier}")

================
File: src/nyord_vpn/api/v2_servers.py
================
T = TypeVar("T")
class TechnologyMetadata(BaseModel):
class Technology(BaseModel):
class IP(BaseModel):
class ServerIP(BaseModel):
class SpecificationValue(BaseModel):
class Specification(BaseModel):
class GroupType(BaseModel):
class Group(BaseModel):
    class Config:
class Service(BaseModel):
class City(BaseModel):
class Country(BaseModel):
class Location(BaseModel):
class Server(BaseModel):
class NordVPNServersV2:
    def __init__(self, *, timeout: int = DEFAULT_TIMEOUT) -> None:
            "servers": TypeAdapter(list[Server]),
            "groups": TypeAdapter(list[Group]),
            "services": TypeAdapter(list[Service]),
            "locations": TypeAdapter(list[Location]),
            "technologies": TypeAdapter(list[Technology]),
    def fetch_all(
            response = requests.get(SERVERS_V2_ENDPOINT, timeout=self.timeout)
            response.raise_for_status()
            data = response.json()
            for key, adapter in self._type_adapters.items():
                    parsed_data[key] = adapter.validate_python(data[key])
                    logger.error(f"Failed to parse {key} data: {err}")
                    raise VPNAPIError(
                        details=str(err),
                self._link_server_relations(server, relationship_maps)
                cast(list[Server], parsed_data["servers"]),
                cast(list[Group], parsed_data["groups"]),
                cast(list[Service], parsed_data["services"]),
                cast(list[Location], parsed_data["locations"]),
                cast(list[Technology], parsed_data["technologies"]),
            logger.error(f"Failed to fetch NordVPN server data: {error}")
                details=str(error),
    def _link_server_relations(
            for group_id in getattr(server, "group_ids", []) or []
            for service_id in getattr(server, "service_ids", []) or []
            for location_id in getattr(server, "location_ids", []) or []
            if hasattr(server, attr):
                delattr(server, attr)
def get_servers_by_country(servers: list[Server], country_code: str) -> list[Server]:
        and server.locations[0].country.code.upper() == country_code.upper()
def get_servers_by_group(servers: list[Server], group_identifier: str) -> list[Server]:
        if any(group.identifier == group_identifier for group in server.groups)

================
File: src/nyord_vpn/core/__init__.py
================


================
File: src/nyord_vpn/core/api.py
================
warnings.warn(
class NordVPNAPIClient:
    def __init__(
    def list_countries(self, *, use_cache: bool = True) -> list[Country]:
            response = get(url, headers=API_HEADERS, timeout=self.timeout)
            response.raise_for_status()
            countries: list[Country] = response.json()
                "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            cache_countries(cache_data)
            self.logger.warning(f"Failed to fetch countries: {e}")
            cached = get_cached_countries()
    def get_country_by_code(self, code: str) -> Country | None:
        code = code.upper()
        for country in self.list_countries():
    def get_country_by_name(self, name: str) -> Country | None:
        name = name.lower()
            if country["name"].lower() == name:
    def get_available_locations(self) -> list[str]:
        for country in sorted(self.list_countries(), key=lambda x: x["name"]):
            locations.append(
                f"{country['name']} ({country['code'].lower()}) - {total_servers} servers",
            for city in sorted(country["cities"], key=lambda x: x["name"]):
                locations.append(f"  {city['name']} - {city['serverCount']} servers")
    def get_best_city(
        country = self.get_country_by_code(country_code)
        sorted_cities = sorted(
    def fetch_countries(
            return self.list_countries(use_cache=False)
        return self.list_countries(use_cache=True)
    def get_cities(self, country_code: str, *, use_cache: bool = True) -> list[City]:
        return country.get("cities", [])
    def test_api_connectivity(self) -> bool:
            response = get(
                self.logger.exception(f"API connectivity test failed: {e}")

================
File: src/nyord_vpn/core/base.py
================
warnings.warn(
class NordVPNClient:
    def __init__(self, username: str, password: str, *, verbose: bool = False) -> None:
        self.countries = self._load_countries()
        self.logger.add(sys.stdout, level="DEBUG" if self.verbose else "INFO")
    def _load_countries(self) -> list[Country]:
        cached = get_cached_countries()
    def get_country_by_code(self, code: str) -> Country | None:
        code = code.upper()
    def get_country_by_name(self, name: str) -> Country | None:
        name = name.lower()
            if country["name"].lower() == name:
    def get_available_locations(self) -> list[str]:
        for country in sorted(self.countries, key=lambda x: x["name"]):
            locations.append(
                f"{country['name']} ({country['code'].lower()}) - {total_servers} servers"
            locations.extend(
                for city in sorted(country["cities"], key=lambda x: x["name"])
    def get_best_city(self, country_code: str) -> City | None:
        country = self.get_country_by_code(country_code)
        sorted_cities = sorted(
    def list_countries(self, **kwargs) -> list[Country]:

================
File: src/nyord_vpn/core/client.py
================
load_dotenv()
logger.configure(
            "sink": RichHandler(),
PACKAGE_DIR = Path(__file__).parent
console = Console()
class City(TypedDict):
class Country(TypedDict):
class CountryCache(TypedDict):
class Client:
    def __init__(
            or os.environ.get("NORD_USER")
            or os.environ.get("NORDVPN_LOGIN")
            or os.environ.get("NORD_PASSWORD")
            or os.environ.get("NORDVPN_PASSWORD")
            raise VPNError(
        self.api_client = NordVPNAPI(timeout=10)
        self.server_manager = ServerManager(self.api_client)
        self.vpn_manager = VPNConnectionManager(
            self.vpn_manager.setup_connection("", self.username, self.password)
            if "hostname" in str(e).lower():
    def is_protected(self) -> bool:
        status = self.status()
        return status.get("connected", False)
    def status(self) -> dict[str, Any]:
        return self.vpn_manager.status()
    def go(self, country_code: str) -> None:
            if status.get("connected", False):
                    self.logger.info(
            servers = self.server_manager.select_fastest_server(country_code)
                raise VPNError(f"No servers available in {country_code}")
            hostname = server.get("hostname")
                raise VPNError("Selected server has no hostname")
                self.logger.info(f"Selected server: {hostname}")
                console.print(f"Selected server: [cyan]{hostname}[/cyan]")
                raise VPNError("Missing VPN credentials")
            self.vpn_manager.setup_connection(hostname, self.username, self.password)
                self.logger.info("Establishing VPN connection...")
                console.print("Establishing VPN connection...")
            self.vpn_manager.connect(servers)  # Pass all servers to try in order
            console.print("[green]Successfully connected to VPN[/green]")
            console.print(f"Private IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
            console.print(f"Country: [cyan]{status.get('country', 'Unknown')}[/cyan]")
            console.print(f"Server: [cyan]{status.get('server', 'Unknown')}[/cyan]")
            raise VPNError(f"Failed to connect: {e}")
    def bye(self) -> None:
            logger.info("Checking current connection status...")
            status = self.vpn_manager.status()
                self.vpn_manager.disconnect()
                logger.info("No active VPN connection found")
            logger.error(f"Error during disconnect: {e}")
        current_ip = self.vpn_manager.get_current_ip()
            self.logger.info("Checking current connection status...")
        if self.vpn_manager.is_connected():
                self.logger.info("Disconnecting from VPN...")
            console.print("[green]Disconnected from VPN[/green]")
                self.logger.info("No active VPN connection found")
            console.print("[yellow]Not connected to VPN[/yellow]")
        public_ip = self.vpn_manager.get_current_ip()
            "timestamp": time.time(),
        save_vpn_state(state)
            console.print(f"Public IP: [cyan]{public_ip}[/cyan]")
            console.print("[yellow]Could not determine IP[/yellow]")
    def info(self) -> None:
                console.print("[green]VPN Status: Connected[/green]")
                console.print(
                    f"Country: [cyan]{status.get('country', 'Unknown')}[/cyan]"
                console.print("[yellow]VPN Status: Not Connected[/yellow]")
                console.print(f"Public IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
            raise VPNError(f"Failed to get status: {e}")
    def init(self) -> None:
                directory.mkdir(parents=True, exist_ok=True)
                self.api_client.get_countries()
                raise VPNConnectionError("Failed to connect to NordVPN API") from e
                self.get_current_ip()
                raise VPNConnectionError("Failed to get initial IP") from e
            if isinstance(e, VPNConnectionError):
            raise VPNConnectionError(f"Failed to initialize client environment: {e}")
    def get_current_ip(self) -> str | None:
        return self.vpn_manager.get_current_ip()
    def _save_state(self) -> None:
            "connected": self.is_protected(),
            "initial_ip": self.get_current_ip(),
            "connected_ip": self.get_current_ip(),
            "server": self.status().get("server", "Unknown"),
            "country": self.status().get("country", "Unknown"),

================
File: src/nyord_vpn/data/.specstory/history/.what-is-this.md
================
# SpecStory Artifacts Directory
    
This directory is automatically created and maintained by the SpecStory extension to preserve your Cursor composer and chat history.
    
## What's Here?
    
- `.specstory/history`: Contains markdown files of your AI coding sessions
- Each file represents a separate chat or composer session
- Files are automatically updated as you work

## Valuable Uses
    
- Capture: Keep your context window up-to-date when starting new Chat/Composer sessions via @ references
- Search: For previous prompts and code snippets 
- Learn: Meta-analyze your patterns and learn from your past experiences
    
## Version Control
    
We recommend keeping this directory under version control to maintain a history of your AI interactions. However, if you prefer not to version these files, you can exclude them by adding this to your `.gitignore`:
    
```
.specstory/**
```
    
## Searching Your Codebase
    
When searching your codebase in Cursor, search results may include your previous AI coding interactions. To focus solely on your actual code files, you can exclude the AI interaction history from search results.
    
To exclude AI interaction history:
    
1. Open the "Find in Files" search in Cursor (Cmd/Ctrl + Shift + F)
2. Navigate to the "files to exclude" section
3. Add the following pattern:
    
```
.specstory/*
```
    
This will ensure your searches only return results from your working codebase files.

## Notes

- Auto-save only works when Cursor/sqlite flushes data to disk. This results in a small delay after the AI response is complete before SpecStory can save the history.
- Auto-save does not yet work on remote WSL workspaces.

## Settings
    
You can control auto-saving behavior in Cursor:
    
1. Open Cursor → Settings → VS Code Settings (Cmd/Ctrl + ,)
2. Search for "SpecStory"
3. Find "Auto Save" setting to enable/disable
    
Auto-save occurs when changes are detected in Cursor's sqlite database, or every 2 minutes as a safety net.

================
File: src/nyord_vpn/network/__init__.py
================


================
File: src/nyord_vpn/network/country.py
================
def get_cached_countries() -> CountryCache | None:
        if not COUNTRIES_CACHE.exists():
        if time.time() - COUNTRIES_CACHE.stat().st_mtime > CACHE_EXPIRY:
        return json.loads(COUNTRIES_CACHE.read_text())
def cache_countries(data: CountryCache) -> None:
        COUNTRIES_CACHE.parent.mkdir(parents=True, exist_ok=True)
        COUNTRIES_CACHE.write_text(json.dumps(data, indent=2, sort_keys=True))
        COUNTRIES_CACHE.chmod(0o644)  # Make readable for all users

================
File: src/nyord_vpn/network/server.py
================
class Country(TypedDict):
class ServerLocation(TypedDict):
class TechnologyMetadata(TypedDict):
class Technology(TypedDict):
class ServerInfo(TypedDict):
class ServerCache(TypedDict):
def _safe_dict_get(d: dict[str, Any], key: str, default: Any = None) -> Any:
    return d.get(key, default) if isinstance(d, dict) else default
def _safe_get(d: dict[str, Any] | None, key: str, default: Any = None) -> Any:
    return _safe_dict_get(d, key, default)
def _safe_str_get(s: str | None, key: str, default: Any = None) -> Any:
        return s[int(key)] if key.isdigit() else default
def _safe_dict_access(d: dict[str, Any], key: str) -> Any:
    if not isinstance(d, dict) or key not in d:
        raise KeyError(f"Required key {key} not found in dictionary")
def _safe_dict_cast(d: Any) -> dict[str, Any]:
    if not isinstance(d, dict):
    return cast(dict[str, Any], d)
def _safe_dict_get_str(d: dict[str, Any], key: str, default: str = "") -> str:
    value = _safe_dict_get(d, key, default)
    return str(value) if value is not None else default
def _safe_dict_get_int(d: dict[str, Any], key: str, default: int = 0) -> int:
        return int(value) if value is not None else default
def _safe_dict_get_list(
    return value if isinstance(value, list) else default
def _safe_dict_get_dict(
    return value if isinstance(value, dict) else default
def cache_servers(data: dict[str, Any]) -> None:
        if not isinstance(data, dict):
            logger.warning("Invalid server data format")
        SERVERS_CACHE_FILE.parent.mkdir(parents=True, exist_ok=True)
        temp_file = SERVERS_CACHE_FILE.with_suffix(".tmp")
        temp_file.write_text(json.dumps(data, indent=2))
        temp_file.replace(SERVERS_CACHE_FILE)
        logger.warning(f"Failed to cache server information: {e}")
def _parse_timestamp(timestamp: Any) -> float:
    if isinstance(timestamp, int | float):
        return float(timestamp)
    if isinstance(timestamp, str):
                dt = datetime.fromisoformat(timestamp.replace("Z", "+00:00"))
                return dt.timestamp()
def get_cached_servers() -> ServerCache | None:
        if not SERVERS_CACHE_FILE.exists():
        data = json.loads(SERVERS_CACHE_FILE.read_text())
        last_updated = _parse_timestamp(_safe_dict_get(data, "last_updated", 0))
        if time.time() - last_updated > SERVERS_CACHE_TTL:
            "servers": cast(list[ServerInfo], _safe_dict_get_list(data, "servers", [])),
            "locations": cast(
                dict[str, ServerLocation], _safe_dict_get_dict(data, "locations", {})
        logger.warning(f"Failed to load cached server information: {e}")
class ServerManager:
    def __init__(self, api_client: NordVPNAPI) -> None:
        self._failed_servers: set[str] = set()  # Track failed servers in this session
    def verbose(self) -> bool:
    def verbose(self, value: bool) -> None:
    def _validate_country_code(self, country_code: str | None) -> str | None:
        normalized = country_code.upper()
        if not isinstance(normalized, str) or len(normalized) != 2:
            raise ServerError(f"Invalid country code format: {country_code}")
            servers, _, _, locations, _ = self.api_client.get_servers()
                if location.country and location.country.code.upper() == normalized:
            available_countries = sorted(
                    loc.country.code.upper()
            raise ServerError(
                f"Available countries: {', '.join(available_countries)}"
            cache = self.get_servers_cache()
                raise ServerError("No server information available")
            for location in cache["locations"].values():
                if location["country"]["code"].upper() == normalized:
                    loc["country"]["code"].upper()
                    for loc in cache["locations"].values()
    def fetch_server_info(self, country: str | None = None) -> tuple[str, str] | None:
            country_code = self._validate_country_code(country)
            best_server = self.api_client.find_best_server(
            hostname = getattr(best_server, "hostname", None)
                raise ServerError("Best server has no hostname")
            station = getattr(best_server, "station", "")
            if isinstance(e, ServerError):
            raise ServerError(f"Failed to fetch server information: {e}")
    def get_servers_cache(self) -> ServerCache | None:
                and time.time() - self._last_cache_update <= SERVERS_CACHE_TTL
            file_cache = get_cached_servers()
                self._last_cache_update = time.time()
                    self.api_client.get_servers()
                    "last_updated": time.time(),
                        location_id = str(location.id)
                        if hasattr(tech, "metadata") and tech.metadata:
                        server_technologies.append(technology)
                            str(loc.id) for loc in server.locations if loc.id
                    new_cache["servers"].append(server_info)
                cache_servers(cast(dict[str, Any], new_cache))
                logger.warning(f"Failed to get server information from API: {e}")
                response = requests.get(
                response.raise_for_status()
                api_data = response.json()
                if not isinstance(api_data, dict):
                    self.logger.warning(
                for location in api_data.get("locations", []):
                    if not isinstance(location, dict):
                    location_id = str(location.get("id", ""))
                    country_data = location.get("country", {})
                    if isinstance(country_data, dict):
                            "name": str(country_data.get("name", "")),
                            "code": str(country_data.get("code", "")),
                for item in api_data.get("servers", []):
                    if not isinstance(item, dict):
                    for tech in item.get("technologies", []):
                        if not isinstance(tech, dict):
                        tech_id = tech.get("id")
                            "id": int(tech_id),
                            "status": str(tech.get("status", "")),
                        if tech.get("metadata"):
                                    "name": str(meta.get("name", "")),
                                    "value": str(meta.get("value", "")),
                                for meta in tech.get("metadata", [])
                                if isinstance(meta, dict)
                        technologies.append(technology)
                        "hostname": str(item.get("hostname", "")),
                            str(lid) for lid in item.get("location_ids", [])
                        "status": str(item.get("status", "")),
                        "load": int(item.get("load", 0)),
                    servers.append(server_info)
            self.logger.warning(f"Failed to get server information: {e}")
    def _is_valid_hostname(self, hostname: str) -> bool:
        if not hostname or len(hostname) > 253:
        parts = hostname.split(".")
        if len(parts) < 2:
            if not part or len(part) > 63:
            if not re.match(r"^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?$", part):
    def _ping_server(self, hostname: str) -> float:
            system = platform.system().lower()
            if not self._is_valid_hostname(hostname):
                self.logger.warning(f"Invalid hostname format: {hostname}")
                return float("inf")
            hostname = hostname.lower()
            if re.match(r"^(\d{1,3}\.){3}\d{1,3}$", hostname):
                self.logger.debug(f"Running ping command: {' '.join(cmd)}")
            result = subprocess.run(
                min_time = float("inf")
                for line in result.stdout.splitlines():
                        self.logger.debug(f"Ping output line: {line}")
                            stats = line.split("=")[1].strip().split("/")
                            min_time = float(stats[0])
                                self.logger.debug(
                            time_str = line.split("time=")[1].split()[0].rstrip("ms")
                            ping_time = float(time_str)
                            min_time = min(min_time, ping_time)
                if min_time < float("inf"):
                self.logger.debug(f"Error pinging {hostname}: {e}")
    def _is_valid_server(self, server: Any) -> bool:
        if not hasattr(server, "get") and not hasattr(server, "__dict__"):
            server.get("hostname", "")
            if hasattr(server, "get")
            else getattr(server, "hostname", "")
            server.get("status", "")
            else getattr(server, "status", "")
            server.get("technologies", [])
            else getattr(server, "technologies", [])
            if hasattr(tech, "get"):
                tech_name = tech.get("name", "")
                tech_name = getattr(tech, "name", "")
                    self.logger.debug(f"Found OpenVPN TCP support: {tech_name}")
            self.logger.debug(f"Server {hostname} does not support OpenVPN TCP")
    def _test_server(self, server: Any) -> tuple[Any, float]:
        hostname = server.get("hostname", "")
            return server, float("inf")
        load = server.get("load", 100)
        ping_time = self._ping_server(hostname)
        server_copy = server.copy()
    def _select_diverse_servers(
        if len(servers) <= count:
        servers_by_load = sorted(servers, key=lambda s: s.get("load", 100))
        low_load = servers_by_load[: len(servers_by_load) // 4]
            result.append(low_load[secrets.randbelow(len(low_load))])
        mid_start = len(servers_by_load) // 4
        mid_end = mid_start + len(servers_by_load) // 2
            result.append(medium_load[secrets.randbelow(len(medium_load))])
        remaining = count - len(result)
            selected_hostnames = {s.get("hostname", "") for s in result}
                s for s in servers if s.get("hostname", "") not in selected_hostnames
            for _ in range(min(remaining, len(remaining_servers))):
                idx = secrets.randbelow(len(remaining_servers))
                result.append(remaining_servers[idx])
                remaining_servers.pop(idx)
    def select_fastest_server(
                    country_code = self._validate_country_code(country_code)
                logger.warning(
                raise ServerError("No servers available")
            location_lookup = {str(loc["id"]): loc for loc in locations.values()}
                country_code = country_code.upper()
                        location = location_lookup.get(str(loc_id))
                            and location["country"]["code"].upper() == country_code
                            filtered_servers.append(server)
                            for loc in locations.values()
                self._failed_servers.clear()  # Reset failed servers if none left
                return self.select_fastest_server(country_code)  # Try again
            test_servers = self._select_diverse_servers(servers)
                server_result, score = self._test_server(server)
                if score < float("inf"):
                    results.append((server_result, score))
            results.sort(key=lambda x: x[1])
            raise ServerError(f"Failed to select server: {e}")
    def get_country_info(self, country_code: str) -> dict[str, Any]:
        normalized_code = self._validate_country_code(country_code)
            raise ServerError(f"Invalid country code: {country_code}")
            _, _, _, locations, _ = self.api_client.get_servers()
                    and location.country.code.upper() == normalized_code
                        "id": getattr(location.country, "id", None),
            raise ServerError(f"Country not found: {normalized_code}")
            for loc in cache["locations"].values():
                country_dict.update(loc["country"])
    def get_random_country(self) -> str:
                raise ServerError("No countries available")
            return country_codes[secrets.randbelow(len(country_codes))]
            country_codes = sorted(

================
File: src/nyord_vpn/network/vpn_commands.py
================
class OpenVPNVerbosity(Enum):
class OpenVPNConfig:
    ciphers: list[str] = field(
    tls_ciphers: list[str] = field(
    dns_servers: list[str] = field(
    extra_options: dict[str, Any] = field(default_factory=dict)
    def __post_init__(self) -> None:
        self._validate_paths()
        self._validate_verbosity()
        self._validate_numeric_params()
    def _validate_paths(self) -> None:
        if isinstance(self.config_path, str):
            self.config_path = Path(self.config_path)
        if isinstance(self.auth_path, str):
            self.auth_path = Path(self.auth_path)
        if isinstance(self.log_path, str):
            self.log_path = Path(self.log_path)
        if not self.config_path.exists():
            raise VPNConfigError(f"{CONFIG_FILE_NOT_FOUND}: {self.config_path}")
        if not self.auth_path.exists():
            raise VPNConfigError(f"{AUTH_FILE_NOT_FOUND}: {self.auth_path}")
            self.config_path.read_bytes()
            self.auth_path.read_bytes()
            raise VPNConfigError(f"{CANNOT_READ_FILES}: {e}") from e
            self.log_path.parent.mkdir(parents=True, exist_ok=True)
    def _validate_verbosity(self) -> None:
        if isinstance(self.verbosity, int):
                raise VPNConfigError(f"{INVALID_VERBOSITY}: {self.verbosity}")
            with contextlib.suppress(ValueError):
                self.verbosity = OpenVPNVerbosity(self.verbosity)
    def _validate_numeric_params(self) -> None:
            raise VPNConfigError(f"{INVALID_CONNECT_RETRY}: {self.connect_retry}")
            raise VPNConfigError(f"{INVALID_CONNECT_TIMEOUT}: {self.connect_timeout}")
            raise VPNConfigError(f"{INVALID_PING_INTERVAL}: {self.ping_interval}")
            raise VPNConfigError(
def get_openvpn_command(config: OpenVPNConfig) -> list[str]:
    if not shutil.which("openvpn"):
        raise VPNConfigError(f"{OPENVPN_NOT_FOUND}. Please install OpenVPN first.")
        str(config.config_path),
        str(config.auth_path),
        str(
            if isinstance(config.verbosity, OpenVPNVerbosity)
        str(config.connect_retry),
        str(config.connect_timeout),
        str(config.ping_interval),
        str(config.ping_restart),
    cmd.extend(
            ":".join(config.ciphers),
            ":".join(config.tls_ciphers),
    system = platform.system().lower()
        _add_macos_options(cmd, config)
        _add_linux_options(cmd, config)
        _add_windows_options(cmd, config)
        logger.warning(f"Unsupported platform: {system}. Using generic options.")
        _add_generic_options(cmd, config)
        cmd.extend(["--log", str(config.log_path)])
    for key, value in config.extra_options.items():
            cmd.append(f"--{key}")
            cmd.append(str(value))
def _add_macos_options(cmd: list[str], config: OpenVPNConfig) -> None:
        cmd.extend(["--dhcp-option", "DNS", dns_server])
def _add_linux_options(cmd: list[str], config: OpenVPNConfig) -> None:
    resolv_conf_script = Path("/etc/openvpn/update-resolv-conf")
    if resolv_conf_script.exists():
                str(resolv_conf_script),
    if not resolv_conf_script.exists():
def _add_windows_options(cmd: list[str], config: OpenVPNConfig) -> None:
def _add_generic_options(cmd: list[str], config: OpenVPNConfig) -> None:
def create_default_config(
    return OpenVPNConfig(

================
File: src/nyord_vpn/network/vpn.py
================
console = Console()
OPENVPN_AUTH = Path.home() / ".cache" / "nyord-vpn" / "openvpn.auth"
OPENVPN_LOG = Path.home() / ".cache" / "nyord-vpn" / "openvpn.log"
class VPNConnectionManager:
    def __init__(
        state = load_vpn_state()
        self._normal_ip = state.get("normal_ip")
        self._connected_ip = state.get("connected_ip")
        self._server = state.get("server")
        self._country_name = state.get("country")
        OPENVPN_AUTH.parent.mkdir(parents=True, exist_ok=True)
            self.openvpn_path = self.check_openvpn_installation()
                self.logger.warning("OpenVPN not found during initialization")
    def check_openvpn_installation(self) -> str:
                if Path(path).exists():
                    result = subprocess.run(
                            self.logger.debug(f"Found OpenVPN at {path}")
                path = result.stdout.strip()
            raise VPNError(
            if isinstance(e, VPNError):
            raise VPNError(f"Failed to verify OpenVPN installation: {e}")
    def setup_connection(self, hostname: str, username: str, password: str) -> None:
            if not username or not isinstance(username, str):
                raise VPNAuthenticationError("Username must be a non-empty string")
            username = username.strip()
                raise VPNAuthenticationError("Username cannot be empty")
            if not password or not isinstance(password, str):
                raise VPNAuthenticationError("Password must be a non-empty string")
            password = password.strip()
                raise VPNAuthenticationError("Password cannot be empty")
            if len(password) < 8:
                raise VPNAuthenticationError("Password must be at least 8 characters")
            auth_dir.mkdir(mode=0o700, parents=True, exist_ok=True)
            temp_auth = auth_dir / f".openvpn.auth.{os.getpid()}.tmp"
                temp_auth.write_text(f"{username}\n{password}")
                temp_auth.chmod(0o600)
                temp_auth.replace(OPENVPN_AUTH)
                    self.logger.debug(f"Created auth file at {OPENVPN_AUTH}")
                    if temp_auth.exists():
                        temp_auth.unlink()
                raise VPNAuthenticationError(
                stat = OPENVPN_AUTH.stat()
                    OPENVPN_AUTH.chmod(0o600)
                        self.logger.debug("Fixed auth file permissions")
                lines = OPENVPN_AUTH.read_text().strip().split("\n")
                if len(lines) != 2:
                if lines[0].strip() != username or lines[1].strip() != password:
                if isinstance(e, VPNAuthenticationError):
            raise VPNAuthenticationError(str(e))
    def get_current_ip(self) -> str | None:
        def is_valid_ipv4(ip: str) -> bool:
                parts = ip.strip().split(".")
                if len(parts) != 4:
                return all(0 <= int(part) <= 255 for part in parts)
        for attempt in range(2):
                    self.logger.debug(
                response = requests.get("https://api.ipify.org?format=json", timeout=3)
                response.raise_for_status()
                data = response.json()
                ip = data.get("ip")
                if ip and is_valid_ipv4(ip):
                        self.logger.debug(f"Got valid IP {ip} from api.ipify.org")
                    time.sleep(0.5)
                response = requests.get("http://ip-api.com/json", timeout=3)
                ip = data.get("query")
                        self.logger.debug(f"Got valid IP {ip} from ip-api.com")
                self.logger.debug("Checking IP with ifconfig.me (final attempt)")
            response = requests.get("https://ifconfig.me/ip", timeout=3)
            ip = response.text.strip()
                    self.logger.debug(f"Got valid IP {ip} from ifconfig.me")
                self.logger.debug(f"Final IP check failed: {e}")
            self.logger.warning("Failed to get current IP from any service")
    def _save_state(self) -> None:
        current_ip = self.get_current_ip()
            "connected": self.is_connected(),
            "timestamp": time.time(),
        save_vpn_state(state)
    def connect(self, servers: list[dict[str, Any]]) -> None:
                hostname = server.get("hostname")
                    raise VPNError("Invalid server info - missing hostname")
                    self.disconnect()
                        self.logger.warning(
                    for proc in psutil.process_iter(["name", "pid", "cmdline"]):
                                cmdline = proc.info.get("cmdline", [])
                                if any("nordvpn.com" in arg for arg in cmdline):
                                        os.kill(proc.info["pid"], signal.SIGKILL)
                                        time.sleep(0.1)  # Brief pause after kill
                    location_ids = server.get("location_ids", [])
                    locations = self.server_manager.get_servers_cache().get(
                        location = locations.get(str(loc_id))
                        if location and location.get("country"):
                    self.logger.debug(f"Connecting to {hostname}")
                config_path = get_config_path(hostname)
                    raise VPNConfigError(f"Failed to get OpenVPN config for {hostname}")
                        config_content = config_path.read_text()
                        self.logger.debug(f"OpenVPN config for {hostname}:")
                        for line in config_content.splitlines():
                            if not line.strip().startswith("#"):  # Skip comments
                                self.logger.debug(f"  {line}")
                        self.logger.warning(f"Failed to read config file: {e}")
                if not OPENVPN_AUTH.exists():
                    raise VPNError("Auth file not found - please run setup first")
                    auth_content = OPENVPN_AUTH.read_text().strip().split("\n")
                    if len(auth_content) != 2:
                        self.logger.debug("Auth file exists and has correct format")
                    raise VPNError(f"Failed to read auth file: {e}")
                cmd = get_openvpn_command(
                    self.logger.debug("Running OpenVPN command:")
                    self.logger.debug(" ".join(cmd))
                    if OPENVPN_LOG and OPENVPN_LOG.exists():
                        OPENVPN_LOG.unlink()
                    self.process = subprocess.Popen(
                    if self.process.poll() is not None:
                        stdout, stderr = self.process.communicate()
                    raise VPNError(f"Failed to start OpenVPN process: {e}")
                start_time = time.time()
                while time.time() - start_time < 30:  # 30 second timeout
                                log_content = OPENVPN_LOG.read_text()
                                    self.logger.debug("OpenVPN log content:")
                                    for line in log_content.splitlines():
                                self.logger.warning(f"Failed to read OpenVPN log: {e}")
                                    for line in log_content.splitlines()
                                    self.logger.debug("Auth-related log lines:")
                                    self.logger.debug("Auth progress:")
                    time.sleep(0.1)
                    if self.process and self.process.poll() is None:
                            self.process.terminate()
                            if self.process.poll() is None:
                                self.process.kill()
                        error_messages.append(
                time.sleep(1)  # Brief pause to let connection stabilize
                if not self.verify_connection():
                        self.logger.warning(error_msg)
                    error_messages.append(error_msg)  # Collect
                    self.logger.info(f"Connected to {hostname}")
                        time.sleep(0.1)  # Brief pause
                error_messages.append(str(e))  # Collect
                if isinstance(e, VPNError | VPNAuthenticationError | VPNConfigError):
            "Failed to connect after trying all servers:\n" + "\n".join(error_messages)
    def disconnect(self) -> None:
                    for _ in range(10):  # 1 second total
                        self.logger.warning(f"Error terminating tracked process: {e}")
                                os.kill(proc.info["pid"], signal.SIGTERM)
                                if self._is_process_running(proc.info["pid"]):
                            remaining.append(proc.info["pid"])
                        self.logger.debug("Cleaned up OpenVPN log file")
                        self.logger.warning(f"Failed to clean up OpenVPN log: {e}")
            self._invalidate_ip_cache()
                self.logger.info("Disconnected from VPN")
            if isinstance(e, ProcessLookupError):
                error_details.append("Process not found")
            elif isinstance(e, PermissionError):
                error_details.append("Permission denied")
                error_details.append(str(e))
                self.logger.exception(
                    f"Error during disconnect: {'; '.join(error_details)}"
                f"Failed to disconnect from VPN: {'; '.join(error_details)}"
    def is_connected(self) -> bool:
        return self.process is not None and self.process.poll() is None
    def verify_connection(self) -> bool:
            if not self.process or self.process.poll() is not None:
                    self.logger.debug("OpenVPN process not running")
                    output = subprocess.check_output(["ifconfig"], text=True)
                    if not any(
                        line.startswith("utun") and "UP" in line
                        for line in output.split("\n")
                            self.logger.debug("No active utun interface found")
                        self.logger.debug("Failed to check TUN interface")
                    output = subprocess.check_output(
                            self.logger.debug("TUN interface not up")
                socket.gethostbyname("nordvpn.com")
                    self.logger.debug("DNS resolution failed")
                        self.logger.debug("Failed to get current IP")
                normal_ip = state.get("normal_ip")
                        self.logger.debug("IP has not changed from pre-connection IP")
                    self.logger.debug(f"IP verification failed: {e}")
                self.logger.debug(f"Connection verification failed: {e}")
    def status(self) -> dict[str, Any]:
            "ip": self.get_current_ip(),
                cache = self.server_manager.get_servers_cache()
                if cache and cache.get("servers"):
                        if server.get("hostname") == self._server:
                            locations = cache.get("locations", {})
                    country_code = self._server.split(".")[0][:2].upper()
                    country = self.api_client.get_country_by_code(country_code)
    def _is_process_running(self, process_id: int) -> bool:
            os.kill(process_id, 0)
                self.logger.debug(f"Error checking process {process_id}: {e}")
    def check_connection_state(self) -> bool:
            process_id = state.get("process_id")
            if not process_id or not self._is_process_running(process_id):
                if state.get("connected"):
                            self.logger.debug("OpenVPN connection verified")
                        self.logger.debug(f"Failed to read OpenVPN log: {e}")
                self.logger.exception(f"Error checking connection state: {e}")
    def _invalidate_ip_cache(self) -> None:
            self.logger.debug("IP cache invalidated")
    def go(self, country_code: str) -> None:
        if not check_root():
            ensure_root()
            status = self.status()
            if status.get("connected", False):
                    self.logger.info(
            servers = self.server_manager.select_fastest_server(country_code)
                raise VPNError(f"No servers available in {country_code}")
                self.logger.info(f"Selected {len(servers)} servers to try")
                for i, server in enumerate(servers, 1):
                        f"{i}. {server.get('hostname')} (load: {server.get('load')}%)"
                        self.logger.info(f"Trying server: {hostname}")
                        console.print(f"Trying server: [cyan]{hostname}[/cyan]")
                    self.setup_connection(
                    self.connect([server])  # Pass as list for compatibility
                        self.logger.info(f"Successfully connected to {hostname}")
                    errors.append(error_msg)
                + "\n".join(f"- {e}" for e in errors)
            raise VPNError(f"Failed to connect: {e}")

================
File: src/nyord_vpn/scripts/__init__.py
================


================
File: src/nyord_vpn/scripts/update_countries.py
================
class City(TypedDict):
class Country(TypedDict):
class CountryCache(TypedDict):
def fetch_countries() -> list[Country]:
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        progress.add_task(
        response = requests.get(url, timeout=10)
        response.raise_for_status()
    countries: list[Country] = response.json()
    return sorted(countries, key=lambda x: x["name"])
def main() -> None:
        package_dir = Path(__file__).parent.parent
        data_dir.mkdir(parents=True, exist_ok=True)
        countries = fetch_countries()
        total_servers = sum(country["serverCount"] for country in countries)
        total_cities = sum(len(country["cities"]) for country in countries)
            "last_updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        with cache_file.open("w") as f:
            json.dump(cache_data, f, indent=2, sort_keys=True)
        cache_file.chmod(0o644)
        rprint("[green]✓ Updated country list cache with:[/green]")
        rprint(f"  • [cyan]{len(countries)}[/cyan] countries")
        rprint(f"  • [cyan]{total_cities}[/cyan] cities")
        rprint(f"  • [cyan]{total_servers}[/cyan] servers")
        rprint(f"[blue]Cache file: {cache_file}[/blue]")
        rprint(f"[red]✗ Failed to fetch country list: {e}[/red]")
        sys.exit(1)
        rprint(f"[red]✗ Failed to update cache file: {e}[/red]")
    main()

================
File: src/nyord_vpn/storage/__init__.py
================


================
File: src/nyord_vpn/storage/models.py
================
class City(TypedDict):
class Country(TypedDict):
class CountryCache(TypedDict):
class VPNError(Exception):
    def __init__(self, message: str | None = None) -> None:
        super().__init__(message or "An unknown VPN error occurred")
class ServerError(VPNError):
        super().__init__(
class AuthenticationError(VPNError):
class CredentialsError(VPNError):
class StateError(VPNError):
class CacheError(VPNError):

================
File: src/nyord_vpn/storage/state.py
================
def save_vpn_state(state: dict) -> None:
        if STATE_FILE.exists():
            with contextlib.suppress(json.JSONDecodeError):
                existing = json.loads(STATE_FILE.read_text())
        current_ip = state.get("current_ip")
        if not state.get("connected") and current_ip:
        elif state.get("connected") and current_ip:
            if not state.get("normal_ip") and existing.get("normal_ip"):
                state["normal_ip"] = existing.get("normal_ip")
        state["timestamp"] = time.time()
        temp_state = STATE_FILE.with_suffix(".tmp")
        temp_state.write_text(json.dumps(state, indent=2))
        temp_state.replace(STATE_FILE)
        logger.warning(f"Failed to save VPN state: {e}")
def load_vpn_state() -> dict:
            state = json.loads(STATE_FILE.read_text())
            if time.time() - state.get("timestamp", 0) < 300:
                "normal_ip": state.get("normal_ip"),
                "timestamp": time.time(),
        logger.warning(f"Failed to load VPN state: {e}")

================
File: src/nyord_vpn/utils/__init__.py
================


================
File: src/nyord_vpn/utils/connection.py
================
def is_openvpn_running() -> bool:
    for proc in psutil.process_iter(["name"]):
        if proc.info.get("name") == "openvpn":
def compute_connection_status(

================
File: src/nyord_vpn/utils/templates.py
================
CACHE_DIR = Path.home() / ".cache" / "nyord-vpn"
def log_debug(msg: str, *args: object, **kwargs: object) -> None:
    if logger.level("DEBUG").no <= logger.level("INFO").no:
        logger.debug(msg.format(*args, **kwargs))
def calculate_sha256(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()
def verify_file_integrity(path: Path, expected_hash: str) -> bool:
        actual_hash = calculate_sha256(path.read_bytes())
        log_debug("Failed to verify file integrity: {}", e)
def get_zip_age() -> timedelta | None:
        if not CONFIG_ZIP.exists():
        mtime = datetime.fromtimestamp(CONFIG_ZIP.stat().st_mtime)
        return datetime.now() - mtime
        log_debug("Failed to get ZIP file age: {}", e)
def is_zip_expired() -> bool:
    age = get_zip_age()
    return age > timedelta(days=ZIP_MAX_AGE_DAYS)
def secure_directory(path: Path, mode: int = 0o700) -> None:
        path.mkdir(mode=mode, parents=True, exist_ok=True)
        stat_info = path.stat()
            path.chmod(mode)
            log_debug("Fixed directory permissions for {}", path)
        user_id = os.getuid()
        group_id = os.getgid()
            os.chown(path, user_id, group_id)
                subprocess.run(
                    ["sudo", "chown", f"{user_id}:{group_id}", str(path)],
                raise VPNConfigError(
                    f"Failed to set ownership with sudo: {e.stderr.decode()}"
        log_debug("Set ownership of {} to {}:{}", path, user_id, group_id)
        raise VPNConfigError(f"Failed to secure directory {path}: {e}")
def cleanup_old_configs() -> None:
        existing_configs = list(CONFIG_DIR.glob("*.tcp.ovpn"))
        if len(existing_configs) > MAX_CACHED_CONFIGS:
            log_debug("Cleaning up old config files...")
            existing_configs.sort(key=lambda p: p.stat().st_mtime)
                    config.unlink()
                    log_debug("Removed old config: {}", config)
                    log_debug("Failed to remove old config {}: {}", config, e)
        log_debug("Failed to cleanup old configs: {}", e)
def download_with_retry(
    for attempt in range(MAX_RETRIES):
                jitter = random.uniform(0, 0.1) * delay
                log_debug(
                time.sleep(sleep_time)
            response = requests.get(url, headers=headers, timeout=timeout)
            response.raise_for_status()
            content_hash = calculate_sha256(content)
            if isinstance(e, requests.HTTPError) and (
            delay = min(delay * 2, MAX_RETRY_DELAY)
                "Download failed (attempt {}/{}): {}", attempt + 1, MAX_RETRIES, str(e)
    if isinstance(last_error, requests.HTTPError):
def extract_config_from_zip(server: str) -> Path:
        secure_directory(CONFIG_DIR)
        cleanup_old_configs()
        log_debug("Extracting config file {} from {}", zip_path, CONFIG_ZIP)
            with zipfile.ZipFile(CONFIG_ZIP) as zip_ref:
                    zip_ref.getinfo(zip_path)
                    file_hash = calculate_sha256(zip_ref.read(zip_path))
                    zip_ref.extract(zip_path, CONFIG_DIR)
                    if not verify_file_integrity(extracted_path, file_hash):
                        raise VPNConfigError("Extracted file is corrupted")
                        for name in zip_ref.namelist()
                        if name.startswith("ovpn_tcp/") and name.endswith(".tcp.ovpn")
                    log_debug("Available TCP configs in ZIP: {}", len(tcp_configs))
                        log_debug("Sample configs: {}", tcp_configs[:5])
                        f"ZIP contains {len(tcp_configs)} TCP configs."
            with contextlib.suppress(Exception):
                CONFIG_ZIP.unlink()
            raise VPNConfigError(f"Corrupted ZIP file: {e}") from e
            extracted_path.rename(config_path)
            if not verify_file_integrity(config_path, file_hash):
                raise VPNConfigError("Config file corrupted during move")
            raise VPNConfigError(f"Failed to move config file: {e}") from e
        with contextlib.suppress(FileNotFoundError, OSError):
            (CONFIG_DIR / "ovpn_tcp").rmdir()
            config_path.chmod(0o600)
            log_debug("Set permissions on {}", config_path)
            raise VPNConfigError(f"Failed to set config file permissions: {e}") from e
        raise VPNConfigError(f"Failed to extract configuration: {e}")
def download_config_zip() -> None:
        secure_directory(CACHE_DIR)
        temp_zip = CACHE_DIR / f".ovpn.{os.getpid()}.zip.tmp"
            log_debug("Downloading OpenVPN configurations...")
            content, content_hash = download_with_retry(OVPN_CONFIG_URL, HEADERS)
                temp_zip.write_bytes(content)
                temp_zip.chmod(0o600)
                if not verify_file_integrity(temp_zip, content_hash):
                    raise VPNConfigError("Downloaded file corrupted during write")
                raise VPNConfigError(f"Failed to write temporary ZIP file: {e}") from e
                with zipfile.ZipFile(temp_zip) as zip_ref:
                    log_debug("ZIP contains {} TCP configs", len(tcp_configs))
                raise VPNConfigError("Downloaded file is not a valid ZIP") from e
                temp_zip.replace(CONFIG_ZIP)
                if not verify_file_integrity(CONFIG_ZIP, content_hash):
                    raise VPNConfigError("ZIP file corrupted during move")
                log_debug("OpenVPN configurations cached at {}", CONFIG_ZIP)
                raise VPNConfigError(f"Failed to save ZIP file: {e}") from e
                if temp_zip.exists():
                    temp_zip.unlink()
        raise VPNConfigError(f"Failed to download/cache configurations: {e}")
def get_config_path(server: str) -> Path:
    server = server.replace(".tcp", "")
    log_debug("Looking for config file at: {}", config_path)
    if is_zip_expired():
            log_debug("ZIP file is {} days old, downloading fresh copy...", age.days)
            log_debug("ZIP file is missing, downloading...")
        if CONFIG_ZIP.exists():
                log_debug("Failed to remove old ZIP file: {}", e)
        download_config_zip()
    if not config_path.exists():
        log_debug("Config file not found at: {}", config_path)
        config_path = extract_config_from_zip(server)
        log_debug("Successfully extracted config to: {}", config_path)
        stat_info = config_path.stat()
            log_debug("Fixed config file permissions for {}", config_path)
        raise VPNConfigError(f"Failed to verify config file permissions: {e}")

================
File: src/nyord_vpn/utils/utils.py
================
console = Console()
CACHE_DIR = Path(user_cache_dir(APP_NAME, APP_AUTHOR))
CONFIG_DIR = Path(user_config_dir(APP_NAME, APP_AUTHOR))
CACHE_DIR.mkdir(mode=0o700, parents=True, exist_ok=True)
CONFIG_DIR.mkdir(mode=0o700, parents=True, exist_ok=True)
PACKAGE_DIR = Path(__file__).parent
def check_root() -> bool:
    return os.geteuid() == 0
def ensure_root() -> None:
    if not check_root():
            if cmd[0].startswith("sudo"):
            env = os.environ.copy()
            if os.environ.get("VIRTUAL_ENV"):
                nyord_vpn_path = os.path.join(
                if os.path.exists(nyord_vpn_path):
            console.print(
            if logger.level("DEBUG").no <= logger.level("INFO").no:
                logger.debug(f"Running command: {' '.join(args)}")
            subprocess.run(args, env=env, check=True)
            sys.exit(0)
            console.print("[red]Error: Admin privileges required.[/red]")
            console.print("[yellow]Run the command again with sudo:[/yellow]")
            console.print(f"[blue]sudo -E {' '.join(sys.argv)}[/blue]")
                logger.debug(f"Command failed with error: {e}")
            sys.exit(1)
def is_process_running(process_id: int) -> bool | None:
        os.kill(process_id, 0)
def ensure_data_dir() -> None:
    DATA_DIR.mkdir(parents=True, exist_ok=True)
ensure_data_dir()
    with open(COUNTRY_IDS_FILE) as f:
        NORDVPN_COUNTRY_IDS: dict[str, str] = json.load(f)
def save_vpn_state(state: dict) -> None:
        if STATE_FILE.exists():
            with contextlib.suppress(json.JSONDecodeError):
                existing = json.loads(STATE_FILE.read_text())
        if not state.get("connected") and state.get("current_ip"):
        elif state.get("connected") and state.get("current_ip"):
            if not state.get("normal_ip") and existing.get("normal_ip"):
                state["normal_ip"] = existing.get("normal_ip")
        state["timestamp"] = time.time()
        temp_state = STATE_FILE.with_suffix(".tmp")
        temp_state.write_text(json.dumps(state, indent=2))
        temp_state.chmod(0o600)
        temp_state.replace(STATE_FILE)
            logger.debug(f"Saved state to {STATE_FILE}: {json.dumps(state, indent=2)}")
        logger.warning(f"Failed to save VPN state: {e}")
def load_vpn_state() -> dict:
                state = json.loads(STATE_FILE.read_text())
                    logger.debug(
                        f"Loaded state from {STATE_FILE}: {json.dumps(state, indent=2)}"
                if time.time() - state.get("timestamp", 0) < 300:
                    "normal_ip": state.get("normal_ip"),
                    "timestamp": time.time(),
                logger.warning(f"Failed to parse state file: {e}")
        logger.warning(f"Failed to load VPN state: {e}")

================
File: src/nyord_vpn/__init__.py
================


================
File: src/nyord_vpn/__main__.py
================
console = Console()
load_dotenv()
class CLI:
    def __init__(self, verbose: bool = False) -> None:
            username = os.getenv("NORD_USER") or os.getenv("NORDVPN_LOGIN")
            password = os.getenv("NORD_PASSWORD") or os.getenv("NORDVPN_PASSWORD")
                console.print("[red]Error: Missing credentials[/red]")
                console.print("Please set the following environment variables:")
                console.print("  NORD_USER or NORDVPN_LOGIN")
                console.print("  NORD_PASSWORD or NORDVPN_PASSWORD")
                sys.exit(1)
            self.client = Client(username, password, verbose=verbose)
            console.print(f"[red]Error:[/red] {e}")
    def go(self, country_code: str) -> None:
        check_root()
            self.client.go(country_code)
    def bye(self) -> None:
            self.client.bye()
    def info(self) -> None:
            self.client.info()
    def update(self) -> None:
            fetch_countries()
            console.print("[green]Successfully updated country information[/green]")
            console.print(f"[red]Error updating country information:[/red] {e}")
def main() -> None:
        fire.Fire(CLI)
    main()

================
File: src/nyord_vpn/exceptions.py
================
class NyordVPNError(Exception):
    def __init__(
        super().__init__(self._format_message())
    def _format_message(self) -> str:
class VPNError(NyordVPNError):
        super().__init__(message, details, cause)
class CredentialsError(NyordVPNError):
class ServerNotFoundError(NyordVPNError):
class VPNConfigError(VPNError):
class VPNServerError(NyordVPNError):
class VPNAuthenticationError(VPNError):
class VPNTimeoutError(NyordVPNError):
class VPNProcessError(VPNError):
class VPNConnectionError(VPNError):
class VPNDisconnectionError(VPNError):
class VPNAPIError(VPNError):

================
File: tests/integration/__init__.py
================


================
File: tests/integration/test_config_loading.py
================
async def test_file_loading(temp_dir) -> None:
        "password": TEST_PASSWORD.get_secret_value(),
    config_file.write_text(json.dumps(config_data))
    client = Client.from_file(config_file)
    assert client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert client.config.config_dir == Path("custom/config/dir").resolve()
    config = VPNConfig.from_file(config_file)
    assert config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
    assert config.config_dir == Path("custom/config/dir").resolve()
async def test_environment_loading_unprefixed(monkeypatch) -> None:
    monkeypatch.setenv("NORD_USER", TEST_USERNAME)
    monkeypatch.setenv("NORD_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Norway")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "4")
    client = Client.from_env()
async def test_environment_loading_prefixed(monkeypatch) -> None:
    monkeypatch.setenv("NORDVPN_USERNAME", TEST_USERNAME)
    monkeypatch.setenv("NORDVPN_PASSWORD", TEST_PASSWORD.get_secret_value())
    monkeypatch.setenv("NORDVPN_DEFAULT_COUNTRY", "Sweden")
    monkeypatch.setenv("NORDVPN_RETRY_ATTEMPTS", "5")
async def test_environment_loading_precedence(monkeypatch) -> None:
    monkeypatch.setenv("NORD_USER", "unprefixed_user")
    monkeypatch.setenv("NORD_PASSWORD", "unprefixed_pass")
    monkeypatch.setenv("NORDVPN_USERNAME", "prefixed_user")
    monkeypatch.setenv("NORDVPN_PASSWORD", "prefixed_pass")
    assert client.config.password.get_secret_value() == "unprefixed_pass"
async def test_default_values() -> None:
    config = VPNConfig(username="test", password="test")
    assert config.password.get_secret_value() == "test"
    assert config.config_dir == Path.home() / ".cache" / "nyord-vpn"
    client = Client(username="test", password="test")
    assert client.config.password.get_secret_value() == "test"
    assert client.config.config_dir == Path.home() / ".cache" / "nyord-vpn"
async def test_config_file_precedence(temp_dir, monkeypatch) -> None:
    monkeypatch.setenv("NORD_USER", "env_user")
    monkeypatch.setenv("NORD_PASSWORD", "env_pass")
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "45")
    client = Client.from_file(
        password=TEST_PASSWORD.get_secret_value(),
        client.config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
        config.password.get_secret_value() == TEST_PASSWORD.get_secret_value()
async def test_config_validation(temp_dir) -> None:
    with pytest.raises(ValueError, match="ensure this value is greater than 0"):
        VPNConfig.from_file(config_file)
    with pytest.raises(ValueError, match="Failed to setup config directory"):
    with pytest.raises(ValueError, match="Field required"):
def test_load_from_file(tmp_path: Path) -> None:
    config_path.write_text(json.dumps(config_data))
    client = Client(config_file=config_path)
    config = VPNConfig.from_file(config_path)
def test_load_from_env(monkeypatch) -> None:
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "30")
    client = Client()  # Will load from env by default
    config = VPNConfig.from_env()
def test_direct_initialization() -> None:
    config = VPNConfig(
    client = Client(
def test_invalid_config_file(tmp_path: Path) -> None:
    with pytest.raises(FileNotFoundError):
        VPNConfig.from_file(tmp_path / "nonexistent.json")
    invalid_path.write_text("invalid json content")
    with pytest.raises(json.JSONDecodeError):
        VPNConfig.from_file(invalid_path)
    empty_path.write_text("{}")
    with pytest.raises(ValueError):
        VPNConfig.from_file(empty_path)
def test_invalid_environment(monkeypatch) -> None:
        VPNConfig.from_env()
    monkeypatch.setenv("NORDVPN_API_TIMEOUT", "invalid")

================
File: tests/integration/test_connection.py
================
async def test_connection_success(
        await client.connect()
        status = await client.status()
    mock_client.primary_api.connect.side_effect = VPNError("Primary API failed")
async def test_connection_failure(
    mock_client.fallback_api.connect.side_effect = VPNError("Fallback API failed")
    with pytest.raises(VPNConnectionError, match="Both primary and fallback failed"):
    mock_aiohttp_session.get.side_effect = asyncio.TimeoutError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
    mock_subprocess.side_effect = Exception("Subprocess error")
async def test_country_selection(
        await client.connect("Test Country")
    mock_client.primary_api.connect.side_effect = VPNError("Invalid country")
    mock_client.fallback_api.connect.side_effect = VPNError("Invalid country")
    with pytest.raises(VPNConnectionError, match="Invalid country"):
            await client.connect("Invalid Country")

================
File: tests/integration/test_errors.py
================
async def test_network_errors(
    mock_aiohttp_session.get.side_effect = asyncio.TimeoutError()
    with pytest.raises(VPNConnectionError, match="Failed to connect"):
            await client.connect()
    mock_aiohttp_session.get.side_effect = ConnectionRefusedError()
    mock_aiohttp_session.get.side_effect = Exception("DNS resolution failed")
    mock_aiohttp_session.get.side_effect = Exception("SSL verification failed")
async def test_subprocess_errors(
    mock_subprocess.side_effect = FileNotFoundError("openvpn not found")
    with pytest.raises(VPNConfigError):
    mock_subprocess.side_effect = subprocess.SubprocessError("OpenVPN error")
    with pytest.raises(VPNConnectionError):
async def test_configuration_errors(
    with pytest.raises(VPNConfigError, match="Field required"):
        VPNClient()
    config_file.write_text("invalid = toml [ content")
    with pytest.raises(VPNConfigError, match="Failed to load configuration"):
        VPNClient(config_file=config_file)
        VPNClient(config_file=temp_dir / "nonexistent.toml")
    config_file.write_text(
    with pytest.raises(VPNConfigError, match="Failed to setup config directory"):
async def test_api_errors(
        json.JSONDecodeError("Invalid JSON", "{", 0)
async def test_error_recovery(
        asyncio.TimeoutError(),  # First attempt fails
        MagicMock(  # Second attempt succeeds
            json=AsyncMock(
        result = await client.connect()
        status = await client.status()
        Exception("First attempt failed"),  # First attempt fails
            communicate=AsyncMock(return_value=(b"Success", b"")),
async def test_invalid_credentials() -> None:
    client = VPNClient(username="invalid", password=TEST_PASSWORD.get_secret_value())
async def test_network_errors() -> None:
    client = VPNClient(
        password=TEST_PASSWORD.get_secret_value(),
    with pytest.raises(VPNError):
        await client.status()
        await client.list_countries()
async def test_timeout_handling(tmp_path: Path) -> None:
        "password": TEST_PASSWORD.get_secret_value(),
    config_path.write_text(json.dumps(config_data))
    client = VPNClient(config_file=config_path)
async def test_retry_behavior(tmp_path: Path) -> None:
async def test_fallback_behavior() -> None:
    assert await client.connect() is True
    await client.disconnect()
async def test_invalid_country() -> None:
        await client.connect("Invalid Country")
        await client.connect("")
async def test_cleanup_after_error(
    mock_client.primary_api.connect.side_effect = VPNError("Connection failed")
    mock_client.fallback_api.connect.side_effect = VPNError("Connection failed")
    status = mock_client.status()

================
File: tests/integration/test_validation_integration.py
================
@pytest.fixture(autouse=True)
def clear_env():
    os.environ.pop("NORD_USER", None)
    os.environ.pop("NORD_PASSWORD", None)
def test_invalid_credentials_njord() -> None:
    with pytest.raises(VPNError, match="Missing credentials"):
        NjordVPNClient()
def test_invalid_credentials_legacy() -> None:
        LegacyVPNClient()
def test_invalid_country_njord() -> None:
    with pytest.raises(VPNError):
        client = NjordVPNClient()
        client.connect("Invalid Country")
def test_invalid_country_legacy() -> None:
        client = LegacyVPNClient()

================
File: tests/__init__.py
================


================
File: tests/conftest.py
================
def mock_env_credentials(monkeypatch) -> None:
    monkeypatch.setenv("NORD_USER", "test_user")
    monkeypatch.setenv("NORD_PASSWORD", "test_pass")
def mock_openvpn():
    with patch("subprocess.run") as mock_run:
def mock_requests():
    with patch("requests.get") as mock_get:
def mock_process():
    with patch("subprocess.Popen") as mock_popen:
def mock_client(mock_env_credentials, mock_openvpn, mock_requests, mock_process):
    with patch("nyord_vpn.api.legacy.LegacyVPNClient") as mock_legacy:
        client = Client()
def temp_config_file(tmp_path):
    config_file.write_text(json.dumps(config))
def mock_ip_info():

================
File: tests/test_api.py
================
def sample_country() -> dict:
def sample_group_type() -> dict:
def sample_group(sample_group_type) -> dict:
def sample_technology() -> dict:
def sample_server(sample_group_type) -> dict:
def test_get_countries(sample_country) -> None:
    with patch("requests.get") as mock_get:
        mock_response = MagicMock()
        client = NordVPNAPI()
        countries = client.get_countries()
        assert len(countries) == 1
        assert len(countries[0].cities) == 1
def test_get_groups(sample_group) -> None:
        groups = client.get_groups()
        assert len(groups) == 1
def test_get_technologies(sample_technology) -> None:
        technologies = client.get_technologies()
        assert len(technologies) == 1
def test_get_servers(sample_server) -> None:
        servers = client.get_servers()
        assert len(servers[0]) == 1  # First element is list of servers
        assert len(server.locations) == 1
        assert len(server.technologies) == 1
        assert len(server.groups) == 1

================
File: tests/test_client.py
================
def test_client_connect(mock_client) -> None:
    result = mock_client.connect("Test Country")
    status = mock_client.status()
def test_client_disconnect(mock_client) -> None:
    mock_client.connect("Test Country")
    result = mock_client.disconnect()
def test_client_list_countries(mock_client) -> None:
    countries = mock_client.list_countries()
    assert isinstance(countries, list)
    assert len(countries) > 0
    assert all(isinstance(c, dict) for c in countries)
    assert all("name" in c and "code" in c for c in countries)
def test_client_error_handling(mock_client, mocker) -> None:
    mocker.patch.object(
        side_effect=VPNError("Test error"),
    with pytest.raises(VPNError, match="Test error"):
async def test_client_context_manager(mock_client) -> None:
        result = await client.connect("Test Country")
        status = await client.status()
    status = await mock_client.status()

================
File: tests/test_legacy_api.py
================
def test_init(mock_env_credentials, mock_openvpn) -> None:
    api = LegacyVPNClient()
    assert api.username == os.getenv("NORD_USER")
    assert isinstance(api.password, str)
    assert api.password == os.getenv("NORD_PASSWORD")
def test_connect_success(
    assert api.connect() is True
def test_connect_failure(
    mock_process.side_effect = requests.RequestException("Failed to connect")
    with pytest.raises(VPNError, match="Failed to connect"):
        api.connect()
def test_disconnect_success(mock_env_credentials, mock_openvpn, mock_process) -> None:
    assert api.disconnect() is True
def test_status_connected(mock_env_credentials, mock_openvpn, mock_ip_info) -> None:
    status = api.status()
def test_list_countries(mock_env_credentials, mock_openvpn, mock_requests) -> None:
    countries = api.list_countries()
    assert len(countries) == 2
    assert all(isinstance(c, dict) for c in countries)
    assert all("name" in c and "code" in c for c in countries)
def test_openvpn_not_found(mock_env_credentials) -> None:
    with pytest.raises(VPNError, match="OpenVPN not found"):
        LegacyVPNClient()
def test_server_not_found(mock_env_credentials, mock_openvpn, mock_requests) -> None:
    with pytest.raises(VPNError, match="No servers found"):
        api.connect("invalid_country")
def test_config_download_error(
    mock_requests.side_effect = requests.RequestException("Failed to download")
    with pytest.raises(VPNError, match="Failed to download"):
def test_process_error(
    mock_process.side_effect = subprocess.SubprocessError("Process failed")
def test_api_credentials() -> None:

================
File: tests/test_package.py
================
def test_version() -> None:

================
File: tests/test_server_manager.py
================
def mock_api_client():
    client = MagicMock(spec=NordVPNAPI)
    client.logger = MagicMock()
def server_manager(mock_api_client):
    return ServerManager(mock_api_client)
def test_openvpn_tcp_validation(server_manager) -> None:
    assert server_manager._is_valid_server(server) is True
    assert server_manager._is_valid_server(server) is False
def test_server_filtering(server_manager, mock_api_client) -> None:
    cache = server_manager.get_servers_cache()
    servers = cache.get("servers", [])
    assert len(servers) == 2
    assert any(s["hostname"] == "tcp1.nordvpn.com" for s in servers)
    assert any(s["hostname"] == "tcp2.nordvpn.com" for s in servers)
    mock_api_client.logger.debug.assert_any_call(

================
File: tests/test_v1_countries.py
================
def sample_city() -> dict:
def sample_country(sample_city) -> dict:
def sample_countries(sample_country) -> list[dict]:
def test_fetch_countries(sample_countries) -> None:
    with patch("requests.get") as mock_get:
        mock_response = MagicMock()
        client = NordVPNCountriesV1()
        countries = client.fetch_countries()
        assert len(countries) == 2
        assert len(countries[0].cities) == 1
def test_get_country_by_code(sample_countries) -> None:
    countries = [Country.model_validate(c) for c in sample_countries]
    us = get_country_by_code(countries, "US")
    de = get_country_by_code(countries, "de")
    with pytest.raises(ValueError):
        get_country_by_code(countries, "XX")
def test_get_countries_by_min_servers(sample_countries) -> None:
    large_countries = get_countries_by_min_servers(countries, 90)
    assert len(large_countries) == 1
    medium_countries = get_countries_by_min_servers(countries, 70)
    assert len(medium_countries) == 2
    no_countries = get_countries_by_min_servers(countries, 200)
    assert len(no_countries) == 0
def test_get_city_by_name(sample_countries) -> None:
    us = Country.model_validate(sample_countries[0])
    de = Country.model_validate(sample_countries[1])
    nyc = get_city_by_name(us, "New York")
    frankfurt = get_city_by_name(de, "Frankfurt")
    nyc_lower = get_city_by_name(us, "new york")
        get_city_by_name(us, "Chicago")

================
File: tests/test_v1_groups.py
================
def sample_group_type() -> dict:
def sample_group(sample_group_type) -> dict:
def sample_groups(sample_group_type) -> list[dict]:
def test_fetch_groups(sample_groups) -> None:
    with patch("requests.get") as mock_get:
        mock_response = MagicMock()
        client = NordVPNGroupsV1()
        groups = client.fetch_groups()
        assert len(groups) == 3
def test_get_groups_by_type(sample_groups) -> None:
        legacy_groups = get_groups_by_type(groups, "legacy_group_category")
        assert len(legacy_groups) == 2
        assert all(
        region_groups = get_groups_by_type(groups, "regions")
        assert len(region_groups) == 1
        unknown_groups = get_groups_by_type(groups, "unknown")
        assert len(unknown_groups) == 0
def test_get_group_by_identifier(sample_groups) -> None:
        p2p = get_group_by_identifier(groups, "legacy_p2p")
        europe = get_group_by_identifier(groups, "europe")
        with pytest.raises(ValueError):
            get_group_by_identifier(groups, "unknown")

================
File: tests/test_v1_recommendations.py
================
def sample_city() -> dict:
def sample_country(sample_city) -> dict:
def sample_location(sample_country) -> dict:
def sample_group() -> dict:
def sample_service() -> dict:
def sample_technology() -> dict:
def sample_server(
def test_fetch_recommendations(sample_server) -> None:
    with patch("requests.get") as mock_get:
        mock_response = MagicMock()
        client = NordVPNRecommendationsV1()
        servers = client.fetch_recommendations()
        assert len(servers) == 1
        assert len(server.locations) == 1
        assert len(server.groups) == 1
        assert len(server.services) == 1
def test_get_recommendations_by_country(sample_server) -> None:
        us_servers = get_recommendations_by_country(servers, "US")
        assert len(us_servers) == 1
        us_servers_lower = get_recommendations_by_country(servers, "us")
        assert len(us_servers_lower) == 1
        de_servers = get_recommendations_by_country(servers, "DE")
        assert len(de_servers) == 0
def test_get_recommendations_by_group(sample_server) -> None:
        p2p_servers = get_recommendations_by_group(servers, "legacy_p2p")
        assert len(p2p_servers) == 1
        standard_servers = get_recommendations_by_group(servers, "standard")
        assert len(standard_servers) == 0

================
File: tests/test_v1_technologies.py
================
def sample_technology() -> dict:
def sample_technologies(sample_technology) -> list[dict]:
def test_fetch_technologies(sample_technologies) -> None:
    with patch("requests.get") as mock_get:
        mock_response = MagicMock()
        client = NordVPNTechnologiesV1()
        technologies = client.fetch_technologies()
        assert len(technologies) == 3
def test_get_technology_by_identifier(sample_technologies) -> None:
        udp = get_technology_by_identifier(technologies, "openvpn_udp")
        ikev2 = get_technology_by_identifier(technologies, "ikev2")
        with pytest.raises(ValueError):
            get_technology_by_identifier(technologies, "unknown")

================
File: tests/test_v2_servers.py
================
def sample_technology_metadata() -> dict:
def sample_tech() -> dict:
def sample_ip() -> dict:
def sample_server_ip(sample_ip) -> dict:
def sample_specification_value() -> dict:
def sample_specification(sample_specification_value) -> dict:
def sample_group_type() -> dict:
def sample_group(sample_group_type) -> dict:
def sample_service() -> dict:
def sample_city() -> dict:
def sample_country(sample_city) -> dict:
def sample_location(sample_country) -> dict:
def sample_server(
def sample_api_response(
def test_fetch_all(sample_api_response) -> None:
    with patch("requests.get") as mock_get:
        mock_response = MagicMock()
        client = NordVPNServersV2()
        servers, groups, services, locations, technologies = client.fetch_all()
        assert len(servers) == 1
        assert len(server.ips) == 1
        assert len(server.specifications) == 1
        assert len(server.technologies) == 1
        assert len(server.groups) == 1
        assert len(server.services) == 1
        assert len(server.locations) == 1
        assert len(groups) == 1
        assert len(services) == 1
        assert len(locations) == 1
        assert len(technologies) == 1
def test_get_servers_by_country(sample_api_response) -> None:
        servers, *_ = client.fetch_all()
        us_servers = get_servers_by_country(servers, "US")
        assert len(us_servers) == 1
        us_servers_lower = get_servers_by_country(servers, "us")
        assert len(us_servers_lower) == 1
        de_servers = get_servers_by_country(servers, "DE")
        assert len(de_servers) == 0
def test_get_servers_by_group(sample_api_response) -> None:
        p2p_servers = get_servers_by_group(servers, "legacy_p2p")
        assert len(p2p_servers) == 1
        standard_servers = get_servers_by_group(servers, "standard")
        assert len(standard_servers) == 0

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: cleanup.py
================
LOG_FILE = Path("CLEANUP.txt")
os.chdir(Path(__file__).parent)
def new() -> None:
    if LOG_FILE.exists():
        LOG_FILE.unlink()
def prefix() -> None:
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)
def suffix() -> None:
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
def log_message(message: str) -> None:
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with LOG_FILE.open("a") as f:
        f.write(log_line)
def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
        result = subprocess.run(cmd, check=check, capture_output=True, text=True)
            log_message(result.stdout)
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        return subprocess.CompletedProcess(cmd, 1, "", str(e))
def check_command_exists(cmd: str) -> bool:
        subprocess.run(["which", cmd], check=True, capture_output=True)
class Cleanup:
    def __init__(self) -> None:
        self.workspace = Path.cwd()
    def _print_header(self, message: str) -> None:
        log_message(f"\n=== {message} ===")
    def _check_required_files(self) -> bool:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
    def _generate_tree(self) -> None:
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            tree_result = run_command(
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)
            log_message("\nProject structure:")
            log_message(tree_text)
            log_message(f"Failed to generate tree: {e}")
    def _git_status(self) -> bool:
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())
    def _venv(self) -> None:
        log_message("Setting up virtual environment")
            run_command(["uv", "venv"])
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                log_message("Virtual environment created and activated")
                log_message("Virtual environment created but activation failed")
            log_message(f"Failed to create virtual environment: {e}")
    def _install(self) -> None:
        log_message("Installing package with all extras")
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
            log_message(f"Failed to install package: {e}")
    def _run_checks(self) -> None:
            log_message(
                ">>>\n>>> {}...\n>>> TODO: Check the errors!\n>>>".format(
            run_command(
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)
            run_command(["python", "-m", "vulture", "src"], check=False)
                ">>>\n>>> {}...\n>>> TODO: Try to fix the problems, always think whether the test actually makes sense, then adjust the implementation or the test!\n>>>".format(
            run_command(["python", "-m", "pytest", "tests"], check=False)
                ">>>\n>>> {}...\n>>> TODO: Check the output!\n>>>".format(
            log_message("All checks completed")
            log_message(f"Failed during checks: {e}")
    def status(self) -> None:
        prefix()  # Add README.md content at start
        self._print_header("Current Status")
        self._check_required_files()
        self._generate_tree()
        result = run_command(["git", "status"], check=False)
        self._print_header("Environment Status")
        self._install()
        self._run_checks()
        suffix()  # Add TODO.md content at end
    def venv(self) -> None:
        self._print_header("Virtual Environment Setup")
    def install(self) -> None:
        self._print_header("Package Installation")
    def update(self) -> None:
        self.status()
        if self._git_status():
            log_message("Changes detected in repository")
                run_command(["git", "add", "."])
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
                log_message(f"Failed to commit changes: {e}")
            log_message("No changes to commit")
    def push(self) -> None:
        self._print_header("Pushing Changes")
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
            log_message(f"Failed to push changes: {e}")
def print_usage() -> None:
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")
def main() -> NoReturn:
    new()  # Clear log file
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    cleanup = Cleanup()
            cleanup.status()
            cleanup.venv()
            cleanup.install()
            cleanup.update()
            cleanup.push()
        log_message(f"Error: {e}")
    print(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Explicitly exit to satisfy NoReturn type
    main()

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.toml
================
# Package configuration
[package]
include_cli = true        # Include CLI boilerplate
include_logging = true    # Include logging setup
use_pydantic = true      # Use Pydantic for data validation
use_rich = true          # Use Rich for terminal output

[features]
mkdocs = false           # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows

================
File: PROGRESS.md
================
# Progress Report

## Overview
This progress report tracks the refactoring of the nyord-vpn codebase.

The primary focus of the refactoring effort is to:
1. Improve code quality and maintainability
2. Enhance error handling and user feedback
3. Strengthen security with better validation and randomization
4. Update the API interface for better usability
5. Add comprehensive documentation and testing

Current status: Completed initial refactoring of API and core modules, with focus shifting to improving error handling, fixing test failures, and breaking down complex methods.

## Completed Tasks

- [x] Add module docstrings to all files
- [x] Rename `ConnectionError` to `VPNConnectionError`
- [x] Make boolean parameters keyword-only
- [x] Move main blocks to test files
- [x] API Module refactoring
  - [x] Make `api.py` the central API interface with `NordVPNAPI` class
  - [x] Implement `find_best_server` method with v2 API support and v1 fallback
  - [x] Add deprecation notices and clean up `v1_*.py` files
  - [x] Fix linting issues and improve type hints in `v2_servers.py`
- [x] Core Module initial clean-up
  - [x] Add deprecation warnings to `api.py` and `base.py`
  - [x] Fix boolean positional arguments
- [x] Network Module - `vpn_commands.py`
  - [x] Create `OpenVPNConfig` dataclass with proper validation
  - [x] Implement `get_openvpn_command` function with proper validation
- [x] Network Module - `server.py`
  - [x] Replace random module with secrets module for secure randomization
  - [x] Fix type compatibility issues:
    - [x] Fix Technology type in server_technologies creation
    - [x] Fix parameter type in _select_diverse_servers function 
    - [x] Fix return type in get_country_info function
  - [x] Address security issues in subprocess calls by enhancing hostname validation
  - [x] Add comprehensive type hints for return types, parameters and variables
- [x] Core Module
  - [x] Refactor `client.py` to use the new `NordVPNAPI` class
  - [x] Update `tests/test_server_manager.py` to use `NordVPNAPI` instead of `NordVPNAPIClient`

## Current Tasks

### High Priority

#### Core Module - `client.py`
- [x] Improve error handling and user feedback
  - [x] Add more detailed error messages with troubleshooting steps
  - [x] Implement proper exception handling with specific exception types
  - [x] Add recovery suggestions in error messages
- [ ] Break down complex methods into smaller helper functions
  - [ ] Refactor the `go()` method into smaller functions for each step
  - [ ] Extract connection validation logic into separate functions
  - [ ] Create helper functions for environment variable handling
- [ ] Fix boolean arguments and other linting issues
  - [ ] Make all boolean parameters keyword-only arguments
  - [ ] Fix type annotations for better static analysis
  - [ ] Add proper validation for function parameters

#### Tests
- [ ] Fix test failures
  - [ ] Fix test_openvpn_tcp_validation failure in ServerManager class
  - [ ] Fix test_fetch_all, test_get_servers_by_country, and test_get_servers_by_group failures related to server relationships
  - [ ] Fix test_get_servers test failure related to locations relationship
  - [ ] Fix test_server_filtering failure related to mock implementation
- [ ] Fix import errors in integration tests
  - [ ] Update imports in tests to use `nyord_vpn.exceptions` instead of `nyord_vpn.core.exceptions`
  - [ ] Update class references from `VPNClient` to `Client`
- [ ] Update test fixtures to include missing fields:
  - [ ] Add `type` field to Group model in test fixtures
  - [ ] Add `server_count` field to Country and City models in test fixtures
- [ ] Fix model validation errors:
  - [ ] Update model validation to handle missing fields gracefully
  - [ ] Add default values for optional fields in model definitions

### Medium Priority

#### Network Module - `vpn.py`
- [ ] Make boolean arguments keyword-only
- [ ] Add comprehensive type hints for all functions and methods
- [ ] Implement retry logic for connection attempts with tenacity
- [ ] Break down complex methods:
  - [ ] Split `setup_connection()` into smaller focused functions
  - [ ] Refactor `connect()` method to improve readability
  - [ ] Extract IP validation logic into a utility function
- [ ] Replace random.uniform with secrets.SystemRandom().uniform for better security
- [ ] Improve error handling with specific exception types and recovery mechanisms

#### Utils Module - `templates.py`
- [ ] Fix security vulnerabilities in subprocess calls (S603, S607)
- [ ] Replace datetime.now() and datetime.fromtimestamp() with timezone-aware versions (DTZ005, DTZ006)
- [ ] Fix exception handling issues:
  - [ ] Replace long error messages with proper exception classes (TRY003)
  - [ ] Use `raise ... from err` consistently (B904)
  - [ ] Move try/except out of loops for better performance (PERF203)
  - [ ] Use `else` blocks appropriately after try/except (TRY300)

### Lower Priority

#### Utils Module - `utils.py`
- [ ] Replace os.path functions with pathlib equivalents (PTH110, PTH118, PTH123)
- [ ] Fix security vulnerability in subprocess call (S603)
- [ ] Fix error handling to use `else` blocks appropriately (TRY300)
- [ ] Implement atomic file operations for state management

#### Main Module - `__main__.py`
- [ ] Update CLI class to use the updated Client API
  - [ ] Replace any usage of deprecated classes/methods with their updated counterparts
  - [ ] Update command-line arguments to match new API structure
  - [ ] Ensure all commands use the new Client implementation
- [ ] Improve error handling and user feedback
  - [ ] Add specific error handling for common user errors
  - [ ] Provide clear, actionable error messages with recovery steps
  - [ ] Add verbose output mode for troubleshooting

## Next Steps

The following immediate next steps have been identified based on test failures and prioritized tasks:

1. **Fix the OpenVPN TCP validation issue in server_manager.py**
   - The `_is_valid_server()` method is incorrectly returning `True` for servers without OpenVPN TCP support
   - Update the logic to properly check for the presence of OpenVPN TCP in the technologies list
   - Add additional logging to help diagnose why the check is failing

2. **Fix model relationship issues in test fixtures**
   - Update sample fixtures to properly include relationships:
     - Add server-to-group relationships in sample_server fixture
     - Add server-to-location relationships in sample_server fixture
     - Add proper type field to Group model in test fixtures
   - Modify fixture functions to ensure relationships are properly established

3. **Fix import errors in integration tests**
   - Update import statements:
     - Change `from nyord_vpn.core.exceptions import ...` to `from nyord_vpn.exceptions import ...`
     - Replace references to `VPNClient` with `Client`
   - Fix mock setup in test_server_manager.py to correctly simulate API response structure

4. **Refactor the Client.go() method into smaller functions**
   - Extract server selection logic into a separate method
   - Create a dedicated method for connection validation
   - Implement retry logic with proper error handling
   - Add detailed error messages with troubleshooting steps for common failures

By addressing these issues, we will improve test reliability and code quality, which will provide a solid foundation for further refactoring work.

### Implementation Plan for Fixing Test Failures

1. **Update the `_is_valid_server()` method in server.py**
   ```python
   def _is_valid_server(self, server: dict) -> bool:
       """Check if a server is valid for OpenVPN TCP connection."""
       # Add debug logging for technologies to diagnose the issue
       if self.verbose:
           technologies = server.get("technologies", [])
           self.logger.debug(f"Server technologies: {technologies}")
           
       # Continue with existing validation logic...
       # Fix the OpenVPN TCP check:
       has_openvpn_tcp = False
       for tech in server.get("technologies", []):
           if isinstance(tech, dict) and "name" in tech:
               tech_name = tech.get("name", "")
               if "OpenVPN TCP" in tech_name:
                   has_openvpn_tcp = True
                   break
       
       if not has_openvpn_tcp:
           if self.verbose:
               self.logger.debug(f"Server {server.get('hostname')} does not support OpenVPN TCP")
           return False
       
       return True
   ```

2. **Update test fixtures for proper relationships**
   ```python
   @pytest.fixture
   def sample_server(sample_group, sample_location, sample_technology):
       """Create a sample server with proper relationships."""
       return {
           "id": 1,
           "name": "us1234.nordvpn.com",
           "station": "us1234",
           "hostname": "us1234.nordvpn.com",
           "status": "online",
           "load": 45,
           "groups": [{"id": 1, "pivot": {"server_id": 1, "group_id": 1}}],
           "locations": [{"id": 1, "pivot": {"server_id": 1, "location_id": 1}}],
           "technologies": [sample_technology],
           # Other fields...
       }
   ```

3. **Fix import errors in integration tests**
   ```python
   # Update imports in affected test files
   from nyord_vpn.exceptions import VPNError, VPNConnectionError
   from nyord_vpn.core.client import Client  # Use Client instead of VPNClient
   ```

4. **Fix mock setup in test_server_manager.py**
   ```python
   # Update the mock to match the actual return structure of the NordVPNAPI.get_servers() method
   mock_api_client.get_servers.return_value = (
       [
           {
               "hostname": "tcp1.nordvpn.com",
               "status": "online",
               "load": 50,
               "country": {"code": "US", "name": "United States"},
               "technologies": [
                   {"id": 5, "name": "OpenVPN TCP", "status": "online"},
               ],
           },
           # More sample servers...
       ],
       [], [], [], []  # Empty lists for groups, services, locations, technologies
   )
   ```

================
File: pyproject.toml
================
# this_file: pyproject.toml
[build-system]
requires = ["setuptools>=45", "setuptools-scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "nyord-vpn"
version = "0.1.0"
description = "NordVPN client with API fallback support"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT"}
keywords = ["vpn", "nordvpn", "security"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "njord>=0.0.1",
    "tenacity>=8.0.0",
    "backoff>=2.0.0",
    "rich>=13.4.2",
    "fire>=0.7.0",
    "pydantic>=2.10.6",
    "pydantic-settings>=2.8.0",
    "requests>=2.31.0",
    "keyring>=24.2.0",
    "pycountry>=24.6.1",
    "psutil>=5.9.5",
    "python-dotenv>=1.0.0",
    "aiohttp>=3.11.0",
    "cryptography>=42.0.0",
    "black>=23.7.0",
    "bleach>=6.0.0",
    "build>=0.10.0",
    "certifi>=2023.5.7",
    "charset-normalizer>=3.2.0",
    "click>=8.1.5",
    "docutils>=0.20.1",
    "idna>=3.4",
    "importlib-metadata>=6.8.0",
    "jaraco-classes>=3.3.0",
    "markdown-it-py>=3.0.0",
    "mdurl>=0.1.2",
    "more-itertools>=9.1.0",
    "mypy-extensions>=1.0.0",
    "packaging>=23.1",
    "pathspec>=0.11.1",
    "pkginfo>=1.9.6",
    "platformdirs>=3.9.1",
    "pygments>=2.15.1",
    "pyproject-hooks>=1.0.0",
    "readme-renderer>=40.0",
    "requests-toolbelt>=1.0.0",
    "rfc3986>=2.0.0",
    "six>=1.16.0",
    "tomli>=2.0.1",
    "twine>=4.0.2",
    "typing-extensions>=4.7.1",
    "urllib3>=2.0.3",
    "webencodings>=0.5.1",
    "zipp>=3.16.2",
    "loguru>=0.7.3",
    "vulture>=2.14",
]

[project.optional-dependencies]
dev = [
    "pre-commit>=3.6.0",
    "ruff>=0.9.7",
    "mypy>=1.0.0",
    "pyupgrade>=3.19.0",
    "autoflake>=2.0.0",
    "isort>=5.10.1",
    "vulture>=2.10",
]

test = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.25.0",
    "pytest-mock>=3.12.0",
    "pytest-timeout>=2.3.0",
    "pytest-xdist>=3.5.0",
]

[project.scripts]
nyord-vpn = "nyord_vpn.__main__:main"

[tool.setuptools]
package-dir = {"" = "src"}
packages = ["nyord_vpn"]
package-data = {"nyord_vpn" = ["data/*.json"]}

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/nyord-vpn#readme"
Issues = "https://github.com/twardoch/nyord-vpn/issues"
Source = "https://github.com/twardoch/nyord-vpn"

[tool.coverage.paths]
nyord_vpn = ["src/nyord_vpn", "*/nyord-vpn/src/nyord_vpn"]
tests = ["tests", "*/nyord-vpn/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
]

[tool.coverage.run]
source_pkgs = ["nyord_vpn", "tests"]
branch = true
parallel = true
omit = [
    "src/nyord_vpn/__about__.py",
]

[tool.hatch.build.hooks.vcs]
version-file = "src/nyord_vpn/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/nyord_vpn"]

[tool.hatch.envs.default]
dependencies = [
]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests {args:tests}"
type-check = "mypy src/nyord_vpn tests"
lint = ["ruff check src/nyord_vpn tests", "ruff format --respect-gitignore src/nyord_vpn tests"]
fix = ["ruff check  --fix --unsafe-fixes src/nyord_vpn tests", "ruff format --respect-gitignore src/nyord_vpn tests"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/nyord_vpn tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}", "vulture src"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}", "vulture src"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.25.0",
    "pytest-mock>=3.12.0",
    "pytest-timeout>=2.3.0",
    "pytest-xdist>=3.5.0",
]

[tool.hatch.envs.test.scripts]
test = "python -m pytest {args:tests}"
test-cov = "python -m pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/nyord_vpn --cov=tests {args:tests}"
bench = "python -m pytest -v tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[tool.ruff]
target-version = "py310"
line-length = 88

[tool.ruff.lint]
select = [
    "A",
    "ANN",
    "ARG",
    "ASYNC",
    "B",
    "C",
    "C4",
    "C90",
    "COM",
    "D",
    "DOC",
    "DTZ",
    "E",
    "ERA",
    "EXE",
    "F",
    "FA",
    "FBT",
    "FIX",
    "FLY",
    "FURB",
    "I",
    "ICN",
    "INP",
    "ISC",
    "N",
    "NPY",
    "PD",
    "PERF",
    "PIE",
    "PL",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "PT",
    "PTH",
    "PYI",
    "Q",
    "RET",
    "RSE",
    "RUF",
    "S",
    "SIM",
    "SLF",
    "T",
    "TC",
    "TD",
    "TID",
    "TRY",
    "UP",
    "W",
    "YTT",
]
ignore = ["ARG001", "COM812", "D203", "D213", "E501", "I001", "RUF001", "PLR2004", "EXE003", "ISC001"]

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase --timeout=30 -n auto"
asyncio_mode = "strict"
asyncio_default_fixture_loop_scope = "function"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning",
    "ignore::pytest.PytestDeprecationWarning",
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "async_test: mark a test as an async test",
    "config: mark a test as a configuration test",
    "connection: mark a test as a connection test",
    "security: mark a test as a security test",
]
testpaths = ["tests"]
timeout = 30

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]

================
File: README.md
================
# nyord-vpn

nyord-vpn is a simple NordVPN client for macOS users. It provides an easy way to manage VPN connections. 

nyord-vpn is primarily designed for macOS, as it relies on OpenVPN, which is easily installable via Homebrew. However, with some modifications, it might be possible to use it on other platforms like Linux or Windows. Contributions to support additional platforms are welcome.

## Key Features

- **Simple and Reliable Connection Management:** Connect and disconnect from VPN with minimal hassle.
- **Support for Legacy OpenVPN and njord APIs:** Choose between different API versions for flexibility.
- **Country Selection:** Connect to servers in specific countries easily.
- **Status Monitoring:** Check the current status of your VPN connection.
- **Clear Error Messages:** Resolve issues quickly with informative error messages.
- **Minimal Dependencies:** Lightweight and easy to set up.

## Installation

To use nyord-vpn, you need to install some system requirements and the package itself.

### System Requirements

- macOS operating system
- OpenVPN installed

### Installing OpenVPN

Install OpenVPN using Homebrew:

```bash
brew install openvpn
```

### Installing nyord-vpn

Install the package using pip:

```bash
pip install nyord-vpn
```


## Configuration

Before using nyord-vpn, set your NordVPN credentials as environment variables:

```bash
export NORD_USER="your-username"
export NORD_PASSWORD="your-password"
```

Replace `"your-username"` and `"your-password"` with your actual NordVPN credentials.

## Usage

nyord-vpn can be used via the command line interface (CLI) or programmatically through its Python API.

### API Options

### CLI Commands

Here are the available CLI commands:

- **`nyord-vpn connect`**: Connects to a NordVPN server. Defaults to a server in the United States.
- **`nyord-vpn connect --country <country>`**: Connects to a server in the specified country. Replace `<country>` with the country name or code (e.g., `netherlands`).
- **`nyord-vpn --api njord connect`**: Uses the njord API to connect to the VPN.
- **`nyord-vpn --verbose connect`**: Connects to the VPN with verbose logging enabled for debugging.
- **`nyord-vpn status`**: Displays the current status of the VPN connection, including connection status, server, and IP address.
- **`nyord-vpn list-countries`**: Lists all available countries with NordVPN servers.
- **`nyord-vpn disconnect`**: Disconnects from the VPN.

**Note:** Some commands, such as connecting and disconnecting, may require sudo privileges. You might be prompted to enter your password.

### Python API

You can use nyord-vpn programmatically in Python:

```python
from nyord_vpn.core.factory import create_client

# Create a client (choose "legacy" or "njord")
client = create_client("legacy")

# Connect to VPN in a specific country
client.connect("netherlands")

# Check connection status
status = client.status()
print(f"Connected to {status['server']} ({status['ip']})")

# Disconnect from VPN
client.disconnect()
```

Ensure you have the necessary permissions to run OpenVPN when using the Python API.

## Development

To contribute to nyord-vpn or modify the code:

1. **Install dependencies:**

   ```bash
   pip install -r requirements.txt
   ```

2. **Install optional njord support:**

   ```bash
   pip install njord
   ```

3. **Run with debug logging:**

   ```bash
   NORD_USER="username" NORD_PASSWORD="password" nyord-vpn --verbose connect
   ```

For a full development setup, clone the repository, create a virtual environment, and install the package in editable mode:

```bash
git clone https://github.com/yourusername/nyord-vpn.git
cd nyord-vpn
python -m venv venv
source venv/bin/activate
pip install -e .
```

Replace `yourusername` with the actual repository owner.

## Error Handling and Troubleshooting

nyord-vpn provides clear error messages to help resolve issues. Common errors include:

- **`VPNCredentialsError`**: Missing or invalid credentials. Ensure `NORD_USER` and `NORD_PASSWORD` are set correctly.
- **`VPNConnectionError`**: Failed to connect or disconnect. Check your internet connection and try again.
- **`VPNConfigError`**: Configuration issues, such as missing OpenVPN. Install OpenVPN if not already installed.
- **`VPNServerError`**: Failed to get server information. Try again later or check your network connection.

### Troubleshooting Tips

- **"OpenVPN not found" error:** Install OpenVPN using `brew install openvpn`.
- **"Authentication failed" error:** Verify your NordVPN credentials in the environment variables.
- **"Failed to connect" error:** Check your internet connection or try a different country/server.
- **"No servers available" error:** Wait a few minutes and try again; this may be a temporary API issue.

### Security Considerations

- **Keep Credentials Secure:** Do not hardcode credentials; use environment variables or secure storage.
- **Update Regularly:** Keep nyord-vpn and dependencies up to date for security patches.
- **Monitor Connections:** Regularly check your connection status.
- **Use Strong Passwords:** Ensure your NordVPN account has a strong, unique password.

## Contributing

We welcome contributions to nyord-vpn! To contribute:

1. Fork the repository.
2. Create a feature branch for your changes.
3. Make your changes and commit them.
4. Submit a pull request with a clear description of your changes.

For issues or questions, open an issue on the [GitHub repository](https://github.com/yourusername/nyord-vpn).

## License

nyord-vpn is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

================
File: TODO.md
================
# TODO

A modern Python client for NordVPN with automatic API fallback support, providing both a CLI interface and a Python library.

```bash
# Install system requirements first
brew install openvpn  # macOS
sudo apt install openvpn  # Ubuntu/Debian
sudo dnf install openvpn  # Fedora/RHEL

# Then install and use the package
pip install nyord-vpn
export NORD_USER="username" NORD_PASSWORD="password"
nyord-vpn go de  # Connect to a German VPN
nyord-vpn info  # Check status
nyord-vpn bye  # Disconnect
```

## DEVELOPMENT

After each set of changes, update @PROGRESS.md with what you've done (`- [x] `). Upgrade priorities for NEXT TODO (`- [!]`), re-think the normal TODO (`- [ ] `)

Periodically do:

```
uv venv; source .venv/bin/activate; uv pip install -e .[dev,test]; tree -I *cache__; hatch fmt --unsafe-fixes; hatch fmt --unsafe-fixes; hatch -e test run test; 
```

and react to the results. Use `uv pip...` instead of `pip...` if needed. 

## Working modality

You'll lead two experts: "Ideot" for creative, unorthodox ideas and "Critin" to critique flawed thinking and moderate for balanced discussions. The three of you shall illuminate knowledge with concise, beautiful responses, process methodically for clear answers, collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.

Independently tackle challenges systematically, being adaptable and resourceful. Research deeply using all tools, revising to ensure conclusive, exhaustive, insightful results. When you're finished, print "Wait, but" to go back, think & reflect, revise & improvement what you've done (but don't invent functionality freely). Repeat this. Focus on minimal viable next versions of the code. Ship often and early. 

## General coding principles

Verify info. No assumptions. No apologies. No major invented changes. No unneeded confirmations or checks. Keep existing code and structures unless they need to change. No unnecessary updates or current implementation discussion. Avoid magic numbers, handle edge cases, use assertions to validate assumptions and catch potential errors early.

Every code can fail. Write code that fails gracefully and is UX friendly: uses retries (within reason), does not make stupid assumptions, tests successes, uses fallbacks and backoffs, and then, if the code needs to message the user, be clear and suggest to the user the next steps. Don't prompt the user to do something that the computer can obviously do. The code should ask the user only if there is a real decision to be made. And you should ask me only if a real decision is needed.  

## Keep track of paths

In every source file you create or edit, always maintain the up-to-date `this_file` record that shows the path of the current file relative to the root of the project. Place the `this_file` record near the top of the file, as a comment after the shebangs, or in the YAML Markdown frontmatter. Use these records for orientation. 

## Follow this style for Python

Follow PEP 8. Write clear names. Keep it simple (PEP 20). Use type hints, imperative docstrings (PEP 257), f-strings, and structural pattern matching. Extract repeated logic. Handle errors. Keep functions small. Prefer flat structures. Use pathlib, pydantic as needed. Write maintainable code. 

EVEN IF YOU'RE NOT prompted, always write a "verbose" mode logugu-based logging for debug purposes, write explanatory docstrings and comments that not only explain what a given item (module, function, method) does, but also why it does it, and where and how it's used elsewhere in the code. 

ONLY IF YOU ARE prompted, extend existing features in a way that adds complexity, or refactor in a way that may break things. Remember: minimal viable next version is always our goal. IF NOT PROMPTED, do NOT make such changes. 

For CLI Python scripts, use fire & rich, and start the script with 

```
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["PKG1", "PKG2"]
# ///
# this_file: PATH_TO_CURRENT_FILE
```

# Nyord VPN Codebase Refactoring TODO

## Remaining Tasks (Prioritized)

### High Priority Items

#### Fix Test Failures
- [!] Fix test_openvpn_tcp_validation failure in ServerManager class
  - Update `_is_valid_server()` method to correctly check for OpenVPN TCP support
  - Add debug logging to diagnose technology validation issues
- [!] Fix test_fetch_all, test_get_servers_by_country, and test_get_servers_by_group failures
  - Update sample fixtures to include proper server relationships
  - Ensure server-to-group relationships are properly established
  - Ensure server-to-location relationships are properly established
- [!] Fix test_get_servers test failure related to locations relationship
- [!] Fix test_server_filtering failure related to mock implementation

#### Fix Import Errors in Integration Tests
- [!] Update import statements in integration tests
  - Change `from nyord_vpn.core.exceptions import ...` to `from nyord_vpn.exceptions import ...`
  - Replace references to `VPNClient` with `Client`
- [!] Fix mock setup in test_server_manager.py to correctly simulate API response structure

#### Core Module - `client.py`
- [!] Break down complex methods into smaller helper functions
  - [!] Refactor the `go()` method into smaller functions for each step:
    - Extract server selection logic into a separate method
    - Create a dedicated method for connection validation
    - Implement retry logic with proper error handling
  - [!] Extract connection validation logic into separate functions
  - [!] Create helper functions for environment variable handling
- [!] Fix boolean arguments and other linting issues
  - [!] Make all boolean parameters keyword-only arguments
  - [!] Fix type annotations for better static analysis
  - [!] Add proper validation for function parameters

### Medium Priority Items

#### Network Module - `vpn.py`
- [!] Make boolean arguments keyword-only
- [!] Add comprehensive type hints for all functions and methods
- [ ] Implement retry logic for connection attempts with tenacity
- [ ] Break down complex methods:
  - [ ] Split `setup_connection()` into smaller focused functions
  - [ ] Refactor `connect()` method to improve readability
  - [ ] Extract IP validation logic into a utility function
- [ ] Replace random.uniform with secrets.SystemRandom().uniform for better security
- [ ] Improve error handling with specific exception types and recovery mechanisms

#### Utils Module - `templates.py`
- [!] Fix security vulnerabilities in subprocess calls (S603, S607)
- [!] Replace datetime.now() and datetime.fromtimestamp() with timezone-aware versions (DTZ005, DTZ006)
- [!] Fix exception handling issues:
  - [!] Replace long error messages with proper exception classes (TRY003)
  - [!] Use `raise ... from err` consistently (B904)
  - [!] Move try/except out of loops for better performance (PERF203)
  - [!] Use `else` blocks appropriately after try/except (TRY300)

### Lower Priority Items

#### Utils Module - `utils.py`
- [!] Replace os.path functions with pathlib equivalents (PTH110, PTH118, PTH123)
- [!] Fix security vulnerability in subprocess call (S603)
- [!] Fix error handling to use `else` blocks appropriately (TRY300)
- [ ] Implement atomic file operations for state management

#### Main Module - `__main__.py`
- [!] Update CLI class to use the updated Client API
  - [!] Replace any usage of deprecated classes/methods with their updated counterparts
  - [!] Update command-line arguments to match new API structure
  - [!] Ensure all commands use the new Client implementation
- [!] Improve error handling and user feedback
  - [!] Add specific error handling for common user errors
  - [!] Provide clear, actionable error messages with recovery steps
  - [!] Add verbose output mode for troubleshooting

## Implementation Steps

### Fixing Test Failures

#### 1. Fix the OpenVPN TCP validation issue in server_manager.py

```python
def _is_valid_server(self, server: dict) -> bool:
    """Check if a server is valid for OpenVPN TCP connection."""
    # Add debug logging for technologies to diagnose the issue
    if self.verbose:
        technologies = server.get("technologies", [])
        self.logger.debug(f"Server technologies: {technologies}")
        
    # Check server status
    if server.get("status") != "online":
        if self.verbose:
            self.logger.debug(f"Server {server.get('hostname')} is not online")
        return False
        
    # Check hostname
    hostname = server.get("hostname", "")
    if not hostname.endswith(".nordvpn.com"):
        if self.verbose:
            self.logger.debug(f"Invalid hostname: {hostname}")
        return False
    
    # Check load
    load = server.get("load", -1)
    if not (0 <= load <= 100):
        if self.verbose:
            self.logger.debug(f"Server {hostname} has invalid load: {load}")
        return False
    
    # Fix the OpenVPN TCP check:
    has_openvpn_tcp = False
    for tech in server.get("technologies", []):
        if isinstance(tech, dict) and "name" in tech:
            tech_name = tech.get("name", "")
            if "OpenVPN TCP" in tech_name:
                has_openvpn_tcp = True
                break
    
    if not has_openvpn_tcp:
        if self.verbose:
            self.logger.debug(f"Server {hostname} does not support OpenVPN TCP")
        return False
    
    return True
```

#### 2. Fix model relationship issues in test fixtures

Update sample_server fixture:
```python
@pytest.fixture
def sample_server(sample_group, sample_location, sample_technology):
    """Create a sample server with proper relationships."""
    return {
        "id": 1,
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z",
        "name": "us1234.nordvpn.com",
        "station": "us1234",
        "hostname": "us1234.nordvpn.com",
        "ipv6_station": "",
        "status": "online",
        "load": 45,
        "groups": [{"id": 1, "pivot": {"server_id": 1, "group_id": 1}}],
        "locations": [{"id": 1, "pivot": {"server_id": 1, "location_id": 1}}],
        "technologies": [sample_technology],
    }
```

### Refactoring the Client.go() Method

Break down the go() method into smaller functions:

```python
def _validate_country_code(self, country_code: str) -> None:
    """Validate that the country code is valid."""
    if not country_code or not isinstance(country_code, str) or len(country_code) != 2:
        raise VPNError(f"Country code must be a two-letter code, got: {country_code!r}")
    
    # Optionally validate against known country codes
    countries = self.list_countries()
    country_codes = [c["code"].lower() for c in countries]
    
    if country_code.lower() not in country_codes:
        raise VPNError(f"Country code '{country_code}' not found in available countries: {', '.join(country_codes)}")

def _select_server(self, country_code: str) -> dict:
    """Select the best server for the specified country."""
    servers = self.server_manager.select_fastest_server(country_code)
    if not servers:
        raise VPNError(f"No servers available in {country_code}")

    # Take the first (fastest) server
    server = servers[0]
    hostname = server.get("hostname")
    if not hostname:
        raise VPNError("Selected server has no hostname")

    if self.verbose:
        self.logger.info(f"Selected server: {hostname}")
        
    return server

def _establish_connection(self, server: dict) -> None:
    """Establish the VPN connection to the specified server."""
    hostname = server.get("hostname")
    
    # Set up VPN configuration
    if not self.username or not self.password:
        raise VPNError("Missing VPN credentials")
        
    self.vpn_manager.setup_connection(hostname, self.username, self.password)

    # Connect to VPN
    if self.verbose:
        self.logger.info("Establishing VPN connection...")
        
    # Connect and wait for result
    self.vpn_manager.connect([server])  # Pass server to try

def go(self, country_code: str) -> None:
    """Connect to VPN in specified country."""
    try:
        # First check if we're already connected
        status = self.status()
        if status.get("connected", False):
            # VPN manager will handle disconnection automatically
            if self.verbose:
                self.logger.info("Already connected, will disconnect before connecting to new server")

        # Validate the country code
        self._validate_country_code(country_code)
        
        # Select the best server
        server = self._select_server(country_code)
        
        # Establish the connection
        self._establish_connection(server)

        # Get status for display
        status = self.status()
        console.print("[green]Successfully connected to VPN[/green]")
        console.print(f"Private IP: [cyan]{status.get('ip', 'Unknown')}[/cyan]")
        console.print(f"Country: [cyan]{status.get('country', 'Unknown')}[/cyan]")
        console.print(f"Server: [cyan]{status.get('server', 'Unknown')}[/cyan]")

    except Exception as e:
        raise VPNError(f"Failed to connect: {e}")
```



================================================================
End of Codebase
================================================================
